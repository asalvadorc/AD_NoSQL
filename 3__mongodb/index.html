<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://asalvadorc.github.io/AD_NoSQL/3__mongodb/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>3 - MongoDB - AD - Accés a Dades</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/extra.css" rel="stylesheet" />
        <link href="../img/favicon.ico" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "3 - MongoDB";
        var mkdocs_page_input_path = "3__mongodb.md";
        var mkdocs_page_url = "/AD_NoSQL/3__mongodb/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="..">
          <img src="../assets/logocaminas.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">UD 5. BD NoSQL</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../1__introducci/">1 - Introducció</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">REDIS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../2__bases_de_dades_clauvalor/">2 - Bases de Dades Clau-Valor (Redis)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../exercicis_redis/">Exercicis</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">MONGO</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">3 - MongoDB</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#31-estructura-json">3.1 - Estructura JSON</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#32-installacio-de-mongodb">3.2 - Instal·lació de MongoDB</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#installacio-en-linux">Instal·lació en Linux</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#installacio-en-windows">Instal·lació en Windows</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#33-utilitzacio-de-mongodb">3.3 - Utilització de MongoDB</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#331-tipus-de-dades">3.3.1 - Tipus de dades</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#332-operacions-basiques">3.3.2 - Operacions bàsiques</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#insercio-elemental-insert">Inserció elemental: insert</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lectura-find">Lectura: find</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#insercio-multiple">Inserció múltiple</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#esborrat-remove">Esborrat: remove</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#actualitzacio-update">Actualització - update</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#333-operacions-dactualitzacio-avancada">3.3.3 - Operacions d'actualització avançada</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set">$set</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#unset">$unset</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#rename">$rename</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#inc">$inc</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#elements-dun-array">Elements d'un array</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#insercio-en-arrays-push">Inserció en Arrays: $push</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#eliminacio-en-arrays-pop-i-pull">Eliminació en arrays: $pop i $pull</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#upsert">Upsert</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#34-consulta-de-documents">3.4 - Consulta de documents</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#341-parametres-de-les-funcions-find-i-findone">3.4.1 - Paràmetres de les funcions find() i findOne()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#342-operadors-de-les-condicions">3.4.2 - Operadors de les condicions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#operadors-de-comparacio">Operadors de comparació</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#expressions-regulars">Expressions regulars</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#343-agregacio">3.4.3 - Agregació</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#match">$match</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#project">$project</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#group">$group</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sort">$sort</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#limit">$limit</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#skip">$skip</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#35-connexio-des-de-kotlin-i-exemples">3.5 - Connexió des de Kotlin i Exemples</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#36-connexio-des-de-kotlin-al-servidor-de-linstitut">3.6 - Connexió des de Kotlin al servidor de l'Institut</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../exercicis_mongo/">Exercicis</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">FIREBASE</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../AD_Firebase/1__introducci_firebase/">4.1 - Introducció</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AD_Firebase/2__creaci_duna_aplicaci/">4.2 - Creació d'una aplicació</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AD_Firebase/3__realtime_database_rd/">4.3 - Realtime Database</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AD_Firebase/4__cloud_firestore_cf/">4.4. - Cloud Firestore</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AD_Firebase/5__cloud_storage/">4.5. - Cloud Storage (opcional)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../AD_Firebase/exercicis/">Exercicis</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">AD - Accés a Dades</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">MONGO</li>
      <li class="breadcrumb-item active">3 - MongoDB</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="3-mongodb">3 - MongoDB</h1>
<p>Segurament <strong>MongoDB</strong> és el més famós dels Sistemes Gestors de Bases de Dades
<strong>NoSQL</strong>.</p>
<p>El nom de <strong>MongoDB</strong> prové de la paraula anglesa <em>hu<strong>mongo</strong>us</em>, que
significa enorme, que és el propòsit d'aquesta Base de Dades: guardar grans
quantitats d'informació. És de codi obert i està programada en C++. El va
crear l'empresa <strong>10gen</strong> (actualment <strong>MongoDB Inc.</strong>)</p>
<p>És un SGBD <strong>Documental</strong> , és a dir, que servirà per a guardar documents. La
manera interna de guardar-los és en format <strong>BSON</strong> (Binary JSON) que en
essència és una variant del JSON per a poder guardar físicament les dades
d'una manera més eficient.</p>
<p>En un servidor Mongo poden haver més d'una Base de Dades, encara que nosaltres
només en gastarem una: <strong>test</strong>.</p>
<ul>
<li>En cada Base de Dades la informació es guardarà en <strong>col·leccions</strong>.</li>
<li>Cada col·lecció constarà d'uns quants <strong>documents</strong>.</li>
<li>I cada document seran una sèrie de dades guardades en forma de <strong>clau-valor</strong> , dels tipus suportats per MongoDB, i amb el format JSON (en realitat BSON)</li>
</ul>
<p>Per tant, en Mongo no hi ha taules. Mirem uns exemples de documents JSON per a
guardar la informació de llibres i autors. Depenen de com s'haja d'accedir a
la informació ens podem plantejar guardar els llibres amb els seus autors, o
guardar els autors, amb els seus llibres. Fins i tot ens podríem guardar els
dos, per a poder accedir de totes les maneres, encara que és a costa de doblar
la informació.</p>
<p>De la primera manera, guardant els llibres amb el seu autor, podríem tenir
documents amb aquesta estructura, que es podrien guardar en una col·lecció
anomenada <strong>Llibres</strong> :</p>
<pre><code>  {  
    _id:101,  
    titol:"El secret de Khadrell",  
    autor: {  
    nom:"Pep",  
    cognoms:"Castellano Puchol",  
    any_naixement:1960  
    },  
    isbn:"84-95620-72-3"  
  },  
  {  
    _id:102,  
    titol:"L'Ombra del Vent",  
    autor: {  
    nom:"Carlos",  
    cognoms:"Ruiz Zafon",  
    pais:"Espanya"  
    },  
    pagines:490,  
    editorial:"Planeta"  
  }
</code></pre>
<p>Observeu com els objectes no tenen per què tenir la mateixa estructura. La
manera d'accedir al nom d'un autor seria aquesta: <em>objecte.autor.nom</em></p>
<p>Una manera alternativa de guardar la informació, com havíem comentat abans
seria organitzar per autors, amb els seus llibres. D'aquesta manera podríem
anar omplint la col·lecció <strong>Autors</strong> amb un o més documents d'aquest estil:</p>
<pre><code>{  
    _id: 201,  
    nom:"Pep",  
    cognoms:"Castellano Puchol",  
    any_naixement:1960,  
    llibres: [  
    {  
      titol:"El secret de Khadrell",  
      isbn:"84-95620-72-3"  
    },  
    {  
      titol:"Habitació 502",  
      editorial:"Tabarca"  
    }  
  ]  
},  
{  
    _id:202,  
    nom:"Carlos",  
    cognoms:"Ruiz Zafon",  
    pais:"Espanya",  
    llibres: [  
      {  
        titol:"L'Ombra del Vent",  
        pagines:490,  
        editorial:"Planeta"  
      }  
  ]  
}
</code></pre>
<p>Observeu com per a un autor, ara tenim un array ( els claudàtors: <strong>[ ]</strong>) amb
els seus llibres.</p>
<p>Quina de les dues maneres és millor per a guardar la informació? Doncs depén
de l'accés que s'haja de fer a les dades. La millor serà segurament aquella
que depenent dels accessos que s'hagen de fer, torne la informació de forma
més ràpida.</p>
<h2 id="31-estructura-json">3.1 - Estructura JSON</h2>
<p>Amb JSON podrem representar:</p>
<ul>
<li><strong>Valors</strong> , de tipus <strong>caràcter</strong> (entre cometes dobles), <strong>numèric</strong> (sense cometes) , <strong>booleà</strong> (true o false) o <strong>null</strong>.</li>
<li><strong>Parelles clau valor</strong> , és a dir un nom simbòlic acompanyat d'un valor associat.. Es representen així: <strong>"nom" : valor</strong></li>
<li><strong>Objectes</strong> , que és una col·lecció de membres, cadascú dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: <strong>{ "nom1" : "valor1" , "nom2": valor2 , valor 3 , ... }</strong></li>
<li><strong>Arrays</strong> , que són llistes d'elements. Els elements no tenen per què tenir la mateixa estructura, però nosaltres intentarem que sí que la tinguen per coherència. Cada element pot ser un valor , una parella clau valor, un objecte o un array.</li>
</ul>
<p>Veja'm algun exemples:</p>
<pre><code>{ "p1" : 2 , "p2" : 4 , "p3" : 6 , "p4" : 8 , "p5" : 10 }
</code></pre>
<p>en aquest cas tenim un objecte, l'arrel, que té 5 membres, tots ells parelles
clau-valor.</p>
<pre><code>{  
  "num": 1 ,  
  "nom": "Andreu" ,  
  "departament": 10 ,  
  "edat": 32 ,  
  "sou": 1000.0  
}
</code></pre>
<p>ara un objecte, l'arrel, també amb 5 membres que són parelles clau-valor.
Observeu com la clau sempre la posem entre cometes, i el valor quan és un
string també, però quan és numèric, no.</p>
<pre><code>{ "empleat" :  
  { "num": 1 ,  
    "nom": "Andreu" ,  
    "departament": 10 ,  
    "edat": 32 ,  
    "sou": 1000.0  
  }  
}
</code></pre>
<p>en aquest cas tenim un objecte, l'arrel que consta d'un únic objecte,
<strong>empleat</strong> , el qual consta de 5 membres clau-valor.</p>
<p>Mirem ara un exemple amb un array:</p>
<pre><code>{ "notes" :  
  [ 5 , 7 , 8 , 7 ]  
}
</code></pre>
<p>on tenim l'element arrel que consta d'un únic membre, notes, que és un array.</p>
<p>També seria correcte d'aquesta manera, per veure que l'element arrel no té
perquè ser un objecte, sinó també un array</p>
<pre><code>[ 5 , 7 , 8 , 7 ]
</code></pre>
<p>I ara un més complet amb la mateixa estructura que el fitxer XML que havíem
vist en la pregunta 4. Tindrem un objecte arrel, amb només un objecte,
<strong>empresa</strong> , que té un únic element <strong>empleat</strong> que és un array amb 4
elements, cadascun dels empleats:</p>
<pre><code>{ "empresa":  
  { "empleat":  
    [ {  
          "num": "1",  
          "nom": "Andreu",  
          "departament": "10",  
          "edat": "32",  
          "sou": "1000.0"  
        },  
        {  
          "num": "2",  
          "nom": "Bernat",  
          "departament": "20",  
          "edat": "28",  
          "sou": "1200.0"  
        },  
        {  
          "num": "3",  
          "nom": "Clàudia",  
          "departament": "10",  
          "edat": "26",  
          "sou": "1100.0"  
        },  
        {  
          "num": "4",  
          "nom": "Damià",  
          "departament": "10",  
          "edat": "40",  
          "sou": "1500.0"  
        }
    ]  
  }  
}
</code></pre>
<p>Anem a veure un parell de casos més reals. Aquesta és la contestació que fa el
WebService de <strong>Bicicas</strong> en sol·licitar l'estat actual de bicicletes en els
diferents punts (en el moment de fer els apunts es consulta en l'adreça
<a href="http://gestiona.bicicas.es/apps/apps.php">http://gestiona.bicicas.es/apps/apps.php</a>):</p>
<pre><code>[  
  {"ocupacion":  
    [  
      {"id":"01","punto":"UJI -
      FCHS","puestos":27,"ocupados":12,"latitud":"39.99533","longitud":"-0.06999",
      "porcentajeAltaOcupacion":"80","porcentajeBajaOcupacion":"20"},  
      {"id":"02","punto":"ESTACIÓN DE FERROCARRIL Y
      AUTOBUSES","puestos":24,"ocupados":7,"latitud":"39.98765","longitud":"-0.05281",
      "porcentajeAltaOcupacion":"80","porcentajeBajaOcupacion":"20"},  
      {"id":"03","punto":"PLAZA DE
      PESCADERÍA","puestos":28,"ocupados":4,"latitud":"39.98580","longitud":"-0.03798",
      "porcentajeAltaOcupacion":"80","porcentajeBajaOcupacion":"20"},  
      ...  
    ]  
  }  
]
</code></pre>
<p>Com podeu comprovar, l'arrel no és un objecte, sinó un <strong>Array</strong>. En l'array
només ens interessa el primer element que és un objecte amb un únic membre,
<strong>ocupacion</strong>(en l'exemple no hi ha més elements, però en poden haver més en
un moment determinat, quan volen fer avisos). I <strong>ocupacion és un array</strong> ,
amb <strong>un objecte per cada estació de bicicas</strong> , amb les parelles clau valor
<strong>id</strong> , <strong>punto</strong> , <strong>puestos</strong> (les bicicletes que caben), <strong>ocupados</strong>
(quantes bicicletes hi ha col·locades en aquest moment), <strong>latitud</strong> i
<strong>longitud</strong> (les coordenades), ...</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En realitat ens apareixerà tota la informació molt més apegada, perquè
realment està en una única línia.</p>
<p>Per a poder observar millor l'estructura podem utilitzar un <strong>visor</strong> de json.
Normalment el navegador Firefox els visualitza bé, encara que també depén de
la versió. Si tenim instal·lada una versió que admet la visualització de JSON,
ho intentarà interpretar, encara que segurament la millor manera de veure el
format JSON és,tiar les opcions <strong>Dades sense processar -- &gt; Format
d'impressió</strong>, que és la que veiem a la dreta:</p>
<table>
<thead>
<tr>
<th><img alt="" src="../T3_5_1_0_1.png" /></th>
<th><img alt="" src="../T3_5_1_0_2.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Si la versió nostra de Firefox no visualitza el format JSON, podem buscar un
visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es
pot observar com facilita molt la lectura.</p>
<p><img alt="" src="../T3_5_1_1.png" /></p>
</div>
<p>Un altre exemple. Un WebService de GeoNames (una Base de Dade geogràfica
gratuïta i accessible a través d'Internet) ens proporciona informació dels
llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud,
i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1
i oest -0.1). Per exemple,
<a href="https://maps.googleapis.com/maps/api/geocode/json?latlng=40,0">http://api.geonames.org/citiesJSON?north=40.01&amp;south=39.99&amp;east=0.01&amp;west=-0.01&amp;lang=ES&amp;username=demo</a>
torna el següent:</p>
<pre><code>{
  "geonames": [
    {
      "lng": -0.04935,
      "geonameId": 2519752,
      "countrycode": "ES",
      "name": "Castelló de la Plana",
      "fclName": "city, village,...",
      "toponymName": "Castelló de la Plana",
      "fcodeName": "seat of a second-order administrative division",
      "wikipedia": "en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana",
      "lat": 39.98567,
      "fcl": "P",
      "population": 180005,
      "fcode": "PPLA2"
    },
    {
      "lng": -0.06313,
      "geonameId": 2521909,
      "countrycode": "ES",
      "name": "Almazora",
      "fclName": "city, village,...",
      "toponymName": "Almassora",
      "fcodeName": "populated place",
      "wikipedia": "en.wikipedia.org/wiki/Almassora",
      "lat": 39.94729,
      "fcl": "P",
      "population": 24963,
      "fcode": "PPL"
    },
    ...
    ]
}
</code></pre>
<p>A partir de l'arrel (que ara sí que és un objecte), tenim un membre:
<strong>geonames</strong>, que és un array (un element per cada "lloc" trobat), on cada
element té informació diversa, com el nom del lloc, les coordenades, la
població, ...</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>De fa uns mesos que Google limita el servei anterior, i ha de ser amb un
usuari validat. No valdrà la pena, per al poc profit que li trauríem. Mostrem
en què consisteix el servei únicament a nivell il·lustratiu</p>
</div>
<h2 id="32-installacio-de-mongodb">3.2 - Instal·lació de MongoDB</h2>
<p>Podrem instal·lar MongoDB en qualsevol plataforma. I fins i tot sense tenir
permisos d'administrador, com veurem en el cas d'Ubuntu.</p>
<p>També està la possibilitat de crear un servidor en el núvol, fins i tot
gratuït. És l'opció que ens suggereix Mongo per defecte, però nosaltres no la
utilitzarem.</p>
<h3 id="installacio-en-linux">Instal·lació en Linux</h3>
<p>Per a poder fer la instal·lació més bàsica, podrem fer-lo sense permisos
d'administrador. Si els tenim tot és més còmode, però si no en tenim també ho
podem fer, com veurem i remarcarem a continuació.</p>
<p><strong class="azul">Instal·lació del servidor (Linux)</strong></p>
<p>De la pàgina de <strong>MongoDB (<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a>)</strong> anem al menú <strong>Products - &gt; Comunity Edition -&gt;Comunity Server</strong>
i ens baixem la versió apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions. I millor triar
el paquet <strong>tgz</strong>, ja que amb descomprimir el fitxer serà suficient. En
el cas d'<strong>Ubuntu 22.04 de 64 bits</strong> , aquest fitxer és:
<strong><a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.0.5.tgz">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.0.5.tgz</a></strong>. Però recordeu que us heu d'assegurar de la versió.</p>
<p>Senzillament descomprimirem aquest fitxer on vulguem, i ja estarà feta la
instal·lació bàsica.</p>
<p>Per defecte el directori de la Base de Dades és <strong>/data/db</strong></p>
<p>L'únic problema que podríem tenir si no som administradors és que no tinguem
permís per crear aquest directori. Aleshores crearem un altre directori i en
el moment d'arrancar el servidor, li especificarem aquest lloc.</p>
<p>La manera d'arrancar el servidor serà:</p>
<pre><code>&lt;directori arrel MongoDB&gt;./bin/mongod
</code></pre>
<p>Opcionalment li podem dir on està la Base de Dades (si no ho especifiquem
assumirà que està en <strong>/data/db</strong>):</p>
<pre><code>&lt;directori arrel MongoDB&gt;./bin/mongod --dbpath &lt;directori de la BD&gt;
</code></pre>
<p>Resumint, i estant situats al directori on hem descomprimit MongoDB:</p>
<ul>
<li>
<p>Creem el directori de dades:</p>
<pre><code>mkdir /data  
mkdir /data/db
</code></pre>
</li>
<li>
<p>Si no som administradors, arranquem el servidor:</p>
<pre><code>./bin/mongod --dbpath ./data/db
</code></pre>
</li>
<li>
<p>Si som administradors, arranquem el servidor:</p>
<pre><code>./bin/mongod
</code></pre>
</li>
</ul>
<p>La següent imatge il·lustra aquesta segona opció. Està per a una versió
anterior de MongoDB, però és totalment equivalent:</p>
<p><img alt="" src="../T8_3_1_1.png" /></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Una vegada en marxa el servidor, no hem de tancar aquesta terminal, ja que pararíem el servidor.</p>
</div>
<p><strong class="azul">Instal·lació del client MongoShell (Linux)</strong></p>
<p>De la pàgina de <strong>MongoDB (<a href="https://www.mongodb.com/try/download/shell">https://www.mongodb.com/try/download/shell</a>)</strong> anem al menú <strong>Products - &gt; Tools -&gt;MongoDB Shell</strong>
i ens baixem la versió apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions, i millor triar
el paquet <strong>tgz</strong>, ja que amb descomprimir el fitxer serà suficient. En
el cas d'<strong>Ubuntu 22.04 de 64 bits</strong> , triarem l'opió genèrica <strong>Linux 64</strong> ja que és la opció que té el paquet <strong>tgz</strong>, i aquest fitxer és:
<strong><a href="https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz">https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz</a></strong>. Però recordeu que us heu d'assegurar de la versió.</p>
<p>Senzillament descomprimirem aquest fitxer on vulguem, i ja estarà feta la
instal·lació bàsica.</p>
<p>Per a connectar un client, obrim una segona terminal i
executem el client <strong>mongosh</strong> :</p>
<pre><code>&lt;directori arrel Mongosh&gt;/bin/mongosh

./bin/mongosh
</code></pre>
<p><img alt="" src="../T8_3_1_2.png" /></p>
<h3 id="installacio-en-windows">Instal·lació en Windows</h3>
<p><strong class="azul">Instal·lació del servidor (Windows)</strong></p>
<p>No ofereix cap dificultat. Ens baixem la versió apropiada de MongoDB per a
Windows, que resultarà ser un .msi directament executable. En el moment de fer aquestos apunts, la versió de 64 bits és la 8.0.5:</p>
<p><a href="https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.0.5-signed.msi">https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.0.5-signed.msi</a></p>
<p>Com en el cas de Linux, abans d'executar el servidor haurem de tenir el
directori creat. Per defecte el directori serà <strong>\data\db</strong></p>
<p>Aqueste serien les ordres per a crear el directori i després arrancar el
servidor.</p>
<pre><code>mkdir \data\db  
C:\Program Files\MongoDB\Server\8.0\bin\mongod.exe
</code></pre>
<p>Hauria d'aparèixer la imatge següent</p>
<p><img alt="" src="../T8_3_1_11.png" /></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si vas instal·lar MongoDB amb el MongoDB MSI Installer, normalment el servei ja estarà instal·lat i no caldrà executar-lo.</p>
</div>
<p><strong class="azul">Instal·lació del client MongoShell (Windows)</strong></p>
<p>Per a connectar-nos com a clients, ho haurem de fer des d'una altra terminal,
amb <strong>mongosh.exe</strong>, que és la interfície de línia d'ordres (CLI) oficial de MongoDB, utilitzada per interactuar amb la base de dades mitjançant ordres en JavaScript:</p>
<p>Ens baixem la versió apropiada de MongoDB per a Windows </p>
<p><a href="https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz">https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz</a></p>
<div class="admonition tip">
<p class="admonition-title">Mongo Compass</p>
<p>També us podeu descarregar la versió <strong>MongoDB Compass</strong>, que és l'eina gràfica oficial de MongoDB que permet visualitzar, explorar i administrar bases de dades de MongoDB sense necessitat d'utilitzar la línia de comandos.</p>
<p><a href="https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe">https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe</a></p>
</div>
<p><strong class="azul">Probar el funcionament</strong></p>
<p>Per a provar el seu funcionament, anem a fer un parell de comandos: un per a
guardar un document i un altre per a reculerar-lo.</p>
<p>Per a qualsevol operació s'ha de posar <strong>db</strong> seguit del nom de la col·lecció,
i després l'operació que volem fer. Amb el sgüent:</p>
<pre><code>db.exemple.insertOne( {msg:"Hola, què tal?"} )
</code></pre>
<p>Ens contestarà:</p>
<pre><code>WriteResult({ "nInserted" : 1 })
</code></pre>
<p>Indicant que ha inserit un document en la col·lecció <strong>exemple</strong> (si no estava
creada, la crearà).</p>
<p>I amb el següent comando recuperem la informació:</p>
<pre><code>  db.exemple.find()
</code></pre>
<p>Que ens tornarà:</p>
<pre><code>{ "_id" : ObjectId("56cc1acd73b559230de8f71b"), "msg" : "Hola, què tal?" }
</code></pre>
<p>Tot ho fa en la mateixa terminal, i a cadascú de nosaltres ens donarà un
número diferent en <strong>ObjectId</strong>. En la següent imatge es veuen les dues
operacions:</p>
<p><img alt="" src="../T8_3_1_13.png" /></p>
<p>En realitat estem connectats a una Base de Dades anomenada <strong>test</strong>. Podem
crear i utilitzar més d'una Base de Dades, però en aquest curs tindrés més que
suficient amb aquesta Base de Dades. Per a comprovar-ho podem executar la
següent sentència, que ens torna el nom de la Base de Dades:</p>
<pre><code>db.getName()  
test
</code></pre>
<!--
### 3.2.1 - Connexió al servidor de l'Institut

Quan hem utilitzat el client, hem executat el programa **mongo** sense posar-
li res més. Per defecte s'ha connectat al servidor que tenim en la mateixa
màquina.

Però en realitat li podem especificar l'adreça on està el servidor al qual
volem connectar. En concret, l'adreça del servidor de dades de l'Institut en
el qual també tenim instal·lat MongoDB:


    mongosh  89.36.214.106

Podem connectar, però no podrem fer cap operació, perquè està habilitada
l'autenticació per a previndre atacs, cosa que no tenim en el servidor que hem
instal·lat cadascú en la seua màquina.

Aleshores, si intentem fer qualsevol operació, ens donarà error perquè no
estem autenticats:

![](T8_3_1_1_1.png)

La manera d'autenticar serà utilitzant el comando **db.auth("_usuari"_ ,
"_contrasenya"_)**. I en connectarem a un usuari que té permís per a utilitzar
la BD test:

  * Usuari: **ad**
  * Contrasenya: **Ad_ieselcamina$**

A partir d'eixe moment ja podrem utilitzar-lo sense problemes:

![](T8_3_1_1_2.png)

-->

<h2 id="33-utilitzacio-de-mongodb">3.3 - Utilització de MongoDB</h2>
<p>Començarem la utilització de MongoDB des de la consola que havíem arrancat al
final de la instal·lació.</p>
<p>Recordeu que tindrem dues teminals:</p>
<ul>
<li>Una amb el servidor en marxa (i que no hem de tancar): <strong>mongod</strong></li>
<li>Una altra amb el client que es connecta al servidor: <strong>mongosh</strong></li>
</ul>
<p>En aquesta última consola del client podem utilitzar sentències del llenguatge
<strong>Javascipt</strong> , però el que més ens interessarà, evidentment, són les
sentències d'accés a dades. Del llenguatge Javascript pràcticament l'únic que
utilitzarem són variables i algunes funcions.</p>
<p><strong class="azul">Utilització de variables</strong></p>
<p>Com comentàvem el que més utilitzarem del llenguatge <strong>Javascript</strong> és la
utilització de variables, que ens pot ser molt útil en algunes ocasions.
Podrem utilitzar-les durant la sessió, però evidentment no perduraran d'una
sessió a l'altra.</p>
<p>Per a definir una variable podem posar opcionalment davant la paraula
reservada <strong>var</strong> , però no és necessari. Posarem el nom de la variable, el
signe igual, i a continuació el valor de la variable, que pot ser una
constant, o una expressió utilitzant constants, operadors, altres variables,
funcions de Javascript, ...</p>
<p>Especialment interessant són les variables que poden contenir un document
JSON.</p>
<p>Per exemple:
<div class="highlight"><pre><span></span><code>  &gt; a = 30  
  30  
  &gt; b = a/4  
  7.5  
  &gt; Math.sqrt(b)  
  2.7386127875258306  
  &gt; doc = {camp1: &quot;Hola&quot;, camp2: 45, camp3: new Date()}  
  {  
    &quot;camp1&quot; : &quot;Hola&quot;,  
    &quot;camp2&quot; : 45,  
    &quot;camp3&quot; : ISODate(&quot;2022-01-16T18:07:51.118Z&quot;)  
  }  
  &gt;
</code></pre></div>
Una variable de tipus JSON es podrà modificar molt fàcilment, tota ella, o
algun dels elements. Per a arribar als elements posarem
<strong><em>nom_variable.nom_camp</em></strong> :
<div class="highlight"><pre><span></span><code>&gt; doc.camp4 = 3.141592  
3.141592
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; doc.camp5 = [ 2 , 4 , 6 , 8]  
[ 2, 4, 6, 8 ]
</code></pre></div>
I si ara intentem traure el contingut de la variable:
<div class="highlight"><pre><span></span><code>&gt; doc  
{  
  &quot;camp1&quot; : &quot;Hola&quot;,  
  &quot;camp2&quot; : 45,  
  &quot;camp3&quot; : ISODate(&quot;2022-01-16T18:07:51.118Z&quot;),  
  &quot;camp4&quot; : 3.141592,  
  &quot;camp5&quot; : [  
              2,  
              4,  
              6,  
              8  
    ]  
}  
&gt;
</code></pre></div>
També hem de fer constar que en un document, que serà de tipus JSON
(pràcticament), serà un conjunt de parelles clau-valor, amb algunes
restriccions:</p>
<ul>
<li>El document (que moltes vegades l'associarem a objecte de JSON) va entre claus ( <strong>{ }</strong> )</li>
<li>Els elements d'un objecte van separats per comes, i són parelles clau-valor.</li>
<li>La clau no pot ser nula, ni repetir-se en el mateix objecte (sí en diferents objectes, clar)</li>
<li>Els valors són dels tipus que veurem en la pregunta 3.2.1</li>
<li>Un document guardat ha de contenir obligatòriament un camp anomenat <strong>_id</strong> , i que contindrà un valor únic en la col·lecció i servirà per a identificar-lo. Si en guardar un document no li hem posat camp <strong>_id</strong> , el generarà automàticament MongoDB.</li>
</ul>
<h3 id="331-tipus-de-dades">3.3.1 - Tipus de dades</h3>
<p>Els valors dels elements, és a dir de les parelles clau valor, poden ser d'uns
quants tipus. Fem un ràpid repàs.</p>
<p>En els exemples que van a continuació definim senzillament parelles clau-valor
dels diferents tipus, o en tot cas ens ho guardem en variables, però no
guardarem encara en la Base de Dades (ho farem en la següent pregunta).</p>
<p>Quan guardem en una variable es mostrarà el prompt, la definició de la
variable i després el resultat d'haver guardat la variable. Utilitzarem
requadres blancs. Els requadres grocs són únicament de la definició d'una
clau-valor d'un determinat tipus</p>
<p><strong>NULL</strong></p>
<p>Més que un tipus de dades és un valor, millor dit, l'absència de valor
<div class="highlight"><pre><span></span><code>{ &quot;x&quot; : null }
</code></pre></div>
<strong>BOOLEAN</strong></p>
<p>El tipus booleà, que pot agafar els valors true o false.
<div class="highlight"><pre><span></span><code>{ &quot;x&quot; : true }

{ &quot;y&quot; : false }
</code></pre></div>
<strong>NUMBER</strong></p>
<p>Per defecte, el tiups de dades numèrics serà el de coma flotant (<strong>float</strong>),
simple precisió. Si volem un altre tiups (enter, doble precisió, ...) ho
haurem d'indicar expressament. Així els dos següents valors són float:
<div class="highlight"><pre><span></span><code>{ &quot;x&quot; : 3.14 }

{ &quot;y&quot; : 3 }
</code></pre></div>
Si volem que siga estrictament enter, per exemple, haurem d'utilitzar una
funció de conversió:
<div class="highlight"><pre><span></span><code>{ &quot;x&quot; : NumberDouble(&quot;3.14&quot;) }

{ &quot;y&quot; : NumberInt(&quot;3&quot;) }
</code></pre></div>
<strong>STRING</strong></p>
<p>Es pot guardar qualsevol cadena amb caràcters de la codificació UTF-8
<div class="highlight"><pre><span></span><code>{ x : &quot;Hola, què tal?&quot;}
</code></pre></div>
<strong>DATE</strong></p>
<p>Es guarda data i hora, i internament es guarden en milisegons des de l'any
inicial. No es guarda el <strong><em>Time zone</em></strong> , és a dir, la desviació respecte a
l'hora internacional.
<div class="highlight"><pre><span></span><code>{ x : ISODate(&quot;2022-01-16T11:15:27.471Z&quot;) }
</code></pre></div>
Normalment utilitzarem funcions de tractament de la data-hora. L'anterior era
per a convertir el string en data-hora. La següent és per a obtenir la data-
hora actual:
<div class="highlight"><pre><span></span><code>{ x : new Date() }
</code></pre></div>
És a dir, que si no posem paràmetre, ens dóna la data-hora actual. Però li
podem posar com a paràmetre la data-hora que volem que genere. En aquest
exemple, només posem data, per tant l'hora serà les 00:00:
<div class="highlight"><pre><span></span><code>&gt; z = new Date(&quot;2022-01-16&quot;)  
ISODate(&quot;2022-01-16T00:00:00Z&quot;)
</code></pre></div>
En aquest sí que posem una determinada hora, i observeu com hem deposar la T
(Time) entre el dia i l'hora:
<div class="highlight"><pre><span></span><code>&gt; z = new Date(&quot;2022-02-16T18:00&quot;)  
ISODate(&quot;2022-01-16T18:00:00Z&quot;)
</code></pre></div>
És molt important que posem sempre <strong>New Date()</strong> per a generar una data-hora.
Si posem únicament <strong>Date()</strong> , el que estem generant és un string (segurament
amb la data i hora actual, però un string):
<div class="highlight"><pre><span></span><code>&gt; z = Date(&quot;2022-01-16&quot;)  
Sun Jan 16 2022 22:20:09 GMT+0100 (CET)
</code></pre></div>
<strong>ARRAY</strong></p>
<p>És un conjunt d'elements, cadascun de qualsevol tipus, encara que el més
habitual és que siguen del mateix tipus. Van entre claudàtors (<strong>[ ]</strong>) i els
elements separats per comes.
<div class="highlight"><pre><span></span><code>{ x : [ 2 , 4 , 6 , 8 ] }
</code></pre></div>
Com comentàvem, cada element de l'array pot ser de qualsevol tipus:
<div class="highlight"><pre><span></span><code>{ y : [ 2 , 3.14 , &quot;Hola&quot; , new Date() ] }
</code></pre></div>
En MongoDB podrem treballar molt bé amb arrays, i tindrem operacions per a
poder buscar dins de l'array, modificar un element, crear índex, ...</p>
<p><strong>DOCUMENTS (OBJECTES)</strong></p>
<p>Els documents poden contenir com a elements uns altres documents (<strong>objectes</strong>
en la terminologia JSON, però <strong>documents</strong> en la terminologia de MongoDB).</p>
<p>Van entre claus ( <strong>{ }</strong> ), i els elements que contindran van separats per
comes i seran parelles clau-valor de qualsevol tipus (fins i tot altres
documents).
<div class="highlight"><pre><span></span><code>{ x : { a : 1 , b : 2 } }
</code></pre></div>
Posar documents dins d'uns altres documents (el que s'anomena <em>embedded</em>
<em>document</em>) ens permet guardar la informació d'una manera més real, no tan
plana. Així per exemple, les dades d'una persona les podríem definir de la
següent manera. Les posarem en una variable, per veure després com podem
accedir als diferents elements, encara que el més normal serà guardar-lo en la
Base de Dades (amb <strong>insert()</strong>). Si copiem el que va a
continuació al terminal de Mongo, ens apareixerà amb un format estrany. És
perquè la sentència d'assignació a la variable ocupa més d'una línia, i
apareixeran 3 punts al principi per a indicar que continua la sentència. Però
funcionarà perfectament :</p>
<p><div class="highlight"><pre><span></span><code><span class="err">doc</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">  </span><span class="kc">n</span><span class="err">om</span><span class="p">:</span><span class="s2">&quot;Joan Martí&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">  </span><span class="err">adreça</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">  </span><span class="err">carrer</span><span class="p">:</span><span class="s2">&quot;Major&quot;</span><span class="p">,</span><span class="w">  </span>
<span class="w">  </span><span class="kc">n</span><span class="err">úmero</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w">  </span>
<span class="w">  </span><span class="err">població</span><span class="p">:</span><span class="s2">&quot;Castelló&quot;</span><span class="w">  </span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="p">,</span><span class="w">  </span>
<span class="w">  </span><span class="kc">tel</span><span class="err">è</span><span class="kc">f</span><span class="err">o</span><span class="kc">ns</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">964223344</span><span class="p">,</span><span class="mi">678345123</span><span class="p">]</span><span class="w">  </span>
<span class="p">}</span>
</code></pre></div>
Observeu com aquesta estructura que ha quedat tan clara, segurament en una
Base de Dades Relacional ens hauria tocat guardar en 3 taules: la de persones,
la d'adreces i la de telèfons.</p>
<p>Per a accedir als elements d'un document posàvem el punt. Doncs el mateix per
als elements d'un document dins d'un document. I també podem accedir als
elements d'un array, posant l'índex entre claudàtors.
<div class="highlight"><pre><span></span><code>  &gt; doc.nom  
  Joan Martí  

  &gt; doc.adreça  
  { &quot;carrer&quot; : &quot;Major&quot;, &quot;número&quot; : 1, &quot;població&quot; : &quot;Castelló&quot; }  

  &gt; doc.adreça.carrer  
  Major  

  &gt; doc.telèfons  
  [ 964223344, 678345123 ]  

  &gt; doc.telèfons[0]  
  964223344
</code></pre></div>
<strong>OBJECT ID</strong></p>
<p>És un tipus que defineix MongoDB per a poder obtenir valors únics. És el valor
per defecte de l'element <strong>_id</strong> , necessari en tot document (atenció: en un
document, no en un element de tipus document que hem dit equivalent a
l'objecte de JSON). És un número long, és a dir que utilitza 24 bytes.</p>
<p>Farem proves de la seua utilització en la seüent pregunta, en el moment
d'inserir diferents documents.</p>
<h3 id="332-operacions-basiques">3.3.2 - Operacions bàsiques</h3>
<p>En aquest punt anem a veure les operacions més bàsiques, per a poder treballar
sobre exemples pràctics, i així disposar ja d'unes dades inicials per a
practicar.</p>
<h4 class="azul" id="insercio-elemental-insert">Inserció elemental: insert</h4>
<p>La funció <strong>insert</strong> afegirà documents a una col·lecció. En el paràmetre posem
el document directament, o una variable que continga el document. Si la
col·lecció no existia, la crearà i després afegirà el document. En la següent
sentència estem treballant sobre la col·lecció <strong>exemple</strong> , que segurament ja
existirà de quan vam fer la pregunta 3.1 d'instal·lació de MongoDB, que per a
provar vam inserir un document. Però si no existia, la crearà sense problemes.
<div class="highlight"><pre><span></span><code>&gt; db.exemple.insert({ msg2 : &quot;Com va la cosa?&quot;})  
WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre></div>
Acabem d'inserir un nou document, i així ens ho avisa ( <strong>{ "nInserted" : 1
}</strong> , s'ha inserit un document). Automàticament haurà creat un element <strong>_id</strong>
de tipus <strong>ObjectId</strong> , ja que li fa falta per a identificar el document entre
tots els altres de la col·lecció.</p>
<p>I en aquest exemple ens guardem el document en la variable <strong>doc</strong> , i després
l'inserim
<div class="highlight"><pre><span></span><code>&gt; doc = { msg3 : &quot;Per ací no ens podem queixar ...&quot;}  
{ &quot;msg3&quot; : &quot;Per ací no ens podem queixar ...&quot; }  
&gt; db.exemple.insert(doc)  
WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre></div>
També ens indica que ha inserit un document. I haurà creat també el camp
<strong>_id</strong> com veurem en el següent punt.</p>
<h4 class="azul" id="lectura-find">Lectura: find</h4>
<p>Tenim dues funcions per a recuperar informació: <em><strong>find</strong></em> i <em><strong>findOne</strong></em>.</p>
<ul>
<li><strong>find()</strong> : recuperarà tots els documents de la col·lecció, encara que podrem posar criteris per a que ens torne tots els documents que acomplesquen aquestos criteris (ho veurem més avant).</li>
<li><strong>findOne()</strong> : només tornarà un document, en principi el primer. Pot ser sobre tots els documents (i per tant seria el primer document), o posar una condició, i tornaria el primer que acomplirà la condició.</li>
</ul>
<p>Exemple de <strong>find()</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.exemple.find()  
{ &quot;_id&quot; : ObjectId(&quot;56ce310bc61e04ba81def50b&quot;), &quot;msg&quot; : &quot;Hola, què tal?&quot; }  
{ &quot;_id&quot; : ObjectId(&quot;56ce31f6c61e04ba81def50c&quot;), &quot;msg2&quot; : &quot;Com va la cosa?&quot; }  
{ &quot;_id&quot; : ObjectId(&quot;56ce3237c61e04ba81def50d&quot;), &quot;msg3&quot; : &quot;Per ací no ens podem queixar ...&quot; }  
&gt;
</code></pre></div>
Exemple de <strong>findOne()</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.exemple.findOne()  
{ &quot;_id&quot; : ObjectId(&quot;56ce310bc61e04ba81def50b&quot;), &quot;msg&quot; : &quot;Hola, què tal?&quot; }  
&gt;
</code></pre></div>
En tots els casos podem comprovar que és cert el que veníem afirmant, que ha
creat automàticament l'element <strong>_id</strong> per a cada document guardat.
Evidentment, cadascú de nosaltres tindrà una valors diferents.</p>
<p>Inserció especificant el id</p>
<p>Ara que ja sabem consultar els document de la col·lecció amb <strong>find()</strong> anem a
continuar les insercions de documents, per veure les possibilitats que tenim.</p>
<p>En els document que hem inserit fins el moment, no hem especificat el camp
<strong>_id</strong> , i Mongo l'ha generat automàticament de tipus <strong>ObjectId</strong>.</p>
<p>Però nosaltres podrem posar aquest camp <strong>_id</strong> amb el valor que vulguem. Això
sí, haurem d'estar segurs que aquest valor no l'agafa cap altre document de la
col·lecció, o ens donarà un error.</p>
<p>Així per exemple anem a inserir la informació d'uns alumnes. Els posarem en
una col·lecció nova anomenada <strong>alumnes</strong> , i els intentarem posar un <strong>_id</strong>
personal. Per exemple posarem els números 51, 52, 53, ...
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.insert ({_id: 51 , nom: &quot;Rebeca&quot; , cognoms: &quot;Martí Peral&quot;})  
WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre></div>
Ha anat bé, i si mirem els documents que tenim en la col·lecció, comprovarem
que ens ha respectat el <strong>_id</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find()  
{ &quot;_id&quot; : 51, &quot;nom&quot; : &quot;Rebeca&quot;, &quot;cognoms&quot; : &quot;Martí Peral&quot; }  
&gt;
</code></pre></div>
Però si intentem inserir un altre document amb el mateix <strong>_id</strong> (51), ens
donarà error:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.insert ({_id: 51 , nom: &quot;Raquel&quot; , cognoms: &quot;Gomis Arnau&quot;})  
WriteResult({  
&quot;nInserted&quot; : 0,  
&quot;writeError&quot; : {  
    &quot;code&quot; : 11000,  
    &quot;errmsg&quot; : &quot;E11000 duplicate key error collection: test.alumnes index: _id_
    dup key: { : 51.0 }&quot;  
  }  
})  
&gt;
</code></pre></div>
Ens avisa que estem duplicant la <em>clau</em> <em>principal</em> , és a dir
l'identificador.</p>
<h4 class="azul" id="insercio-multiple">Inserció múltiple</h4>
<p>Quan els documents que volem inserir són senzills, podem inserir més d'un a la
vegada, posant dis del <strong>insert()</strong> un <strong>array</strong> amb tots els elements. En el
següent exemple creem uns quants nombres primers en la col·lecció del mateix
nom:
<div class="highlight"><pre><span></span><code>&gt; db.nombresprimers.insert( [ {_id:2} , {_id:3} , {_id:5} , {_id:7} , {_id:11}
&gt; , {_id:13} , {_id:17} , {_id:19} ] )  
BulkWriteResult({  
    &quot;writeErrors&quot; : [ ],  
    &quot;writeConcernErrors&quot; : [ ],  
    &quot;nInserted&quot; : 8,  
    &quot;nUpserted&quot; : 0,  
    &quot;nMatched&quot; : 0,  
    &quot;nModified&quot; : 0,  
    &quot;nRemoved&quot; : 0,  
    &quot;upserted&quot; : [ ]  
})  
&gt;
</code></pre></div>
Ens avisa que ha fet 8 insercions, i ací els tenim:
<div class="highlight"><pre><span></span><code>&gt; db.nombresprimers.find()  
{ &quot;_id&quot; : 2 }  
{ &quot;_id&quot; : 3 }  
{ &quot;_id&quot; : 5 }  
{ &quot;_id&quot; : 7 }  
{ &quot;_id&quot; : 11 }  
{ &quot;_id&quot; : 13 }  
{ &quot;_id&quot; : 17 }  
{ &quot;_id&quot; : 19 }  
&gt;
</code></pre></div></p>
<h4 class="azul" id="esborrat-remove">Esborrat: remove</h4>
<p>Per a esborrar un document d 'una col·lecció utilitzarem la funció <strong>remove</strong>
, passant-li com a paràmetre la condició del document o documents a esborrar.
<div class="highlight"><pre><span></span><code>&gt; db.nombresprimers.remove( {&quot;_id&quot; : 19} )  
WriteResult({ &quot;nRemoved&quot; : 1 })  
&gt;
</code></pre></div></p>
<p>Ens avisa que ha esborrat un document.</p>
<p>La condició no cal que siga sobre el camp <strong>_id</strong>. Pot ser sobre qualsevol
camp, i esborrarà tots els que coincideixen.
<div class="highlight"><pre><span></span><code>&gt; db.exemple.remove( {&quot;msg3&quot; : &quot;Per ací no ens podem queixar ...&quot;} )  
WriteResult({ &quot;nRemoved&quot; : 1 })  
&gt;
</code></pre></div>
També tenim la possibilitat d'esborrar tota una col·lecció amb la funció
<strong>drop()</strong>. Pareu atenció perquè és molt senzilla d'eliminar, i per tant,
potencialment molt perillosa.
<div class="highlight"><pre><span></span><code>&gt; db.nombresprimers.drop()  
true  
&gt;
</code></pre></div></p>
<h4 class="azul" id="actualitzacio-update">Actualització - update</h4>
<p>La funció <em><strong>update</strong></em> servirà per a actualitzar un document ja guardat.
Tindrà dos paràmetres:</p>
<ul>
<li>El primer paràmetre serà la condició per a trobar el document que s'ha d'actualitzar.</li>
<li>El segon paràmetre serà el nou document que substituirà l'anterior</li>
</ul>
<p>Per exemple, si mirem les dades actuals:
<div class="highlight"><pre><span></span><code>&gt; db.exemple.find()  
{ &quot;_id&quot; : ObjectId(&quot;56ce310bc61e04ba81def50b&quot;), &quot;msg&quot; : &quot;Hola, què tal?&quot; }  
{ &quot;_id&quot; : ObjectId(&quot;56ce31f6c61e04ba81def50c&quot;), &quot;msg2&quot; : &quot;Com va la cosa?&quot; }
</code></pre></div>
Podem comprovar el contingut del segon document, el que te <strong>msg2</strong>. Anem a
modificar-lo: en el primer paràmetre posem condició de recerca (només hi haurà
un) i en el segon posem el nou document que substituirà l'anterior
<div class="highlight"><pre><span></span><code>&gt; db.exemple.update( {msg2:&quot;Com va la cosa?&quot;} , {msg2:&quot;Què? Com va la cosa?&quot;})  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
</code></pre></div>
Observeu que la contestació del <strong>update</strong><strong>()</strong> és que ha fet <strong>match</strong> (hi
ha hagut coincidència) amb un document, i que ha modificat un. Si no en troba
cap, no donarà error, senzillament dirà que ha fet match amb 0 documents, i
que ha modificat 0 documents. Mirem com efectivament ha canviat el segon
document
<div class="highlight"><pre><span></span><code>&gt; db.exemple.find()  
{ &quot;_id&quot; : ObjectId(&quot;56ce310bc61e04ba81def50b&quot;), &quot;msg&quot; : &quot;Hola, què tal?&quot; }  
{ &quot;_id&quot; : ObjectId(&quot;56ce31f6c61e04ba81def50c&quot;), &quot;msg2&quot; : &quot;Què? Com va la cosa?&quot; }
</code></pre></div>
Ens vindran molt bé les variables per a les actualitzacions, ja que en moltes
ocasions serà modificar lleugerament el document, canviant o afegint algun
element. Ho podrem fer còmodament amb la variable: primer guardem el document
a modificar en una variable; després modifiquem la variable; i per últim fem
l'operació d'actualització. Evidentment si tenim alguna variable amb el
contingut del document ens podríem estalviar el primer pas.
<div class="highlight"><pre><span></span><code>&gt; doc1 = db.exemple.findOne()  
{ &quot;_id&quot; : ObjectId(&quot;56ce310bc61e04ba81def50b&quot;), &quot;msg&quot; : &quot;Hola, què tal?&quot; }

&gt; doc1.titol = &quot;Missatge 1&quot;  
Missatge 1

&gt; db.exemple.update( {msg:&quot;Hola, què tal?&quot;} , doc1)  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.exemple.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56ce310bc61e04ba81def50b&quot;),  
  &quot;msg&quot; : &quot;Hola, què tal?&quot;,  
  &quot;titol&quot; : &quot;Missatge 1&quot;  
}  
&gt;
</code></pre></div></p>
<h3 id="333-operacions-dactualitzacio-avancada">3.3.3 - Operacions d'actualització avançada</h3>
<p>Al final de la pregunta anterior hem vist l'actualització de documents ja
existents a la Base de Dades. Aquesta actualització la féiem modificant tot el
document, encara que tenim la variant de guardar el document en una variable,
modificar aquesta variable i després fer l'actualització amb aquesta variable.
Però observeu que continua sent una modificació de tot el document, una
substitució del document antic per un document nou.</p>
<p>En aquesta pregunta veurem la utilització d'uns modificadors (<em>modifiers</em>) de
l'operació <strong>update()</strong> , que ens permetran modificar documents de forma
potent: creant i eliminant claus (elements) d'un document, o canviant-los, i
fins i tot afegir o eliminar elements d'un array.</p>
<h4 class="azul" id="set">$set</h4>
<p>El modificador <strong>$set</strong> assigna un valor a un camp del document seleccionat de
la Base de Dades. Si el camp ja existia, modificarà el valor, i si no existia
el crearà.</p>
<p>La sintaxi del modificador <strong>$set</strong> és la següent:
<div class="highlight"><pre><span></span><code>{ $set : { clau : valor} }
</code></pre></div>
Però recordeu que és un modificador, i l'hem d'utilitzar dins d'una operació
d'actualització. Anirà en el segon paràmetre del <strong>update()</strong> , i per tant amb
aquestos modificadors ja no posem tot el document en el segon paràmetre, sinó
únicament l'operador de modificació.</p>
<p>Mirem-ho millor en un exemple:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.insert( {nom:&quot;Abel&quot;, cognoms:&quot;Bernat Carrera&quot;} )  
WriteResult({ &quot;nInserted&quot; : 1 })  
&gt;  
&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;  
}  
&gt;
</code></pre></div>
Suposem ara que li volem afegir l'edat. Abans ho faríem guardant el document
en una variable, i afegint el camp, per a guardar després. Ara ho tenim més
fàcil:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $set: {edat:21} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
</code></pre></div>
Ha trobat un, i l'ha modificat. Evidentment, si hi haguera més d'un alumne a
mb el nom Abel, els modificaria tots.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
  &quot;edat&quot; : 21  
}
</code></pre></div>
Es pot especificar més d'un camp amb els valor corresponents. Si no existien
es crearan, i si ja existien es modificaran:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $set: {nota: 8.5 , edat:22} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
  &quot;edat&quot; : 22,  
  &quot;nota&quot; : 8.5  
}
</code></pre></div>
I fins i tot es pot canviar el tipus d'un camp determinat, i utilitzar arrays,
i objectes, ...
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $set: {nota: [8.5,7.5,9] ,
&gt; adreça:{carrer:&quot;Major&quot;,numero:7,cp:&quot;12001&quot;} } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  

&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
  &quot;edat&quot; : 22,  
  &quot;nota&quot; : [  
      8.5,  
      7.5,  
      9  
  ],  
  &quot;adreça&quot; : {  
      &quot;carrer&quot; : &quot;Major&quot;,  
      &quot;numero&quot; : 7,  
      &quot;cp&quot; : &quot;12001&quot;  
  }  
}  
</code></pre></div></p>
<p>Podem fins i tot modificar ara només el valor d'un camp d'un objecte del
document. Per exemple, anem a modificar el codi postal de l'anterior alumne.
La manera d'arribar al codi postal serà <strong>adreça.cp</strong> , però haurem d'anar amb
compte que vaja entre cometes per a que el trobe:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $set: {adreça.cp:&quot;12502&quot;} } )  
uncaught exception: SyntaxError: missing : after property id :  
@(shell):1:49  

&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $set: {&quot;adreça.cp&quot;:&quot;12502&quot;} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
  &quot;edat&quot; : 22,  
  &quot;nota&quot; : [  
        8.5,  
        7.5,  
        9  
  ],  
  &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
  }  
}
</code></pre></div></p>
<h4 class="azul" id="unset">$unset</h4>
<p>El modificador <strong>$unset</strong> servirà per a <strong>eliminar</strong> elements (camps) d'un o
uns documents. Si el camp existia, l'eliminarà, i si no existia, no donarà
error (avisarà que s'han modificat 0 documents).</p>
<p>La sintaxi és:
<div class="highlight"><pre><span></span><code>{ $unset : {camp : 1 } }
</code></pre></div>
Haurem de posar un valor al camp que anem a esborrar per a mantenir la sintaxi
correcta, i posem 1 que equival a true. També podríem posar -1, que equival a
false, però aleshores no l'esborraria, i per tant no faríem res. Sempre
posarem 1.</p>
<p>Mirem el següent exemple. Afegim un camp, que serà el número d'ordre, i
després el llevarem.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $set: {num_ordre:10} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
  &quot;edat&quot; : 22,  
  &quot;nota&quot; : [  
        8.5,  
        7.5,  
        9  
  ],  
  &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
  },  
  &quot;num_ordre&quot; : 10  
}  

&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $unset: {num_ordre:1} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $unset: {puntuacio:1} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 })
</code></pre></div>
Hem afegit primer el camp <strong>num_ordre</strong> , i hem mostrat el document per
comprovar que existeix. Després esborrem el camp <strong>num_ordre</strong> (i ens confirma
que ha modificat un document). Després intentem esborrar un camp que no
existeix, <strong>puntuacio</strong>. No dóna error, però ens avisa que ha modificat 0
documents. Podem comprovar al final com el document ha quedat com esperàvem.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;nota&quot; : [  
        8.5,  
        7.5,  
        9  
    ],  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    }  
}
</code></pre></div></p>
<h4 class="azul" id="rename">$rename</h4>
<p>El modificador <strong>$rename</strong> canviarà el nom d'un camp. Si no existia, no donarà
error i senzillament no el modificarà. Hem de cuidar de posar el nou nom del
camp entre cometes, per a que no done error.</p>
<p>La sintaxi és:
<div class="highlight"><pre><span></span><code>{ $rename : { camp1 : &quot;nou_nom1&quot; , camp2 : &quot;nou_nom2&quot; , ... } }
</code></pre></div>
Per exemple, canviem el nom del camp <strong>nota</strong> a <strong>notes</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $rename: {nota:&quot;notes&quot;} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
          &quot;carrer&quot; : &quot;Major&quot;,  
          &quot;numero&quot; : 7,  
          &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;notes&quot; : [  
          8.5,  
          7.5,  
          9  
    ]  
}
</code></pre></div>
Observeu que l'ha canviat de lloc, cosa que ens fa pensar que en canviar de
nom un camp, el que fa és tornar a crear-lo amb el nou nom, i esborrar el camp
antic.</p>
<p>En aquest exemple tornem a canviar el nom a <strong>nota</strong> , i intentem canviar el
nom a un camp inexistent, <strong>camp1</strong>. No donarà error.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $rename: {camp1: &quot;camp2&quot; , notes:&quot;nota&quot;} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
  &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
  &quot;nom&quot; : &quot;Abel&quot;,  
  &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
  &quot;edat&quot; : 22,  
  &quot;adreça&quot; : {  
      &quot;carrer&quot; : &quot;Major&quot;,  
      &quot;numero&quot; : 7,  
      &quot;cp&quot; : &quot;12502&quot;  
  },  
  &quot;nota&quot; : [  
      8.5,  
      7.5,  
      9  
  ]  
}
</code></pre></div></p>
<h4 class="azul" id="inc">$inc</h4>
<p>Com cabria esperar, el modificador <strong>$inc</strong> servirà per a incrementar un camp
numèric. Si el camp existia, l'incrementarà en la quantitat indicada. Si no
existia, crearà el camp amb un valor inicial de 0, i incrementarà el valor amb
la quantitat indicada. La quantitat pot ser positiva, negativa o fins i tot
amb part fraccionària. Sempre funcionarà bé, excepte quan el camp a
incrementar no siga numèric, que donarà error.</p>
<p>La sintaxi és aquesta:
<div class="highlight"><pre><span></span><code>{ $inc : {camp : quantitat } }
</code></pre></div>
En els següents exemples, incrementem un camp nou (per tant el crearà amb el
valor especificat), i després l'incrementem en quantitats positives, negatives
i fraccionàries, concretament l'inicialitzem amb un <strong>2</strong> , i despés
l'incrementem en <strong>5</strong> , en <strong>-4</strong> i en <strong>2.25</strong> , per tant el resultat final
serà <strong>5.25</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $inc: {puntuacio:2} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;nota&quot; : [  
        8.5,  
        7.5,  
        9  
    ],  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;puntuacio&quot; : 2  
}  
&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $inc: {puntuacio:5} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $inc: {puntuacio:-4} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $inc: {puntuacio:2.25} } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;nota&quot; : [  
        8.5,  
        7.5,  
        9  
    ],  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;puntuacio&quot; : 5.25  
}
</code></pre></div></p>
<h4 class="azul" id="elements-dun-array">Elements d'un array</h4>
<p>Per a accedir directament a un element d'un array d'un determinat document es
pot utilitzar la següent sintaxi:
<div class="highlight"><pre><span></span><code>&quot;array.index&quot;
</code></pre></div>
Hem de tenir present que el primer element de l'array és el de subíndex 0. I
no us oblideu de tancar-ho tot entre comentes per a que ho puga trobar.</p>
<p>Si no existeix l'element amb el subíndex indicat, donarà error.</p>
<p>Per exemple, anem a pujar un punt la primera nota de l'alumne que estem
utilitzant en tots els exemples :
<div class="highlight"><pre><span></span><code>&gt;db.alumnes.update( {nom:&quot;Abel&quot;} , { $inc : { &quot;nota.0&quot; : 1 } } )
</code></pre></div></p>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56df11d778549bdfbf2125e3&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        9.5,  
        7.5,  
        9  
    ]  
}
</code></pre></div>
<h4 class="azul" id="insercio-en-arrays-push">Inserció en Arrays: $push</h4>
<p>La manera més senzilla d'introduir un element en un array és utilitzar
<strong>$push</strong> sense més. Si existia l'array, introduirà el o els nous elements al
final. Si no existia l'array, el crearà amb aquest o aquestos elements.</p>
<p>La sintaxi és:
<div class="highlight"><pre><span></span><code>{ $push : { clau : element } }
</code></pre></div>
Per exemple anem a afegir una nota a l'alumne de sempre, i posem-la diferent
per veure que s'introdueix al final:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $push : { nota : 7 } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56df11d778549bdfbf2125e3&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        9.5,  
        7.5,  
        9,  
        7  
    ]  
}
</code></pre></div>
També hi ha manera d'introduir un element en una determinada posició que no
siga al final, però es complica prou la cosa, ja que hem d'utilitzar per una
banda el modificador <strong>$position</strong> per a dir on s'ha d'inserir, i per una
altra banda el modificador <strong>$each</strong> per a poder especificar el o els valors
que es volen inserir. Es posa a continuació únicament de forma il·lustrativa.</p>
<p>Per a inserir en una determinada posició hem d'utilitzar obligatòriament 2
modificadors més:</p>
<ul>
<li><strong>$position</strong> indicarà a partir de quina posició es farà l'acció (normalment d'inserir en l'array, és a dir, <strong>$push</strong>)</li>
<li><strong>$each</strong> ens permet especificar una sèrie de valors com un array, i vol dir que es farà l'operació per a cada valor de l'array</li>
</ul>
<p>Els dos modificadors seguiran la sintaxi de sempre, de clau valor, per tant el
conjunt de la sintaxi és:
<div class="highlight"><pre><span></span><code>{ $ push :  
  { clau_del_array :  
    { $position : _posició_ ,  
    $each : [ _valors_ ]  
    }  
  }  
}
</code></pre></div>
Ací tenim un exemple on introduïm una nota en la primera posició:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $push : { nota : { $position : 0 , $each
&gt; : [5] } } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })

&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56df11d778549bdfbf2125e3&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
          &quot;carrer&quot; : &quot;Major&quot;,  
          &quot;numero&quot; : 7,  
          &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        5,  
        9.5,  
        7.5,  
        9,  
        7  
    ]     
}
</code></pre></div></p>
<h4 class="azul" id="eliminacio-en-arrays-pop-i-pull">Eliminació en arrays: $pop i $pull</h4>
<p>Hi ha més d'una manera d'eliminar elements d'un array.</p>
<p><strong class="azul">$pop</strong></p>
<p>Si volem eliminar el primer element o l'últim, el modificador adequat és
<strong>$pop</strong>. La sintaxi és
<div class="highlight"><pre><span></span><code>{ $pop : { clau : posicio } }
</code></pre></div>
On en posició podrem posar:</p>
<ul>
<li>-1 , i esborrarà el primer element</li>
<li>1 , i esborrarà l'últim</li>
</ul>
<p>En els següents exemples s'esborren primer l'últim element i després el
primer.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56df11d778549bdfbf2125e3&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
          &quot;carrer&quot; : &quot;Major&quot;,  
          &quot;numero&quot; : 7,  
          &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
          5,  
          9.5,  
          7.5,  
          9,  
          7  
    ]  
}
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $pop : { nota : 1 } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
      &quot;_id&quot; : ObjectId(&quot;56df11d778549bdfbf2125e3&quot;),  
      &quot;nom&quot; : &quot;Abel&quot;,  
      &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
      &quot;edat&quot; : 22,  
      &quot;adreça&quot; : {  
            &quot;carrer&quot; : &quot;Major&quot;,  
            &quot;numero&quot; : 7,  
            &quot;cp&quot; : &quot;12502&quot;  
      },  
      &quot;nota&quot; : [  
              5,  
              9.5,  
              7.5,  
              9  
      ]  
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $pop : { nota : -1 } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })  
&gt; db.alumnes.findOne()  
{  
      &quot;_id&quot; : ObjectId(&quot;56df11d778549bdfbf2125e3&quot;),  
      &quot;nom&quot; : &quot;Abel&quot;,  
      &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
      &quot;edat&quot; : 22,  
      &quot;adreça&quot; : {  
            &quot;carrer&quot; : &quot;Major&quot;,  
            &quot;numero&quot; : 7,  
            &quot;cp&quot; : &quot;12502&quot;  
      },  
      &quot;nota&quot; : [  
            9.5,  
            7.5,  
            9  
      ]  
}
</code></pre></div>
<strong class="azul">$pull</strong> </p>
<p>Amb aquest modificador esborrarem els elements de l'array que coincidesquen
amb una condició, estiguen en la posició que estiguem. Observeu com es pot
eliminar més d'un element.</p>
<p>Per a poder comprovar-lo bé, primer inserim un altre element al final de
l'array, amb el valor <strong>7.5</strong> (si heu seguit els mateixos exemples que en
aquestos apunts, aquest valor ja es troba en la segona posició).
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $push : { nota : 7.5 } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        9.5,  
        7.5,  
        9,  
        7.5  
    ]  
}
</code></pre></div>
Ara anem a esborrar amb <strong>$pull</strong> l'element de valor <strong>7.5</strong>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( {nom:&quot;Abel&quot;} , { $pull : { nota : 7.5 } } )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.findOne()  
{  
      &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
      &quot;nom&quot; : &quot;Abel&quot;,  
      &quot;cognoms&quot; : &quot;Bernat Carrera&quot;,  
      &quot;edat&quot; : 22,  
      &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
      },  
      &quot;nota&quot; : [  
          9.5,  
          9  
      ]  
}
</code></pre></div></p>
<h4 class="azul" id="upsert">Upsert</h4>
<p>Aquesta paraula ja l'havíem comentada en un punt anterior.</p>
<p>En el <strong>update()</strong> normal, si la condició de búsqueda no donava cap resultat
(parlant ràpid, si no feis <em>matching</em> amb cap document), doncs no actualitzava
cap document i punt.</p>
<p>El <strong>Upsert</strong> és una variant de l'update, que quan no coincidesca cap document
amb la condició, crearà un document nou que serà el resultat de combinar el
criteri que s'ha utilitzat en la condició amb les operacions d'actualització
fetes en el segon paràmetre</p>
<p>Per a que un <strong>Update</strong> actue d'aquesta manera, li hem de posar un tercer
paràmetre amb el valor <strong>true</strong> :
<div class="highlight"><pre><span></span><code>update ( {...} , {...} , true )
</code></pre></div>
Recordeu que el primer paràmetre era la condició, i el segon l'actualització.</p>
<p>Mirem-ho en l'exemple dels alumnes. Si anem a actualitzar els cognoms, i es
troba el document, s'actualitzarà:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( { nom:&quot;Abel&quot; } , { $set : { cognoms : &quot;Bernat Cantera&quot; }} , true )  
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
</code></pre></div>
Efectivament, ens diu que ha modificat un document.</p>
<p>Però si no es troba el document (per exemple perquè li hem posat el nom
<strong>Berta</strong>):
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.update( { nom:&quot;Berta&quot; } , { $set : { cognoms : &quot;Bernat Cantero&quot; }} , true )  
WriteResult({  
&quot;nMatched&quot; : 0,  
&quot;nUpserted&quot; : 1,  
&quot;nModified&quot; : 0,  
&quot;_id&quot; : ObjectId(&quot;56dfdbd136d8b095cb6bd57a&quot;)  
})
</code></pre></div>
Ja ens avisa que no ha fet cap <em>matching</em> , i ha fet un <strong>Upsert</strong>. Ho podem
comprovar mirant tots els document de la col·lecció:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find()  
{ &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;), &quot;nom&quot; : &quot;Abel&quot;, &quot;cognoms&quot; : &quot;Bernat Cantera&quot;, 
&quot;edat&quot; : 22, &quot;adreça&quot; : { &quot;carrer&quot; : &quot;Major&quot;, &quot;numero&quot; : 7, &quot;cp&quot; : &quot;12502&quot; }, &quot;nota&quot; : [ 9.5, 9 ] }  
{ &quot;_id&quot; : ObjectId(&quot;56dfdbd136d8b095cb6bd57a&quot;), &quot;nom&quot; : &quot;Berta&quot;, &quot;cognoms&quot; : &quot;Bernat Cantero&quot; }  
&gt;
</code></pre></div>
El nou document tindrà els camps:</p>
<ul>
<li><strong>_id</strong> , amb el que ens havia avisat que generaria</li>
<li>Els camps de la condició, que en el nostre exemple és <strong>{ nom:"Berta" }</strong></li>
<li>Els camps de l'actualització, que en el nostre exemple eren els cognoms</li>
</ul>
<h2 id="34-consulta-de-documents">3.4 - Consulta de documents</h2>
<p>En la pregunta anterior hem vist com introduir, eliminar i modificar
documents. Les consultes de documents han segut molt senzilles, per a
comprovar únicament els resultats.</p>
<p>En aquesta pregunta veurem en profunditat la consulta de documents.</p>
<ul>
<li>Funcions <strong>find()</strong> i <strong>findOne()</strong> , que són les que hem utilitzat fina ara. Veurem en profunditat la seua sintaxi i potència.</li>
<li>Limitarem i ordenarem també els resultats</li>
<li>Fins i tot podrem elaborar més els resultats, agrupant els resultats, utilitzant funcions d'agregació (o millor dir operadors d'agregació) i donant-los un aspecte diferent</li>
</ul>
<h3 id="341-parametres-de-les-funcions-find-i-findone">3.4.1 - Paràmetres de les funcions find() i findOne()</h3>
<p>Les funcions <strong>find()</strong> i <strong>findOne()</strong> són absolutament equivalents, amb
l'única diferència que la primera torna tots els documents trobats, mentre que
la segona només torna el primer document trobat.</p>
<p>Per una millor comprensió, utilitzarem únicament <strong>find()</strong> , per veure tots
els resultats obtinguts.</p>
<p>La funció <strong>find()</strong> s'ha comparat tradicionalment amb la sentència SELECT de
SQL. Sempre tornarà un conjunt de documents, que poden variar des de no tornar
cap document, a tornar-los tots els de la col·lecció.</p>
<p>La funció <strong>find()</strong> pot tenir uns quants paràmetres.</p>
<ul>
<li>El primer indica una condició o criteri, i tornarà aquells documents de la col·lecció que acomplesquen la condició o criteri. Aquesta condició ve donada en forma de document (o objecte) JSON, i és com l'havíem vist en la funció <strong>update()</strong> :
<div class="highlight"><pre><span></span><code>db.col_leccio1.find( { clau1 : valor1 } )
</code></pre></div>
Tornarà tots els documents de la col·lecció <strong>col_leccio1</strong> que tinguen el
camp <strong>clau1</strong> i que en ell tinguen el valor <strong>valor1</strong>.</li>
</ul>
<p>Aquest criteri pot ser el complicat que faça falta, formant-lo en JSON. Pot
tenir més d'un membre. En definitiva, tornarà aquells documents que facen
<em>matching</em> amb el document del criteri, és a dir, funcionaria com un <strong>and</strong>
en cas que tinga més d'un membre en la condició
<div class="highlight"><pre><span></span><code>db.col_leccio1.find( { clau1 : valor1 , clau2 : valor2 } )
</code></pre></div>
que tornaria aquells documents de la <strong>col_lecció1</strong> que tenen el camp
<strong>clau1</strong> amb el valor <strong>valor1</strong> i que tenen el camp <strong>clau2</strong> amb el valor
<strong>valor2</strong></p>
<p>Si no volem posar cap criteri, per a que els torne tots, no posem res com a
paràmetre, o encara millor, li passem un document (objecte) buit, de manera
que tots els documents de la col·lecció faran <em>matching</em> amb ell.
<div class="highlight"><pre><span></span><code>db.col_leccio1.find( { } )
</code></pre></div>
Tindrem açò present, sobretot quan ens toque utilitzar el segon paràmetre de
<strong>find</strong>. Si no volem cap criteri, posarem el document buit com l'exemple
anterior.</p>
<ul>
<li>El segon paràmetre ens servirà per a delimitar els camps dels documents que es tornaran. També tindrà el format JSON d'un objecte al qual li posarem com a claus els diferents camps que volem que apareguen o no, i com a valor 1 per a que sí que apareguen i 0 per a que no apareguen.</li>
</ul>
<p>Si posem algun camp a que sí que aparega (és a dir, amb el valor 1), els únics
que apareixeran seran aquestos, a més del<strong>_id</strong> que per defecte sempre
apareix.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find({},{nom:1})  
{ &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;), &quot;nom&quot; : &quot;Abel&quot; }  
{ &quot;_id&quot; : ObjectId(&quot;56dfdbd136d8b095cb6bd57a&quot;), &quot;nom&quot; : &quot;Berta&quot; }
</code></pre></div>
Per tant si no volem que aparega <strong>_id</strong> posarem:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find({},{_id:0})  
{ &quot;nom&quot; : &quot;Abel&quot;, &quot;cognoms&quot; : &quot;Bernat Cantera&quot;, &quot;edat&quot; : 22, &quot;adreça&quot; : {
&quot;carrer&quot; : &quot;Major&quot;, &quot;numero&quot; : 7, &quot;cp&quot; : &quot;12502&quot; }, &quot;nota&quot; : [ 9.5, 9 ] }  
{ &quot;nom&quot; : &quot;Berta&quot;, &quot;cognoms&quot; : &quot;Bernat Cantero&quot; }
</code></pre></div>
I si volem traure únicament el nom:
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find({},{nom:1,_id:0})  
{ &quot;nom&quot; : &quot;Abel&quot; }  
{ &quot;nom&quot; : &quot;Berta&quot; }
</code></pre></div>
Per últim, com que a partir d'ara utilitzarem documents més complicats, si
volem que ens apareguen els camps que retornem d'una forma un poc més elegant
o bonica (<em>pretty</em>), posarem aquesta funció al final: <strong>find().pretty()</strong>
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find().pretty()  
{  
      &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
      &quot;nom&quot; : &quot;Abel&quot;,  
      &quot;cognoms&quot; : &quot;Bernat Cantera&quot;,  
      &quot;edat&quot; : 22,  
      &quot;adreça&quot; : {  
          &quot;carrer&quot; : &quot;Major&quot;,  
          &quot;numero&quot; : 7,  
          &quot;cp&quot; : &quot;12502&quot;  
      },  
      &quot;nota&quot; : [  
          9.5,  
          9  
      ]  
}  
{  
&quot;_id&quot; : ObjectId(&quot;56dfdbd136d8b095cb6bd57a&quot;),  
&quot;nom&quot; : &quot;Berta&quot;,  
&quot;cognoms&quot; : &quot;Bernat Cantero&quot;  
}
</code></pre></div></p>
<h3 id="342-operadors-de-les-condicions">3.4.2 - Operadors de les condicions</h3>
<p>Abans de començar aquesta pregunta, anem a agafar unes dades de prova, que
estan en el fitxer <strong>libros_ejemplo.json</strong></p>
<p>Només heu de copiar el contingut del fitxer en la terminal del client de
Mongo.</p>
<p>Posem ací el contingut per a que pugueu pegar-li una miradeta sense necessitat
d'obrir-lo. Anirà bé per als exemples posteriors.</p>
<pre><code>db.libro.insert({  
    "_id":"9788408117117",  
      "titulo":"Circo Máximo",  
    "autor":"Santiago Posteguillo",  
    "editorial":"Planeta",  
    "enstock":true,  
    "paginas":1100,  
    "precio":21.75,  
    "fecha":new ISODate("2013-08-29T00:00:00Z"),          
    "resumen":"Circo Máximo, de Santiago Posteguillo, que ha escrito otras obras de narrativa histórica como Las Legiones Malditas o La traición de Roma, es la segunda parte de la trilogía de Trajano, que comenzó con Los asesinos del emperador, un relato impactante, descomunal, descrito con un trepidante pulso narrativo destinado a trasla dar al lector a la Roma imperial de los césares. Santiago posteguillo se ha convertido en el autor español de referencia de la novela histórica sobre Roma y el mundo antiguo. Bienvenidos al mundo de Marco Ulpio Trajano. Circo Máximo es la historia de Trajano y su gobierno, guerras y traiciones, lealtades insobornables e historias de amor imposibles. Hay una vestal, un juicio, inocentes acusados, un abogado especial, mensajes cifrados, códigos secretos, batallas campales, fortalezas inexpugnables, asedios sin fin, dos aurigas rivales, el Anfiteatro, los gladiadores y tres carreras de cuadrigas. Hay también un caballo especial, diferente a todos, leyes antiguas olvidadas, sacrificios humanos, amargura y terror, pero también destellos de nobleza y esperanza, como la llama de Vesta, que mientras arde preserva a Roma. Sólo que hay noches en las que la llama del Templo de Vesta tiembla. La rueda de la Fortuna comienza entonces a girar. En esos momentos, todo puede pasar y hasta la vida del propio Trajano, aunque él no lo sepa, corre peligro. Y, esto es lo mejor de todo, ocurrió: hubo un complot para asesinar a Marco Ulpio Trajano."  
})

db.libro.insert({  
     "_id":"9788401342158",  
      "titulo":"El juego de Ripper",  
      "autor":"Isabel Allende",  
      "editorial":"Plaza &amp; Janes",  
      "enstock":true,  
      "paginas":480,  
      "precio":21.75,  
    "fecha":new ISODate("2014-03-01T00:00:00Z"),          
      "resumen":"Tal como predijo la astróloga más reputada de San Francisco, una oleada de crímenes comienza a sacudir la ciudad. En la investigación sobre los asesinatos, el inspector Bob Martín recibirá la ayuda inesperada de un grupo de internautas especializados en juegos de rol, Ripper. 'Mi madre todavía está viva, pero la matará el Viernes Santo a medianoche', le advirtió Amanda Martín al inspector jefe y éste no lo puso en duda, porque la chica había dado pruebas de saber más que él y todos sus colegas del Departamento de Homicidios. La mujer estaba cautiva en algún punto de los dieciocho mil kilómetros cuadrados de la bahía de San Francisco, tenían pocas horas para encontrarla con vida y él no sabía por dónde empezar a buscarla",  
 })  
   
db.libro.insert({  
    "_id":"9788496208919",  
   "titulo":"Juego de tronos: Canción de hielo y fuego 1",  
   "autor":"George R.R. Martin",  
   "editorial":"Gigamesh",  
   "enstock":true,  
   "paginas":793,  
   "precio":9.5,  
   "fecha":new ISODate("2011-11-24T00:00:00Z"),       
   "resumen":"Tras el largo verano, el invierno se acerca a los Siete Reinos. Lord Eddars Stark, señor de Invernalia, deja sus dominios para unirse a la corte del rey Robert Baratheon el Usurpador, hombre díscolo y otrora guerrero audaz cuyas mayores aficiones son comer, beber y engendrar bastardos. Eddard Stark desempeñará el cargo de M ano del Rey e intentará desentrañar una maraña de intrigas que pondrá en peligro su vida... y la de los suyos. En un mundo cuyas estaciones duran décadas y en el que retazos de una magia inmemorial y olvidada surgen en los rincones más sombrios y maravillosos, la traición y la lealtad, la compasión y la sed de venganza, el amor y el poder hacen del juego de tronos una poderosa trampa que atrapa en sus fauces a los personajes... y al lector. 'El regreso triunfal de Martin a la fantasía de más alta calidad... con personajes desarrollados con maestría, prosa hábil y pura obstinación.'"  
})

db.libro.insert({  
  "_id":"9788499088075",  
  "titulo":"La ladrona de libros",  
  "autor":"Markus Zusak",  
  "editorial":"Debolsillo",  
  "enstock":false,  
  "paginas":544,  
  "precio":9.45,  
  "fecha":new ISODate("2009-01-09T00:00:00Z"),        
  "resumen":"En plena II Guerra Mundial, la pequeña Liesel hallará su salvación en la lectura. Una novela preciosa, tremendamente humana y emocionante, que describe las peripecias de una niña alemana de nueve años desde que es dada en adopción por su madre hasta el final de la guerra. Su nueva familia, gente sencilla y nada afecta al na zismo, le enseña a leer y a través de los libros Rudy logra distraerse durante los bombardeos y combatir la tristeza. Pero es el libro que ella misma está escribiendo el que finalmente le salvará la vida.",  
})

db.libro.insert({  
  "_id":"9788415140054",  
  "titulo":"La princesa de hielo",  
  "autor":"Camilla Lackberg",  
  "editorial":"Embolsillo",  
  "enstock":true,  
  "precio":11,  
  "fecha":new ISODate("2012-10-30T00:00:00Z"),      
  "resumen":"Misterio y secretos familiares en una emocionante novela de suspense Erica vuelve a su pueblo natal tras el fallecimiento de sus padres, pero se va a encontrar con un nuevo drama. Aparentemente su amiga de la infancia, Alex, se ha suicidado. Pronto se descubre que no solamente fue asesinada sino que estaba embarazada. El primer sospechoso es Anders, un artista fracasado con quien Alex mantenía una relación especial. Pero poco después de ser liberado por falta de pruebas, Anders aparece muerto en su domicilio. Con la ayuda del comisario Patrik, Erica investigará el pasado de su amiga Alex."  
})

db.libro.insert({  
  "_id":"9788408113331",  
  "titulo":"Las carreras de Escorpio",  
  "autor":"Maggie Stiefvater",  
  "editorial":"Planeta",  
  "enstock":false,  
  "paginas":290,  
  "precio":17.23,  
  "fecha":new ISODate("2013-06-04T00:00:00Z"),    
  "resumen":"En la pequeña isla de Thisby, cada noviembre los caballos de agua de la mitología celta emergen del mar. Y cada noviembre, los hombres los capturan para participar en una emocionante carrera mortal. En las carreras de Escorpio, algunos compiten para ganar. Otros para sobrevivir. Los jinetes intentan dominar a sus caballos de agua el tiempo suficiente para acabar la carrera. Algunos lo consiguen. El resto, muere en el intento. Sean Kendrick es el favorito, y necesita ganar la carrera para ganar, también, su libertad. Pero Puck Connolly está dispuesta a ser su más dura adversaria. Ella nunca quiso participar en las carreras. Pero no tiene elección: o compite y gana o… lo pierde todo.",  
})

db.libro.insert({  
  "_id":"9788468738895",  
  "titulo":"Las reglas del juego",  
  "autor":"Anna Casanovas",  
  "enstock":true,  
  "paginas":null,  
  "precio":15.90,  
  "fecha":new ISODate("2014-02-06T00:00:00Z"),  
  "resumen":"Susana Lobato tiene la vida perfectamente planeada y está a punto de conseguir todo lo que quiere: va a tener su propio programa de noticias económicas y en dos meses va a casarse con un hombre maravilloso. Pero una noche Tim anula la boda y la abandona para perseguir un sueño que no la incluye a ella.Kev MacMurray acaba de cumplir treinta y cinco años y siente que ha llegado el momento de dar un cambio a su vida. No sabe por qué, pero últimamente se está asfixiando y está convencido de que no puede seguir donde está. Lo único que lo retiene es la boda de Tim, su mejor amigo.Pero Tim anula la boda y una noche Kev coincide con Susana y respira por primera vez en mucho tiempo.¿Por qué no le había sucedido antes? Se suponía que él y Susana no se soportaban ¿Desde cuándo siente que si no besa a la prometida de su mejor amigo no podrá seguir respirando?Susana nunca había reaccionado así con nadie. ¿Puede correr el riesgo de averiguar qué pasará si se entrega a Kev?Y qué pasará si vuelve Tim, ¿podrán dar un paso atrás?.",  
})
</code></pre>
<p>Podeu comprovar que hi ha 7 documents en la nova col·lecció <strong>libro</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.libro.count()  
7
</code></pre></div>
I també podem consultar els títols de forma còmoda:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( {} , {titulo:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot; }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot; }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot; }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot; }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }
</code></pre></div>
I un altre exemple, on consultem els llibres que estan en stock (hi ha un camp
booleà que ho diu: <strong>enstock</strong>), mostrant títol, editorial i preu
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( {enstock: true} , {titulo:1 , editorial:1 , precio:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot;, &quot;precio&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot;, &quot;precio&quot; : 11 }
</code></pre></div>
I un últim exemple, on consultem els llibres que estan en stock i tenen un
preu de 21.75 €, mostrant tot excepte el _id i el resum
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( {enstock: true , precio: 21.75} , {titulo:1 , editorial:1 , &gt; precio:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }
</code></pre></div>
Anem a mirar ara operadors que ens serviran per fer millor les consultes.</p>
<h4 id="operadors-de-comparacio">Operadors de comparació</h4>
<p>Fins ara en totes les condicions hem utilitzat la igualtat, si un determinat
camp era igual a un determinat valor. Però hi ha infinitat de consultes en les
quals voldrem altres operacions de comparació: major, major o igual, menor,
...</p>
<p>Aquestos són els operadors de comparació:</p>
<ul>
<li><strong>$lt</strong> (<em>less than</em>) <strong>menor</strong></li>
<li><strong>$lte</strong>(<em>less than or equal</em>)<strong>menor o igual</strong></li>
<li><strong>$gt</strong>(<em>gretaer than</em>) major</li>
<li><strong>$gte</strong> (<em>gretaer than or equal</em>) <strong>major o igual</strong></li>
<li><strong>$ne</strong> (<em>not equal</em>) <strong>distint</strong></li>
<li><strong>$eq</strong> (<em>equal</em>) <strong>igual</strong> (però aquest quasi que no caldria, perquè en no posar res es refereix a la igualtat com fins ara)</li>
</ul>
<p>La sintaxi per a la seua utilització és, com sempre, acoplar-se a la sintaxi
JSON:
<div class="highlight"><pre><span></span><code>clau : { $operador : valor [, ... ] }
</code></pre></div>
Així per exemple, per a buscar els llibres de més de 10 €:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { precio : { $gt : 10 } } , { titulo:1 , precio:1 } )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;precio&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;precio&quot; : 17.23 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9
}
</code></pre></div>
I per a buscar els llibres entre 10 i 20 €:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { precio : { $gt : 10 , $lt:20 } } , { titulo:1 , precio:1 }
&gt; )  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;precio&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;precio&quot; : 17.23 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9
}
</code></pre></div>
És especialment útil per a les dates, ja que difícilment trobarem una data (i
hora) exacta, i voldrem quasi sempre els documents anteriors a una data, o
posteriors, o entre dues dates. Haurem d'anar amb compte pel tractament
especial de les dates: hem de comparar coses del mateix tipus, i per tant la
data amb la qual volem comparar l'haurem de tenir en forma de data:
<div class="highlight"><pre><span></span><code>&gt; var d = new ISODate(&quot;2013-01-01T00:00:00Z&quot;)  
&gt; db.libro.find( {fecha:{$gte:d} } , {fecha:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;fecha&quot; : ISODate(&quot;2013-08-29T00:00:00Z&quot;) }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;fecha&quot; : ISODate(&quot;2014-03-01T00:00:00Z&quot;) }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;fecha&quot; : ISODate(&quot;2013-06-04T00:00:00Z&quot;) }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;fecha&quot; : ISODate(&quot;2014-02-06T00:00:00Z&quot;) }
</code></pre></div>
 <strong class="azul">$in</strong></p>
<p>Servirà per a comprovar si el valor d'un camp està entre els d'una llista,
proporcionada com un array. La sitaxi és:
<div class="highlight"><pre><span></span><code>clau : { $in : [valor1 , valor2 , ... , valorN] }
</code></pre></div>
I ací tenim un exemple, els llibre de les editorials Planeta i Debolsillo:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { editorial: {$in : [&quot;Planeta&quot; , &quot;Debolsillo&quot;]} } , {titulo:1
&gt; , editorial:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;}  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot; }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot; }  
</code></pre></div>
 <strong class="azul">$nin</strong></p>
<p>És el contrari, traura els que no estan en la llista.
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { editorial: {$nin : [&quot;Planeta&quot; , &quot;Debolsillo&quot;]} } , &gt; {titulo:1 , editorial:1} )  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot; }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }
</code></pre></div>
Observeu com també trau els llibres que no tenen editorial, com és el cas de
l'últim llibre, Las reglas del juego</p>
<p><strong class="azul">$or</strong></p>
<p>L'operador anterior, <strong>$in</strong> , ja feia una espècie de OR, però sempre sobre el
mateix camp. Si l'operació OR la volem fer sobre camps distints, haurem
d'utilitzar l'operador <strong>$or</strong>. La seua sintaxi ha de jugar amb la
possibilitat de posar molts elements, i per tant convé l'array:
<div class="highlight"><pre><span></span><code>$or : [ {clau1:valor1} , {clau2:valor2} , ... , {clauN:valorN} ]
</code></pre></div>
Serà cert si s'acompleix alguna de les condicions. Per exemple, traure els
llibres que no estan en stock o que no tenen editorial:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { $or : [ {enstock:false} , {editorial:null} ] } , {titulo:1 &gt; , enstock:1 , editorial:1} )  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot;, &quot;enstock&quot; : false }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;enstock&quot; : false }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;enstock&quot; : true}
</code></pre></div>
 <strong class="azul">$not</strong></p>
<p>Serveix per a negar una altra condició.
<div class="highlight"><pre><span></span><code>$not : { condició }
</code></pre></div>
Per exemple els llibres que no són de l'editorial Planeta (observeu que seria
més senzill utilitzar l'operador <strong>$ne</strong> , però és per a mostrar el seu
funcionament:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { editorial: {$not : {$eq:&quot;Planeta&quot;} } } , {titulo:1 , editorial:1} )  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot; }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot; }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }  
</code></pre></div></p>
<p><strong class="azul">$exists</strong></p>
<p>Servirà per a saber els documents que tenen un determinat camp
<div class="highlight"><pre><span></span><code>clau : { $exists : _boolean_ }
</code></pre></div>
Depenet del valor <em>boolean</em> , el funcionament serà:</p>
<ul>
<li><strong>true</strong> : torna els documents en els quals existeix el camp, encara que el seu valor siga nul</li>
<li><strong>false</strong> : torna els documents que no tenen el camp.</li>
</ul>
<p>Anem a traure els llibres que tenen el camp <strong>paginas</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { paginas: {$exists:true} } , {titulo:1 , paginas:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;paginas&quot; : 1100 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;paginas&quot; : 480 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;paginas&quot; : 793 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;paginas&quot; : 544 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;paginas&quot; : 290 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;paginas&quot; : null }
</code></pre></div>
Observeu com ens apareix també l'ultim llibre, que té el camp <strong>paginas</strong> amb
el valor <strong>nul</strong>. En canvi si haguérem fet la consulta preguntant pels que són
diferents de nul, no apareixeria aquest últim llibre:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { paginas: {$ne:null} } , {titulo:1 , paginas:1} )  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;paginas&quot; : 1100 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;paginas&quot; : 480 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;paginas&quot; : 793 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;paginas&quot; : 544 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;paginas&quot; : 290 }
</code></pre></div>
I si posem <strong>false</strong> al valor en el <strong>$exists</strong> , únicament ens apareixerà el
llibre que no té el camp:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { paginas: {$exists:false} } , {titulo:1 , paginas:1} )  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot; }
</code></pre></div>
I per la mateixa raó que abans, si traiem els que tenen <strong>paginas</strong> a null,
ens eixirà tant qui no té el camp, com qui el té però amb valor nul:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { paginas: null } , {titulo:1 , paginas:1} )  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;paginas&quot; : null}
</code></pre></div>
Per tant, per a segons quines coses, ens interessa l'operador <strong>$exists</strong> , en
compte de jugar amb el nul.</p>
<h4 id="expressions-regulars">Expressions regulars</h4>
<p>Mongo accepta les expressions regulars de forma nativa, cosa que dóna molta
potència per a poder buscar informació diversa.</p>
<p>Les expressions regulars en Mongo tenen la mateixa sintaxi que en Perl, i que
és molt molt pareguda a la major part de llenguatges de programació.</p>
<p>Mirem alguns exemples. Els llibres dins dels quals està la paraula <strong>juego</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { titulo: /juego/ } , {titulo:1} )  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }
</code></pre></div>
Ara que tenen la paraula <strong>juego</strong> sense importar majúscules o minúscules:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { titulo: /juego/i } , {titulo:1} )  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }
</code></pre></div>
I ara que tenen la paraula <strong>juego</strong> només al principi.
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { titulo: /^juego/i } , {titulo:1} )  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot; }
</code></pre></div>
I ara els llibres que en el resum (<strong>resumen</strong>) tenen la paraula <strong>amiga</strong> o
<strong>amigo</strong> , és a dir <strong>amig</strong> seguit d'una <strong>a</strong> o una <strong>o</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.libro.find( { resumen: /amig[ao]/i } , {titulo:1} )  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }
</code></pre></div>
 <strong class="azul">Arrays</strong></p>
<p>Les consultes dins d'arrays de Mongo són molt senzilles.</p>
<p>La més senzilla és quan busquem un valor d'un tipus senzill, i en aquest cas
el que farà Mongo és buscar en tot l'array per si està aquest valor. És a dir,
exactament igual que el que hem fet fins ara.
<div class="highlight"><pre><span></span><code>db.col_leccio1.find ( { clau_array : valor } )
</code></pre></div>
Mirem-ho en un exemple. Anem a crear dos documents que tinguen un array
cadascun, per exemple de colors. El creem en una col·lecció nova, anomenada
<strong>colorins</strong> , en dos documents amb el mateix camp de tipus array, <strong>color</strong> ,
però amb dades diferents<strong><em>*</em></strong>*:
<div class="highlight"><pre><span></span><code>&gt; db.colorins.insert({color: [&quot;roig&quot;,&quot;blau&quot;,&quot;groc&quot;]})  
WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre></div></p>
<p><div class="highlight"><pre><span></span><code>&gt; db.colorins.insert({color: [&quot;negre&quot;,&quot;blanc&quot;,&quot;roig&quot;]})  
WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find();  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }
</code></pre></div></p>
<p>Com es veu en la sintaxi, triar els documents que tenen un camp (en aquest cas
d'array) que continga un valor, és igual de senzill que quan es tracta d'un
camp de tipus string, per exemple:</p>
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({color:&quot;roig&quot;})  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }
</code></pre></div>
<p>També podem utilitzar qualsevol dels operadors vistos fins el moment, com per
exemple l'operador <strong>$in</strong> , que mirarà els documents que tenen algun dels
colors que s'especifica a continuació:
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({color: {$in : [&quot;groc&quot;,&quot;lila&quot;]} })  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }
</code></pre></div>
O per exemple també utilitzar <strong>expressions regulars</strong> :
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({color: /bl/ })  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }
</code></pre></div>
 <strong class="azul">$ all</strong></p>
<p>L'operador <strong>$all</strong> el podem utilitzar quan vulguem seleccionar els documents
que en l'array tiguen <strong>tots</strong> els elements especificats.</p>
<p>Per exemple, anem a buscar els document que tenen el color roig i blau.</p>
<p><div class="highlight"><pre><span></span><code>&gt; db.colorins.find({color : { $all : [&quot;roig&quot;,&quot;blau&quot;]} })  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }
</code></pre></div>
 <strong class="azul">Subíndex</strong></p>
<p>Si volem mirar exactament una determinada posició de l'array, podem
especificar la posició immediatament després de la clau, <strong>separada per un
punt</strong>. Recordeu que la primera posició és la <strong>0</strong>. Hem de posar entre
cometes la clau i la posició, sinó no sabrà trobar-la.</p>
<p>Per exemple, busquem els documents que tenen el roig en la primera posició.</p>
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({&quot;color.0&quot; : &quot;roig&quot;} )  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Accedir a una determinada posició és fàcil, però no és tan fàcil accedir a una
posició calculada, per exemple a l'última posició. Ja fa falta coneixements un
poc més avançats de JavaScript, per a posar dins del <strong>find()</strong> una funció en
JavaScript, i actuar dins d'aquesta.</p>
</div>
<hr />
<p>Únicament de manera il·lustrativa, posem ací la manera de traure els
documents, l'últim color dels quals és el roig. En ella ens creem una variable
amb l'últim element de l'array (amb <strong>pop()</strong>), i el comparem amb el color
roig, tornant true en cas de que sí que siguen iguals:</p>
<p><div class="highlight"><pre><span></span><code>&gt; db.colorins.find(function() { var a =this.color.pop(); return (a ==&quot;roig&quot;)})  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }
</code></pre></div>
També hi ha una forma alternativa de fer-ho, que és utilitzant l'operador
<strong>$where</strong>, que ens permet crear condicions amb sintaxi JavaScript:</p>
<p><div class="highlight"><pre><span></span><code>&gt; db.colorins.find({$where:&quot;this.color[this.color.length - 1]==&#39;roig&#39;&quot;})  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }
</code></pre></div>
 <strong class="azul">$size</strong></p>
<p>L'operador <strong>$size</strong> ens servirà per a fer condicions sobre el número
d'elements d'un array.</p>
<p>Incorporem 2 documents nous, amb 2 i 4 elements respectivament, per a poder
comprovar-lo:</p>
<p><div class="highlight"><pre><span></span><code>&gt; db.colorins.insert({color: [&quot;negre&quot;,&quot;blanc&quot;]})  
WriteResult({ &quot;nInserted&quot; : 1 })
&gt; db.colorins.insert({color: [&quot;taronja&quot;,&quot;gris&quot;,&quot;lila&quot;,&quot;verd&quot;]})  
WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre></div>
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find()  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16972aa3c92aaed389da6&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16990aa3c92aaed389da7&quot;), &quot;color&quot; : [ &quot;taronja&quot;, &quot;gris&quot;, &quot;lila&quot;, &quot;verd&quot; ] }
</code></pre></div>
Ara anem a seleccionar els documents que tenen 4 colors
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({color:{$size:4}})  
{ &quot;_id&quot; : ObjectId(&quot;56e16990aa3c92aaed389da7&quot;), &quot;color&quot; : [ &quot;taronja&quot;, &quot;gris&quot;, &quot;lila&quot;, &quot;verd&quot; ] }
</code></pre></div></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>L'operador <strong>$size</strong> només admet un valor numèric, i no es poden concatenar
expressions amb altres operadors, com per exemple intentar la condició que la
grandària de l'array siga menor o igual a un determinat valor. Es pot tornar a
esquivar la qüestió amb l'operador <strong>$where</strong> , i posar la condició en
JavaScript. Així la consulta dels documents que tenen 3 o menys colors la
podríem traure d'aquesta manera:</p>
</div>
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({$where:&quot;this.color.length&lt;=3&quot;})  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot;, &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot;, &quot;roig&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16972aa3c92aaed389da6&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot; ]}
</code></pre></div>
<p><strong class="azul">$slice</strong></p>
<p>L'operador <strong>$slice</strong> no és un operador que es puga posar en les condicions
(criteris), sinó que servirà per a extraure determinats elements de l'array,
pel número d'ordre d'aquestos elements en l'array. Només el podrem posar, per
tant, en el segon paràmetre del <strong>find()</strong>.</p>
<p>La sintaxi és:
<div class="highlight"><pre><span></span><code>clau : {$slice : x }
</code></pre></div>
Els valors que pot agafar <strong>x</strong> són:</p>
<ul>
<li>Números positius: serà el número d'elements del principi (per l'esquerra)</li>
<li>Números negatius: serà el número d'elements del final (per la dreta)</li>
<li>Un array de 2 elements (<strong>[x,y]</strong>): traurà a partir de la posició <strong>x</strong> (0 és el primer), tants elements com indique <strong>y</strong></li>
</ul>
<p>Per exemple, anem a traure els dos primers colors de cada document:
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({} , {color:{$slice:2} })  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;roig&quot;, &quot;blau&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16972aa3c92aaed389da6&quot;), &quot;color&quot; : [ &quot;negre&quot;, &quot;blanc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16990aa3c92aaed389da7&quot;), &quot;color&quot; : [ &quot;taronja&quot;, &quot;gris&quot; ] }
</code></pre></div>
O traure l'últim color:
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({} , {color:{$slice:-1 }})  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;roig&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16972aa3c92aaed389da6&quot;), &quot;color&quot; : [ &quot;blanc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16990aa3c92aaed389da7&quot;), &quot;color&quot; : [ &quot;verd&quot; ] }
</code></pre></div>
O traure el tercer element, tinguen els que tinguen. Recordeu que el segon
element, és el de la posició 2, i en volem traure 1.
<div class="highlight"><pre><span></span><code>&gt; db.colorins.find({} , {color:{$slice:[2,1] }})  
{ &quot;_id&quot; : ObjectId(&quot;56e1438ff6663c8169030e09&quot;), &quot;color&quot; : [ &quot;groc&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e14398f6663c8169030e0a&quot;), &quot;color&quot; : [ &quot;roig&quot; ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16972aa3c92aaed389da6&quot;), &quot;color&quot; : [ ] }  
{ &quot;_id&quot; : ObjectId(&quot;56e16990aa3c92aaed389da7&quot;), &quot;color&quot; : [ &quot;lila&quot; ] }
</code></pre></div>
<strong>Recerques en objectes</strong></p>
<p>Per a fer recerques en camps que a la seua vegada són objectes (o documents
dins de documents, en la terminologia de Mongo), només hem de posar la ruta de
les claus separant per mig de punts, i cuidar de posar-la entre cometes.</p>
<p>Així, per exemple, anem a fer una consulta sobre la col·lecció d'alumnes, que
eren uns documents en els quals hi havia algun camp de tipus objecte.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find().pretty()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Cantera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
    &quot;carrer&quot; : &quot;Major&quot;,  
    &quot;numero&quot; : 7,  
    &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        9.5,  
        9  
    ]  
}  
{  
&quot;_id&quot; : ObjectId(&quot;56dfdbd136d8b095cb6bd57a&quot;),  
&quot;nom&quot; : &quot;Berta&quot;,  
&quot;cognoms&quot; : &quot;Bernat Cantero&quot;  
}
</code></pre></div>
Es podrien traure els documents (els alumnes) que viuen en el codi postal
12502. Ens ha d'eixir l'únic alumne del qual tenim l'adreça, que justament té
aquest codi postal. Recordeu que en la clau (realment clau.subclau), ha d'anar
entre cometes. Hem posat al final <strong>pretty()</strong> per a una millor lectura, però
evidentment no és necessari.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find({&quot;adreça.cp&quot;: &quot;12502&quot;}).pretty()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Cantera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        9.5,  
        9  
    ]  
}
</code></pre></div>
I funcionaria igual amb qualsevol número de subnivells, és a dir, documents
que tenen objectes, els quals tenen objectes, ... I també amb altres tipus
d'operadors, o expressions regulars, ...</p>
<p>Per exemple, tots els alumnes de Castelló (el codi postal ha de començar per
12 i contenir 3 xifres més, és a dir, caràcter del 0 al 9, i 3 vegades.
<div class="highlight"><pre><span></span><code>&gt; db.alumnes.find({&quot;adreça.cp&quot;: /^12[0-9]{3}/}).pretty()  
{  
    &quot;_id&quot; : ObjectId(&quot;56debe3017bf4ed437dc77c8&quot;),  
    &quot;nom&quot; : &quot;Abel&quot;,  
    &quot;cognoms&quot; : &quot;Bernat Cantera&quot;,  
    &quot;edat&quot; : 22,  
    &quot;adreça&quot; : {  
        &quot;carrer&quot; : &quot;Major&quot;,  
        &quot;numero&quot; : 7,  
        &quot;cp&quot; : &quot;12502&quot;  
    },  
    &quot;nota&quot; : [  
        9.5,  
        9  
    ]  
}
</code></pre></div>
 <strong class="azul">Limit, Skip i Sort</strong></p>
<p>Una vegada tenim feta una consulta, podem limitar el nombre de documents que
ens ha de tornar, o ordenar-los.</p>
<p>Per a això hi ha uns mètodes que apliqiuem al final del <strong>find()</strong> , és a dir,
a continuació del <strong>find()</strong> , separats per un punt.</p>
<p>Ho aplicarem als llibres, que és on tenim més documents. I no mostrem tots els
camps, per a una millor lectura:
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({} , {titulo:1 , precio:1 , editorial:1})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot;, &quot;precio&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot;, &quot;precio&quot; : 9.45 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot;, &quot;precio&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 17.23 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9 }
</code></pre></div>
 <strong class="azul">limit(<em>n</em>)</strong></p>
<p>Limita el número de documents tornats a <em><strong>n</strong></em> documents.
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).limit(3)  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot;, &quot;precio&quot; : 9.5 }
</code></pre></div>
Si el número de documents que fa la consulta és menor que <em><strong>n</strong></em> , doncs se'n
tornaran menys. Així per exemple, de l'editorial Planeta només hi ha dos
llibres. Encara que posem limit(3), se'n tornaran 2.
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({editorial:&quot;Planeta&quot;} , {titulo:1 , precio:1 , &gt; editorial:1}).limit(3)  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot;: &quot;Planeta&quot;, &quot;precio&quot; : 17.23 }
</code></pre></div>
 <strong class="azul">skip(<em>n</em>)</strong></p>
<p>Se saltaran els primers <em><strong>n</strong></em> documents. Si hi haguera menys documents dels
que se salten, doncs no se'n mostraria cap.
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).skip(2)  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot;, &quot;precio&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot;, &quot;precio&quot; : 9.45 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot;, &quot;precio&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 17.23 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9 }
</code></pre></div>
 <strong class="azul">sort()</strong></p>
<p>Serveix per a ordenar. Com a paràmetre se li passarà un objecte JSON amb les
claus per a ordenar, i els valors seran:</p>
<ul>
<li>1: ordre ascendent</li>
<li>-1: ordre descendent</li>
</ul>
<p>Si posem més d'una clau, s'ordenarà pel primer, en cas d'empat pel segon, ...</p>
<p>En aquest exemple ordenem pel preu
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({precio:1})  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot;, &quot;precio&quot; : 9.45 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot;, &quot;precio&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot;, &quot;precio&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 17.23 }  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }
</code></pre></div>
I com déiem, es pot posar més d'un camp d'ordenació. Per exemple, per
editorial en ordre ascendent, i per preu en ordre descendent
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({editorial:1 ,
&gt; precio:-1})  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot;, &quot;precio&quot; : 9.45 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot;, &quot;precio&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot;, &quot;precio&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 17.23 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }
</code></pre></div>
Observeu com el primer és el que no té editorial (equivalent a null). I com
que hi ha dos de l'editorial Planeta, apareix primer el més car, i després el
més barat.</p>
<p>I evidentment, es poden combinar els mètodes limit, skip i sort.</p>
<p>En aquest exemple traurem el segon i tercer llibre més car. Per a això ordenem
per preu de forma descendent, saltem un i limitem a 2. No importa l'ordre com
col·locar skip, limit i sort.
<div class="highlight"><pre><span></span><code>&gt; db.libro.find({} , {titulo:1 , precio:1 , &gt; editorial:1}).sort({precio:-1}).skip(1).limit(2)  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;precio&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot;, &quot;precio&quot; : 17.23 }
</code></pre></div></p>
<h3 id="343-agregacio">3.4.3 - Agregació</h3>
<p>L'agregació ens permetrà fer consultes molt avançades. És un procés un poc
complicat però molt potent. Ens donarà una potència quasi com la del SQL quan
comencem a utilitzar el GROUP BY i HAVING.</p>
<p>La tècnica que s'utilitza és la del <em><strong>pipeline</strong></em> , és a dir fer una sèrie de
comandos, cadascun agafa les dades que proporciona l'anterior i a la seua
vegada proporciona les dades al següent comando. D'aquesta manera es tractarà
un conjunt de documents i es faran "operacions" sobre ells seqüencialment en
blocs: filtrat, projecció, agrupacions, ordenació, limitació i <em>skipping</em>
(saltar alguns).</p>
<p>La sintaxi serà:
<div class="highlight"><pre><span></span><code>db.col_leccio1.aggregate ( _operador $matc_ h ,  _operador $projec_ t ,
_operador $group_ , _operador $sort_ , _operador $limit_ , _operador $skip_ )
</code></pre></div>
L'ordre dels operadors pot canviar, però hem de tenir en compte que els
comandos s'executen en el ordre en què els posem (d'esquerra a dreta). Així,
per exemple, pot ser molt convenient posar el primer operador el $match, que
és el de seleccionar documents, així les altres operacions es faran sobre
menys documents i aniran més ràpides.</p>
<p>Cada paràmetre del aggregate, és a dir, cada operador tindrà format JSON, i
per tant sempre serà de l'estil:
<div class="highlight"><pre><span></span><code>{ $operador : { clau:valor , ... } }
</code></pre></div></p>
<h4 class="azul" id="match">$match</h4>
<p>Servirà per a filtrar els documents. Aleshores, l'agregació només afectarà als
documents seleccionats. Es poden utilitzar tots els operadors que hem anat
estudiant.</p>
<p>El següent exemple selecciona els documents de l'editorial Planeta. Ho fa per
mig de <strong>aggregate</strong> , però com no fem res més, senzillament selecciona els
documents.
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$match:{editorial:&quot;Planeta&quot;}})
</code></pre></div>
En el següent exemple, a més de seleccionar els de l'editorial Planeta després
apliquem una projecció sobre els camps títol i editorial, per a poder
visualitzar millor el resultat.
<div class="highlight"><pre><span></span><code>&gt;
&gt; db.libro.aggregate({$match:{editorial:&quot;Planeta&quot;}},{$project:{titulo:1,editorial:1}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot;}  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot;: &quot;Planeta&quot; }
</code></pre></div></p>
<h4 class="azul" id="project">$project</h4>
<p>Ens permet projectar sobre determinats camps del document, però és molt més
complet que en la projecció "normal" que havíem fet fins ara, ja que permet
també renomenar camps, fer càlculs, etc.</p>
<p><strong>Projeccció</strong></p>
<p>La manera més senzilla, evidentment és projectar sobre alguns camps dels
existents, i el funcionament és idèntic al de l'altra vegada (valors 1 per a
que apareguen, 0 per a que no apareguen; per defecte<strong>_id</strong> sempre apareix):
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$project:{titulo:1,editorial:1}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot; }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;editorial&quot; : &quot;Plaza &amp; Janes&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;editorial&quot; : &quot;Gigamesh&quot; }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;editorial&quot; : &quot;Debolsillo&quot; }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;editorial&quot; : &quot;Embolsillo&quot; }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot; }
</code></pre></div>
 <strong>Renomenar</strong></p>
<p><strong>$project</strong> també ens permet renomenar camps existents (després veurem que també
càlculs). La manera serà posar d'aquest manera:</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="w"> </span><span class="err">$projec</span><span class="kc">t</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;nom_nou&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;$camp_vell&quot;</span><span class="w"> </span><span class="p">}}</span>
</code></pre></div>
<p>El secret està en el dòlar que va davant del camp vell, ja que d'aquesta
manera ens referim al valor d'aquest camp. Així per exemple renomenem el camp
<strong>enstock</strong> a <strong>disponible</strong> , a banda de traure el títol:</p>
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$project:{titulo:1 , disponible:&quot;$enstock&quot;}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;disponible&quot; : true }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;disponible&quot; : true }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot; disponible&quot; : true }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;disponible&quot; : false }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;disponible&quot; : true }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;disponible&quot; : false }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;disponible&quot; : true }
</code></pre></div>
<p><strong>Camps calculats</strong></p>
<p>Amb aquest nom genèric ens referirem a tots els càlculs, expressions i més
coses que podrem posar per a trasnsformar el que ja tenim. Com veiem, açò és
molt més potent que la projecció normal.</p>
<ul>
<li><strong>Expressions matemàtiques</strong> : Podrem aplicar fórmules per a sumar (<strong>$add</strong>), restar (<strong>$subtract</strong>), multiplicar (<strong>$multiply</strong>), dividir (<strong>$divide</strong>) i més coses (potència, arrel quadrada, valor absolut, mòdul, ...). Cada operació té el seu operador que serà una paraula precedida pel dòlar, i amb la sintaxi de JSON, on posarem els operands en un array. </li>
</ul>
<p>Per exemple, traurem títol del llibre, preu i preu en pessetes (multiplicant
per 166.386)
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$project:{titulo:1 , precio:1 ,
&gt; preu_pessetes:{$multiply:[&quot;$precio&quot; , 166.386]}}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;precio&quot; : 21.75, &quot;preu_pessetes&quot; : 3618.8955 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;titulo&quot; : &quot;El juego de Ripper&quot;, &quot;precio&quot; : 21.75, &quot;preu_pessetes&quot; : 3618.8955 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;titulo&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1&quot;, &quot;precio&quot; : 9.5, &quot;preu_pessetes&quot; : 1580.667 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;titulo&quot; : &quot;La ladrona de libros&quot;, &quot;precio&quot; : 9.45, &quot;preu_pessetes&quot; : 1572.3476999999998 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;titulo&quot; : &quot;La princesa de hielo&quot;, &quot;precio&quot; : 11, &quot;preu_pessetes&quot; : 1830.2459999999999 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;precio&quot; : 17.23, &quot;preu_pessetes&quot; : 2866.83078 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;titulo&quot; : &quot;Las reglas del juego&quot;, &quot;precio&quot; : 15.9, &quot;preu_pessetes&quot; : 2645.5374 }
</code></pre></div></p>
<ul>
<li><strong>Expressions de dates</strong> : Ja veurem i ja podem anar intuint que moltes agregacions estaran basades en el temps, per a poder fer consultes de documents de la setmana passada, o el mes passat, ... Per a poder fer aquestes agregacions, hi ha un conjunt d'expressions que permeten extraure fàcilment d'una data el seu dia, mes, any, ... en forma de número</li>
</ul>
<p>Són les expressions: <strong>$year, $month, $week, $dayOfMonth, $DayOfWeek,
$dayOfYear, $hour, $minute</strong> i <strong>$second</strong>.</p>
<p>En el següent exemple traurem tots els documents, projectant per la data, any
i mes:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$project : {fecha:1 , año:{$year:&quot;$fecha&quot;} , &gt; mes:{$month:&quot;$fecha&quot;}}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;fecha&quot; : ISODate(&quot;2013-08-29T00:00:00Z&quot;), &quot;año&quot; : 2013, &quot;mes&quot; : 8 }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;fecha&quot; : ISODate(&quot;2014-03-01T00:00:00Z&quot;), &quot;año&quot; : 2014, &quot;mes&quot; : 3 }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;fecha&quot; : ISODate(&quot;2011-11-24T00:00:00Z&quot;), &quot;año&quot; : 2011, &quot;mes&quot; : 11 }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;fecha&quot; : ISODate(&quot;2009-01-09T00:00:00Z&quot;), &quot;año&quot; : 2009, &quot;mes&quot; : 1 }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;fecha&quot; : ISODate(&quot;2012-10-30T00:00:00Z&quot;), &quot;año&quot; : 2012, &quot;mes&quot; : 10 }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;fecha&quot; : ISODate(&quot;2013-06-04T00:00:00Z&quot;), &quot;año&quot; : 2013, &quot;mes&quot; : 6 }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;fecha&quot; : ISODate(&quot;2014-02-06T00:00:00Z&quot;), &quot;año&quot; : 2014, &quot;mes&quot; : 2 }
</code></pre></div></p>
<ul>
<li><strong>Expressions de strings</strong> : Ens permeten manipular els strings per a extraure subcadenes, concatenar, passar a majúscules o minúscules. Aquestes són algunes de les funcions:</li>
</ul>
<blockquote>
<ul>
<li><strong>$substr : [exp , inici , llargària]</strong> : extrau una subcadena del string del primer paràmetre, des de la posició que indica el segon paràmetre (o primer caràcter) i tants caràcters com el tercer paràmetre</li>
<li><strong>$concat : [ exp1 , exp2 , ...]</strong> : concatena les expressions que hi ha en l'array</li>
<li><strong>$toLower : exp</strong> i <strong>$toUpper : exp</strong> : converteixen l'expressió a majúscules i minúscules respectivament</li>
</ul>
</blockquote>
<p>Per exemple, anem a traure el títol dels llibres amb l'autor entre parèntesis:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$project: { &quot;Llibre:&quot; : {$concat : [&quot;$titulo&quot; , &quot; (&quot; , &gt; &quot;$autor&quot; , &quot;)&quot;]}}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;Llibre:&quot; : &quot;Circo Máximo (Santiago Posteguillo)&quot; }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;Llibre:&quot; : &quot;El juego de Ripper (Isabel Allende)&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;Llibre:&quot; : &quot;Juego de tronos: Canción de hielo y fuego 1 (George R.R. Martin)&quot; }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;Llibre:&quot; : &quot;La ladrona de libros (Markus Zusak)&quot; }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;Llibre:&quot; : &quot;La princesa de hielo (Camilla Lackberg)&quot; }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;Llibre:&quot; : &quot;Las carreras de Escorpio (Maggie Stiefvater)&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;Llibre:&quot; : &quot;Las reglas del juego (Anna Casanovas)&quot;}
</code></pre></div>
I ara el mateix, però amb el títol en majúscules:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$project: { &quot;Llibre:&quot; : {$concat :
&gt; [{$toUpper:&quot;$titulo&quot;}, &quot; (&quot; , &quot;$autor&quot; , &quot;)&quot;]}}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;Llibre:&quot; : &quot;CIRCO MáXIMO (Santiago Posteguillo)&quot; }  
{ &quot;_id&quot; : &quot;9788401342158&quot;, &quot;Llibre:&quot; : &quot;EL JUEGO DE RIPPER (Isabel Allende)&quot; }  
{ &quot;_id&quot; : &quot;9788496208919&quot;, &quot;Llibre:&quot; : &quot;JUEGO DE TRONOS: CANCIóN DE HIELO Y FUEGO 1 (George R.R. Martin)&quot; }  
{ &quot;_id&quot; : &quot;9788499088075&quot;, &quot;Llibre:&quot; : &quot;LA LADRONA DE LIBROS (Markus Zusak)&quot; }  
{ &quot;_id&quot; : &quot;9788415140054&quot;, &quot;Llibre:&quot; : &quot;LA PRINCESA DE HIELO (Camilla Lackberg)&quot; }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;Llibre:&quot; : &quot;LAS CARRERAS DE ESCORPIO (Maggie Stiefvater)&quot; }  
{ &quot;_id&quot; : &quot;9788468738895&quot;, &quot;Llibre:&quot; : &quot;LAS REGLAS DEL JUEGO (Anna Casanovas)&quot; }
</code></pre></div></p>
<h4 class="azul" id="group">$group</h4>
<p>Realitza grups sobre els documents seleccionats prèviament, per a valors
iguals del camp o expressions que determinem. Posteriorment, amb els grups,
podrem realitzar operacions, com sumar o traure la mitjana d'alguna quantitat
dels documents del grup, o el màxim o mínim, ...</p>
<p>Per a poder agrupar, haurem de definir com a <strong>_id</strong> del grup el camp o camps
pels valors dels quals volem agrupar. Per exemple, si volem agrupar els
llibres per l'editorial, haurem de definir el <strong>_id</strong> del grup el camp
editorial</p>
<p><div class="highlight"><pre><span></span><code>$group : { &quot;_id&quot; : _camp o camps_ }
</code></pre></div>
Si agrupem per un únic camp, senzillament el posem amb un dòlar davant i entre
cometes. Si és més d'un camp, els posem com un objecte. Per exemple, agrupem
per editorial:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : &quot;$editorial&quot; } } )  
{ &quot;_id&quot; : &quot;Debolsillo&quot; }  
{ &quot;_id&quot; : null }  
{ &quot;_id&quot; : &quot;Gigamesh&quot; }  
{ &quot;_id&quot; : &quot;Embolsillo&quot; }  
{ &quot;_id&quot; : &quot;Plaza &amp; Janes&quot; }  
{ &quot;_id&quot; : &quot;Planeta&quot; }
</code></pre></div>
Podem observar com hi ha algun llibre que no té editorial.</p>
<p>Ara agrupem per any de publicació (l'extraurem del camp <strong>fecha</strong>):
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : { &quot;any&quot; : { $year : &quot;$fecha&quot; } } }} )  
{ &quot;_id&quot; : { &quot;any&quot; : 2012 } }  
{ &quot;_id&quot; : { &quot;any&quot; : 2009 } }  
{ &quot;_id&quot; : { &quot;any&quot; : 2011 } }  
{ &quot;_id&quot; : { &quot;any&quot; : 2014 } }  
{ &quot;_id&quot; : { &quot;any&quot; : 2013 } }
</code></pre></div>
I ara agrupem per editorial i any de publicació (els dos llibres de Planeta
són del 2013)
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : { &quot;Editorial&quot; : &quot;$editorial&quot; ,
&gt; &quot;any&quot; : { $year : &quot;$fecha&quot; } } } } )  
{ &quot;_id&quot; : { &quot;Editorial&quot; : &quot;Embolsillo&quot;, &quot;any&quot; : 2012 } }  
{ &quot;_id&quot; : { &quot;any&quot; : 2014 } }  
{ &quot;_id&quot; : { &quot;Editorial&quot; : &quot;Debolsillo&quot;, &quot;any&quot; : 2009 } }  
{ &quot;_id&quot; : { &quot;Editorial&quot; : &quot;Gigamesh&quot;, &quot;any&quot; : 2011 } }  
{ &quot;_id&quot; : { &quot;Editorial&quot; : &quot;Plaza &amp; Janes&quot;, &quot;any&quot; : 2014 } }  
{ &quot;_id&quot; : { &quot;Editorial&quot; : &quot;Planeta&quot;, &quot;any&quot; : 2013 } }
</code></pre></div>
 <strong>Operadors d'agrupació</strong></p>
<p>Ens permetran fer alguna operació sobre els documents del grup. Es posen com a
segon paràmetre del grup (després de la definició del <strong>_id</strong>).</p>
<ul>
<li><strong>$sum : valor</strong> : sumarà el valor de tots els documents del grup. El valor pot ser un camp numèric, o alguna altra cosa més complicada.</li>
<li><strong>$avg : valor</strong> : calcularà la mitjana dels valors per als documents del grup</li>
<li><strong>$max : valor</strong> : màxim</li>
<li><strong>$min : valor</strong> : mínim</li>
<li><strong>$first : exp</strong> : agafarà el primer valor de l'expressió del grup, ignorant les altres del grup</li>
<li><strong>$last : exp</strong> : agafarà l'últim</li>
</ul>
<p>La documentació diu que també existeix l'operador <strong>$count</strong> , però a partir
d'una determinada versió. Es pot substituir la seua utilització per l'operador
<strong>$sum</strong> , sumant la quantitat 1.</p>
<p>Per exemple, la suma dels preus dels llibres de cada editorial:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : &quot;$editorial&quot; , &quot;suma_preus&quot; : {
&gt; $sum : &quot;$precio&quot;} } } )  
{ &quot;_id&quot; : &quot;Debolsillo&quot;, &quot;suma_preus&quot; : 9.45 }  
{ &quot;_id&quot; : null, &quot;suma_preus&quot; : 15.9 }  
{ &quot;_id&quot; : &quot;Gigamesh&quot;, &quot;suma_preus&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;Embolsillo&quot;, &quot;suma_preus&quot; : 11 }  
{ &quot;_id&quot; : &quot;Plaza &amp; Janes&quot;, &quot;suma_preus&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;Planeta&quot;, &quot;suma_preus&quot; : 38.980000000000004 }
</code></pre></div>
O la mitjana dels preus de cada any:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : { &quot;any&quot; : { $year : &quot;$fecha&quot; } } ,
&gt; &quot;mitjana preus&quot; : { $avg : &quot;$precio&quot; } } } )  
{ &quot;_id&quot; : { &quot;any&quot; : 2012 }, &quot;mitjana preus&quot; : 11 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2009 }, &quot;mitjana preus&quot; : 9.45 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2011 }, &quot;mitjana preus&quot; : 9.5 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2014 }, &quot;mitjana preus&quot; : 18.825 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2013 }, &quot;mitjana preus&quot; : 19.490000000000002 }
</code></pre></div>
I ara intentem comptar la quantitat de llibres de cada editorial:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : &quot;$editorial&quot; , &quot;quants&quot; : { $sum :
&gt; 1} } } )  
{ &quot;_id&quot; : &quot;Debolsillo&quot;, &quot;quants&quot; : 1 }  
{ &quot;_id&quot; : null, &quot;quants&quot; : 1 }  
{ &quot;_id&quot; : &quot;Gigamesh&quot;, &quot;quants&quot; : 1 }  
{ &quot;_id&quot; : &quot;Embolsillo&quot;, &quot;quants&quot; : 1 }  
{ &quot;_id&quot; : &quot;Plaza &amp; Janes&quot;, &quot;quants&quot; : 1 }  
{ &quot;_id&quot; : &quot;Planeta&quot;, &quot;quants&quot; : 2 }
</code></pre></div></p>
<h4 class="azul" id="sort">$sort</h4>
<p>Serveix per a ordenar i segueix la mateixa sintàxi que en les consultes normal
(1: ordre ascendent; -1: ordre descendent). Podrem ordenar pels camps normals
o per camps clalculats.</p>
<p>Per exemple ordenem per la suma de preus de cada editorial:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : &quot;$editorial&quot; , &quot;suma_preus&quot; : {
&gt; $sum : &quot;$precio&quot;} } } , { $sort : { suma_preus : 1 } })  
{ &quot;_id&quot; : &quot;Debolsillo&quot;, &quot;suma_preus&quot; : 9.45 }  
{ &quot;_id&quot; : &quot;Gigamesh&quot;, &quot;suma_preus&quot; : 9.5 }  
{ &quot;_id&quot; : &quot;Embolsillo&quot;, &quot;suma_preus&quot; : 11 }  
{ &quot;_id&quot; : null, &quot;suma_preus&quot; : 15.9 }  
{ &quot;_id&quot; : &quot;Plaza &amp; Janes&quot;, &quot;suma_preus&quot; : 21.75 }  
{ &quot;_id&quot; : &quot;Planeta&quot;, &quot;suma_preus&quot; : 38.980000000000004 }
</code></pre></div>
I ara ordenem de forma descendent per la mitjana de preus de cada any:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate( { $group : { &quot;_id&quot; : {&quot;any&quot;:{$year:&quot;$fecha&quot;}} , &quot;mitjana
&gt; preus&quot;:{$avg:&quot;$precio&quot;} } } , {$sort:{&quot;mitjana preus&quot;:-1}})  
{ &quot;_id&quot; : { &quot;any&quot; : 2013 }, &quot;mitjana preus&quot; : 19.490000000000002 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2014 }, &quot;mitjana preus&quot; : 18.825 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2012 }, &quot;mitjana preus&quot; : 11 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2011 }, &quot;mitjana preus&quot; : 9.5 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2009 }, &quot;mitjana preus&quot; : 9.45 }
</code></pre></div></p>
<h4 class="azul" id="limit">$limit</h4>
<p>Limita el resultat del aggregate al número indicat.</p>
<p>Per exemple, els tres anys de mitjana de preus més cara. És com l'últim
exemple, afegint el límit:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$group:{&quot;_id&quot;:{&quot;any&quot;:{$year:&quot;$fecha&quot;}},&quot;mitjana
&gt; preus&quot;:{$avg:&quot;$precio&quot;}}} , {$sort:{&quot;mitjana preus&quot;:-1}} , {$limit:3})  
{ &quot;_id&quot; : { &quot;any&quot; : 2013 }, &quot;mitjana preus&quot; : 19.490000000000002 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2014 }, &quot;mitjana preus&quot; : 18.825 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2012 }, &quot;mitjana preus&quot; : 11 }
</code></pre></div></p>
<h4 class="azul" id="skip">$skip</h4>
<p>Salta el número indicat</p>
<p>En l'exemple anterior, ara saltem els 3 primers:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$group:{&quot;_id&quot;:{&quot;any&quot;:{$year:&quot;$fecha&quot;}},&quot;mitjana
&gt; preus&quot;:{$avg:&quot;$precio&quot;}}} , {$sort:{&quot;mitjana preus&quot;:-1}} , {$skip:3})  
{ &quot;_id&quot; : { &quot;any&quot; : 2011 }, &quot;mitjana preus&quot; : 9.5 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2009 }, &quot;mitjana preus&quot; : 9.45 }
</code></pre></div></p>
<h2 id="35-connexio-des-de-kotlin-i-exemples">3.5 - Connexió des de Kotlin i Exemples</h2>
<p>Per a poder connectar des de Java o Kotlin ens sera suficient amb un driver,
que haurem d'incorporar al projecte. En la següent pàgina podem trobar-lo, en
diferents versions:</p>
<p><a href="https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/">https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/</a></p>
<p>En el moment de fer aquestos apunts, l'últim driver disponible és el següent:</p>
<p><a href="https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/3.9.1/mongo-
java-driver-3.9.1.jar">https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/3.9.1/mongo-
java-driver-3.9.1.jar</a></p>
<p>Per a separar les proves i exercicis de la part de <strong>Redis</strong> , creem un nou
paquet anomenat <strong>ExemplesMongo</strong>.</p>
<p><strong><u>Connexió</strong></u></p>
<p>La connexió és tan senzilla com el següent:</p>
<div class="highlight"><pre><span></span><code>       val con = MongoClient(&quot;localhost&quot;, 27017)
       val bd = con.getDatabase(&quot;test&quot;)
</code></pre></div>
<p>És a dir, obtenim un objecte <strong>MongoClient</strong> passant-li al constructor
l'adreça del servidor i el port de connexió (que per defecte és 27017).</p>
<p>Posteriorment hem de connectar amb la Base de Dades. Ja havíem comentat en la
instal·lació de Mongo que nosaltres només utilitzaríem una Base de Dades ja
creada anomenada <strong>test</strong>. Obtenim un objecte <strong>MongoDatabase</strong> que farà
referència a la Base de Dades, i és l'objecte que utilitzarem a partir d'ara.
Evidentment ho podríem haver fet en una única línia.</p>
<p>Si el servidor no el tenim en la mateixa màquina, només haurem de substituir
<strong>localhost</strong> per l'adreça on estiga el servidor.</p>
<p>Per a tancar la connexió:
<div class="highlight"><pre><span></span><code>       con.close()
</code></pre></div>
 <strong><u>Inserció de documents</u></strong></p>
<p>Des de Kotlin podrem inserir documents amb la mateixa facilitat que des de la
consola. Només haurem de crear un objecte <strong>Document</strong> de <strong>BSON</strong> (recordeu
que és el format intern de Mongo, absolutament similar a <strong>JSON</strong>). La manera
d'anar posant parelles calu valor en aquest document és per mig del mètode
<strong>put</strong>. Fem un exemple molt senzill on senzillament guardem un document amb
una parella clau-valor d'un missatge. Guardeu-lo amb el nom <strong>Prova1.kt</strong> :</p>
<pre><code>import com.mongodb.MongoClient
import org.bson.Document

fun main(args: Array&lt;String&gt;) {
    val con = MongoClient("localhost", 27017)
    val bd = con.getDatabase("test")
    val doc = Document()
    doc.put("msg4", "Missatge inserit des de Kotlin")
    bd.getCollection("exemple").insertOne(doc)
    con.close()
}
</code></pre>
<p>Segurament traurà avisos en la consola, però només són avisos. Podem comprovar
en la terminal com s'ha inserit el document:</p>
<p><img alt="" src="../T8_3_4_1.png" /></p>
<p><strong><u>Consultes</u></strong></p>
<p>Tenim el mètode <strong>find()</strong> per a fer consultes, i li podem posar un document
com a paràmetre per a seleccionar determinats documents o traure determinada
informació. Guardeu el següent exemple amb el nom <strong>Prova2.kt</strong> :</p>
<pre><code>import com.mongodb.MongoClient

fun main(){
    val con = MongoClient("localhost" , 27017)
    val bd = con.getDatabase("test")
   val llibres = bd.getCollection("libro").find()

    for (llibre in llibres)
        println(llibre.get("titulo"))

   con.close();
}
</code></pre>
<p>I com comentàvem podem posar com a paràmetres en el find() per a seleccionar
determinats documents, ordenar, etc. Només hem de cuidar que ho hem de posar
en <strong>JSON</strong>(millor dit <strong>BSON</strong>), i per tant haurem de crear un document per a
això. Copieu el següent exemple amb el nom <strong>Prova3.kt</strong> :</p>
<pre><code>import com.mongodb.MongoClient
import org.bson.Document

fun main(){
    val con = MongoClient("localhost", 27017)
    val bd = con.getDatabase("test")

    val ordenar = Document()
    ordenar.put("precio", -1)

    val llibres = bd.getCollection("libro").find().sort(ordenar)

    for (llibre in llibres) System.out.println(
        "Títol: " + llibre.get("titulo").toString() + ". Preu: " + llibre.get("precio")
    )

    con.close()
}
</code></pre>
<p>El resultat serà aquest:</p>
<p><img alt="" src="../T8_3_4_2.png" /></p>
<p>Hem pogut observar en l'execució dels exemples anteriors que ens trau una gran
quantitat d'avisos. No són errors, sinó senzillament informació de com van les
connexions, que mongo torna, i apareixen en l'eixida estàndar.</p>
<p>Si no volem que apareguen podem posar al principi del programa una sentència
per a dir que únicament apareguen els errors, i no els avisos. Els errors
estarien en la categoria de <strong>SEVERE</strong></p>
<div class="highlight"><pre><span></span><code>        LogManager.getLogManager().getLogger(&quot;&quot;).setLevel(Level.SEVERE)
</code></pre></div>
<p>Hem d'importar les classes de <strong>java.util</strong>. Quedaria el mateix exemple
<strong>Prova3.kt</strong> d'aquesta manera:</p>
<pre><code>import com.mongodb.MongoClient
import org.bson.Document
import java.util.logging.Level
import java.util.logging.LogManager

fun main(){
    LogManager.getLogManager().getLogger("").setLevel(Level.SEVERE)
    val con = MongoClient("localhost", 27017)
    val bd = con.getDatabase("test")

    val ordenar = Document()
    ordenar.put("precio", -1)

    val llibres = bd.getCollection("libro").find().sort(ordenar)

    for (llibre in llibres) System.out.println(
        "Títol: " + llibre.get("titulo").toString() + ". Preu: " + llibre.get("precio")
    )

    con.close()
}
</code></pre>
<p>I el resultat ara serà:</p>
<p><img alt="" src="../T8_3_4_3.png" /></p>
<p><strong><u>Agregació</u></strong></p>
<p>Per a poder utilitzar la funció d'agregació, que té tanta potència, ens ho hem
de muntar d'aquesta manera:</p>
<ul>
<li>Sobre la col·lecció utilitzar el mètode <strong>aggregate()</strong></li>
<li>Com a paràmetres, afegirem un <strong>MutableList</strong>. Cada element d'ell serà una opció d'aggregate</li>
<li>Per a cada opció ($match, $project...), utilitzarem el mètode d'<strong>Aggregates</strong>(una classe del driver de Mongo) amb el mateix nom: <ul>
<li>Per a <strong>$match</strong> : <strong>Aggregates.match()</strong></li>
<li>Per a <strong>$project: Aggregates.project()</strong></li>
<li>...</li>
</ul>
</li>
<li>Dins de cadascun d'aquestos mètodes posarem un document BSon amb les especificacions que necessitem</li>
</ul>
<p>En aquest exemple farem la selecció (match) dels llibres de l'editorial
Planeta, agafant (project) únicament el títol i l'editorial.</p>
<p>La sentència en la consola la faríem així:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate({$match:{editorial:&quot;Planeta&quot;}},{$project:{titulo:1,
&gt; editorial:1}})  
{ &quot;_id&quot; : &quot;9788408117117&quot;, &quot;titulo&quot; : &quot;Circo Máximo&quot;, &quot;editorial&quot; : &quot;Planeta&quot; }  
{ &quot;_id&quot; : &quot;9788408113331&quot;, &quot;titulo&quot; : &quot;Las carreras de Escorpio&quot;, &quot;editorial&quot; : &quot;Planeta&quot; }
</code></pre></div>
El programa ens quedaria així. Guardeu-lo en en fitxer Kotlin anomenat
<strong>Prova_Aggregate_1.kt</strong> :</p>
<pre><code>import com.mongodb.MongoClient
import com.mongodb.client.model.Aggregates
import org.bson.Document
import java.util.logging.Level
import java.util.logging.LogManager

fun main(){
    LogManager.getLogManager().getLogger("").setLevel(Level.SEVERE)
    val con = MongoClient("localhost", 27017)
    val bd = con.getDatabase("test")

    val seleccionar = Document()
    seleccionar.put("editorial", "Planeta")

    val projeccio = Document()
    projeccio.put("titulo",1)
    projeccio.put("editorial",1)

    val llibres = bd.getCollection("libro").aggregate(mutableListOf(Aggregates.match(seleccionar),Aggregates.project(projeccio)))

    for (llibre in llibres)
        println("Títol: " + llibre.get("titulo").toString() + ".   Editorial: " + llibre.get("editorial").toString()
    )

    con.close()
}
</code></pre>
<p>Mirem un altre exemple. Traure el llibre més barat de cada any.</p>
<p>La consulta en Mongo que faríem en la consola de Mongo seria:
<div class="highlight"><pre><span></span><code>&gt; db.libro.aggregate(  
{$group : {&quot;_id&quot; : { &quot;any&quot; : { $year : &quot;$fecha&quot; } } , &quot;minim&quot;:{$min: &quot;$precio&quot;}}}, {$sort:{&quot;_id&quot;:1}})  
{ &quot;_id&quot; : { &quot;any&quot; : 2009 }, &quot;minim&quot; : 9.45 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2011 }, &quot;minim&quot; : 9.5 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2012 }, &quot;minim&quot; : 11 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2013 }, &quot;minim&quot; : 17.23 }  
{ &quot;_id&quot; : { &quot;any&quot; : 2014 }, &quot;minim&quot; : 15.9 }
</code></pre></div>
Ara col·locarem aquesta sentència en un programa Kotlin. Guardeu el següent
codi com el fitxer Kotlin <strong>Prova_Aggregate_2.kt</strong> :</p>
<pre><code>import com.mongodb.MongoClient
import com.mongodb.client.model.Aggregates
import org.bson.Document
import java.util.logging.Level
import java.util.logging.LogManager

fun main(){
    LogManager.getLogManager().getLogger("").setLevel(Level.SEVERE)
    val con = MongoClient("localhost", 27017)
    val bd = con.getDatabase("test")

    val grup = Document()
    grup.put("_id", Document("any",Document("\$year","\$fecha")))
    grup.put("minim",Document("\$min","\$precio"))

    val ordenar = Document()
    ordenar.put("_id",1)

    val llibres = bd.getCollection("libro").aggregate(mutableListOf(Aggregates.group(grup),Aggregates.sort(ordenar)))

    for (llibre in llibres){
        val d = llibre.get("_id") as Document
        println("Any: " + (d.get("_id") as Document).getInteger("any")+ ".   Mínim: " + d.getDouble("minim"))
    }

    con.close()
}
</code></pre>
<p>Hem tingut la complicació que el resultat és més complicat, té un document
dins d'una altre document (com es veu en el resultat de la sentència executada
en la consola). Aquest serà el resultat:</p>
<p><img alt="" src="../T8_3_4_1.1.png" /></p>
<h2 id="36-connexio-des-de-kotlin-al-servidor-de-linstitut">3.6 - Connexió des de Kotlin al servidor de l'Institut</h2>
<p>La connexió canvia si la fem al servidor de l'Institut, no per ser una
direcció externa, sinó perquè cal la autenticació. Hem habilitat
l'autenticació per a intentar evitar atacs.</p>
<p>Si no tinguèrem autenticació, la connexió seria com abans:</p>
<pre><code>val con = MongoClient("89.36.214.106")
val bd = con.getDatabase("test")
</code></pre>
<p>Però per tenir l'autenticació activada la connexió haurà de ser diferent:</p>
<pre><code>val con = MongoClient(MongoClientURI("mongodb://ad:Ad_ieselcamina$@89.36.214.106/?authSource=test"))
val bd = con.getDatabase("test")
</code></pre>
<p>on hem especificat l'adreça donant-li un usuari (<strong>ad</strong>), una contrasenya
(<strong>Ad_ieselcamina$</strong>), el servidor (<strong>89.36.214.106</strong>) i fins i tot la Base de
Dades on connectem, que ja va comentar que només teníem la BD <strong>test</strong></p>
<p>Per a tancar la connexió, com sempre:</p>
<pre><code>con.close()
</code></pre>
<p>Mirem un exemple on podem comprovar que l'utilitzem exactament igual que amb
la connexió a localhost, però ara ens està contestant el servidor de
l'Institut. Guardeu-lo amb el nom <strong>ProvaServidor.kt</strong> :</p>
<pre><code>import com.mongodb.MongoClient
import com.mongodb.MongoClientURI
import org.bson.Document
import java.util.logging.Level
import java.util.logging.LogManager

fun main(){
    LogManager.getLogManager().getLogger("").setLevel(Level.SEVERE)

    val con = MongoClient(MongoClientURI("mongodb://ad:Ad_ieselcamina$@89.36.214.106/?authSource=test"))
    val bd = con.getDatabase("test")

    val ordenar = Document()
    ordenar.put("precio", -1)

    val llibres = bd.getCollection("libro").find().sort(ordenar)

    for (llibre in llibres)
        System.out.println(llibre.get("titulo").toString() + " --&gt; " + llibre.get("precio"))

    con.close()
}
</code></pre>
<p>I ací tenim el resultat:</p>
<p><img alt="" src="../T8_3_5_2.png" /></p>
<p>Llicenciat sota la  <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Llicència Creative Commons Reconeixement NoComercial
SenseObraDerivada 4.0</a></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../exercicis_redis/" class="btn btn-neutral float-left" title="Exercicis"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../exercicis_mongo/" class="btn btn-neutral float-right" title="Exercicis">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../exercicis_redis/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../exercicis_mongo/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
