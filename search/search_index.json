{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5 Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Acc\u00e9s a Dades - Bases de Dades NoSQL"},{"location":"1__introducci/","text":"1 - Introducci\u00f3 En el tema anterior vam tenir el primer contacte amb les Bases de Dades NoSQL. En aquella ocasi\u00f3 es tractava de Bases de Dades Orientades a objectes, que ens permetien guardar els objectes de forma c\u00f2moda, i sense desfasament objecte- relacional, ja que el que guard\u00e0vem era directament objectes. Per contra, se'ns complicava la manera de fer consultes, ja que no dispos\u00e0vem d'un llenguatge tan potent com el SQL. El terme NoSQL (Not Only SQL) \u00e9s m\u00e9s extens. S\u00f3n en definitiva Bases de Dades que no estan basades en el Model Relacional, i que en determinades ocasions poden ser m\u00e9s eficients que les Bases de Dades Relacionals precisament per fugir de la rigidesa que proporciona aquest model, amb dades tan ben estructurades. El terme clau \u00e9s \"en determinades ocasions\", \u00e9s a dir, per a guardar un determinat tipus d'informaci\u00f3. Aix\u00ed ens trobarem distints tipus de Bases de Dades NoSQL, depenent del tipus d'informaci\u00f3 que vulguen guardar: Bases de Dades Orientades a Objectes , per a poder guardar objectes, com per exemple DB4O Bases de Dades Orientades a Documents (o simplement Bases de Dades Documentals), per a guardar documents de determinats tipus: XML, JSON, ... Per exemple eXist que guarda documents XML, o MongoDB que guarda la informaci\u00f3 en un format similar a JSON. O Firebase , una Base de Dades que utilitza tamb\u00e9 el format JSON i que en temps real permet sincronitzar amb el n\u00favol les dades locals. Bases de Dades Clau-Valor , per a guardar informaci\u00f3 de forma molt senzilla, guardant \u00fanicament la clau (el nom de la propietat) i el seu valor Bases de Dades Orientades a Grafs , per a guardar estructures com els grafs, on hi ha una s\u00e8rie de nodes i arestes que comunicarien (relacionarien) els nodes Bases de Dades Orientades a Columna , que t\u00e9 una estructura pareguda a les taules del Model Relacional, per\u00f2 orientat a les columnes (o fam\u00edlies de columnes, de manera que un grup de columnes es guarda en el mateix lloc). Un exemple \u00e9s Cassandra Altres tipus com les Bases de Dades Multivalor , les Bases de Dades Tabulars , ... En aquest tema nom\u00e9s veurem les Bases de Dades Clau-Valor, per la seua senzillesa, i una altra Base de Dades orientada a documents, MongoDB , per la seua utilitzaci\u00f3 actual. Com que ja hem vist una Orientada a Objectes. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"1 - Introducci\u00f3"},{"location":"1__introducci/#1-introduccio","text":"En el tema anterior vam tenir el primer contacte amb les Bases de Dades NoSQL. En aquella ocasi\u00f3 es tractava de Bases de Dades Orientades a objectes, que ens permetien guardar els objectes de forma c\u00f2moda, i sense desfasament objecte- relacional, ja que el que guard\u00e0vem era directament objectes. Per contra, se'ns complicava la manera de fer consultes, ja que no dispos\u00e0vem d'un llenguatge tan potent com el SQL. El terme NoSQL (Not Only SQL) \u00e9s m\u00e9s extens. S\u00f3n en definitiva Bases de Dades que no estan basades en el Model Relacional, i que en determinades ocasions poden ser m\u00e9s eficients que les Bases de Dades Relacionals precisament per fugir de la rigidesa que proporciona aquest model, amb dades tan ben estructurades. El terme clau \u00e9s \"en determinades ocasions\", \u00e9s a dir, per a guardar un determinat tipus d'informaci\u00f3. Aix\u00ed ens trobarem distints tipus de Bases de Dades NoSQL, depenent del tipus d'informaci\u00f3 que vulguen guardar: Bases de Dades Orientades a Objectes , per a poder guardar objectes, com per exemple DB4O Bases de Dades Orientades a Documents (o simplement Bases de Dades Documentals), per a guardar documents de determinats tipus: XML, JSON, ... Per exemple eXist que guarda documents XML, o MongoDB que guarda la informaci\u00f3 en un format similar a JSON. O Firebase , una Base de Dades que utilitza tamb\u00e9 el format JSON i que en temps real permet sincronitzar amb el n\u00favol les dades locals. Bases de Dades Clau-Valor , per a guardar informaci\u00f3 de forma molt senzilla, guardant \u00fanicament la clau (el nom de la propietat) i el seu valor Bases de Dades Orientades a Grafs , per a guardar estructures com els grafs, on hi ha una s\u00e8rie de nodes i arestes que comunicarien (relacionarien) els nodes Bases de Dades Orientades a Columna , que t\u00e9 una estructura pareguda a les taules del Model Relacional, per\u00f2 orientat a les columnes (o fam\u00edlies de columnes, de manera que un grup de columnes es guarda en el mateix lloc). Un exemple \u00e9s Cassandra Altres tipus com les Bases de Dades Multivalor , les Bases de Dades Tabulars , ... En aquest tema nom\u00e9s veurem les Bases de Dades Clau-Valor, per la seua senzillesa, i una altra Base de Dades orientada a documents, MongoDB , per la seua utilitzaci\u00f3 actual. Com que ja hem vist una Orientada a Objectes. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"1 - Introducci\u00f3"},{"location":"2__bases_de_dades_clauvalor/","text":"2 - Bases de Dades Clau-Valor Segurament de tots els tipus de Bases de Dades NoSQL existents, la de m\u00e9s f\u00e0cil comprensi\u00f3 \u00e9s la Base de Dades Clau-Valor . En ella s'aniran guardant parelles clau-valor, \u00e9s a dir, el nom d'una determinada propietat i el seu valor. La clau ha de ser \u00fanica, \u00e9s a dir, no es pot repetir ja que en cas contrari no es podria tornar a recuperar. Per tant no hi ha definici\u00f3 de taules ni cap altra estructura; es van guardant parelles clau-valor i prou. En el moment de recuperar la informaci\u00f3 veurem que podrem obtenir el contingut d'una clau, o el de m\u00e9s d'una al mateix temps. L'exemple que veurem de Base de Dades Clau-Valor \u00e9s Redis , molt famosa per a seua pot\u00e8ncia i efici\u00e8ncia. La clau sempre \u00e9s de tipus String, i com ja hem comentat no poden haver dues claus iguals. En Redis els valors poden ser de 5 tipus diferents: Cadenes de car\u00e0cters (String) . Per exemple: nom_1 -- > Albert Mapes (Hashes) que vindria a ser un registre amb subcamps (sub-claus). Per exemple: empleat_1 -- > [ nom=\"Albert\" , departament=\"10\" , sou=\"1000.0\" ] Llistes (Lists) que s\u00f3n conjunts ordenats de valors. Per exemple: llista_1 -- > { \"Primer\" , \"Segon\" , \"Tercer\" } Conjunts (Sets) s\u00f3n conjunts desordenats de valors. No importa el seu ordre, i de fet ser\u00e0 impredecible l'ordre amb el qual els torna Redis. Per exemple: colors -- > { \"Blau\" , \"Verd\" , \"Roig\" } **** Conjunts Ordenats (Sorted Sets) , que intenten reunir els avantatges dels conjunts, per\u00f2 que seran ordenats. Ja veurem la difer\u00e8ncia entre llistes i conjunts ordenats. Algunes caracter\u00edstiques de Redis s\u00f3n: \u00c9s una arquitectura client-servidor \u00c9s extraordin\u00e0riament eficient quan es pot carregar tota en mem\u00f2ria, encara que si no pot carregar-la tamb\u00e9 funcionar\u00e0 de forma molt r\u00e0pida. I a m\u00e9s mant\u00e9 una sincronitzaci\u00f3 constant a disc per a fer les dades persistents. Aquesta tasca la fa en segon pla, de manera que no afecta al servei. Per a poder suportar ratios de lectura molt alts fa una replicaci\u00f3 master/slave, \u00e9s a dir que pot haver m\u00e9s d'un servidor, i un \u00e9s el que actua de master i els altres s\u00f3n r\u00e8pliques del primer. El slave rep una c\u00f2pia inicial de la Base de Dades sencera. A mida que es van realitzant escriptures en el master, es van enviant a tots els slaves connectats. Els clients es poden connectar als distints servidors, b\u00e9 siga al master o als slaves, sense haver de carregar sempre al master. 2.1 - Instal\u00b7laci\u00f3 de Redis Redis est\u00e0 constru\u00eft per a Linux. Tamb\u00e9 funciona, per\u00f2, des de Windows com veurem una miqueta m\u00e9s avant. Instal\u00b7laci\u00f3 en Linux El lloc des d'on baixar-lo \u00e9s la p\u00e0gina oficial: https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-from-source/ En el moment de fer aquestos apunts, l'\u00faltima versi\u00f3 estable \u00e9s la 7.4.1 . Per obtenir els fitxers font de la darrera versi\u00f3 estable de Redis des del lloc de desc\u00e0rregues de Redis, executeu: wget https://download.redis.io/redis-stable.tar.gz Compilando Redis Suposarem que el fitxer est\u00e0 col\u00b7locat en el lloc on volem que estiga instal\u00b7lat de forma definitiva. Per compilar Redis, primer extrae el fitxer tar, canvia al directori arrel i despr\u00e9s executa make: tar -xzvf redis-stable.tar.gz cd redis-stable make Amb a\u00e7\u00f2 s'haurien d'haver generat els executables, i ja hauria de funcionar. Per a posar en marxa el servidor, quasi que el m\u00e9s c\u00f2mode ser\u00e0 obrir un terminal, situar-nos en el directori redis-stable/src i des d'ahi executar redis-server . Hauria d'eixir una finestra similar a la seg\u00fcent, amb m\u00e9s o menys avisos (observeu que al principi de la imatge est\u00e0n les ordres donades per a executar el servidor). Entre altres coses diu que el servidor est\u00e0 en marxa esperant connexions al port 6379, que \u00e9s el port per defecte de Redis. Aquesta finestra del terminal l'haurem de deixar en marxa. Quan vulguem detenir Redis, senzillament fem ctrl-c , i detindrem l'execuci\u00f3 de forma ordenada (guardant-se les dades no guardades) Podr\u00edem haver executat directament redis-server fent-li doble-clic des d'un explorador d'arxius, per exemple, per\u00f2 aleshores no podr\u00edem parar-lo i en definitiva controlar-lo tan c\u00f2modament. Per a fer una connexi\u00f3 des d'un client, tamb\u00e9 des d'un terminal (un altre) executem redis-cli : Ja ha fet la connexi\u00f3, concretament a localhost (127.0.0.1) i al port 6379, que hav\u00edem quedat que \u00e9s el port per defecte. Comprovem que s\u00ed que funciona. Encara no hi ha dades, perqu\u00e8 l'acabem d'instal\u00b7lar. I recordeu que \u00e9s una Base de Dades clau-valor. Per crear una entrada posarem set clau valor . Per a obtenir-la posarem get clau . En la imatge es pot comprovar: Hem creat una clau anomenada clau_1 amb el valor primera , com es pot comprovar en el moment d'obtenir-la amb get . Si al programa redis-cli no li posem par\u00e0metres, intentar\u00e0 fer una connexi\u00f3 local (localhost). Si volem connectar a un servidor situat en una altra adre\u00e7a, li la posem amb el par\u00e0metre -h adre\u00e7a , per exemple: redis-cli -h 192.168.1.26 Connexi\u00f3 al servidor de l'Institut En el servidor de dades de l'Institut tamb\u00e9 tenim instal\u00b7lat redis. Per\u00f2 per a no tenir accessos no desitjats, cal una autenticaci\u00f3. Senzillament \u00e9s posar el comando auth amb la contrasenya que ja hem utilitzat en altres ocasions: auth ieselcaminas.ad En la seg\u00fcent imatge es veu com s\u00ed que hem pogut connectar Instal\u00b7laci\u00f3 en Windows de 64 bits Encara que Redis est\u00e0 constru\u00eft per a Linux, hi ha versions per a Windows, preferiblement de 64 bits. El lloc on poder baixar els fitxers de Redis per a Windows de 64 bits \u00e9s: https://github.com/MSOpenTech/redis/releases Versi\u00f3 En el moment de fer aquestos apunts, la darreara versi\u00f3 es la 3.0.504. Ens baixem el zip, el descomprimim, i ja ho tindrem disponible (sense fer make ni res). Observeu com en la carpeta resultat de descomprimir ja tenim els executables redis-server i redis-cli que s\u00f3n els que ens interessen: Executem redis-server directament i ja el tindrem en marxa: Executem tamb\u00e9 el redis-cli i el resultat ser\u00e0 el mateix que en Linux. 2.2 - Entron gr\u00e0fic: Redis Insight Com hem comprovat en el punt anterior, la connexi\u00f3 que fem des del client \u00e9s a trav\u00e9s de consola. Per tant haurem de posar comandos i ens contestar\u00e0 la seua execuci\u00f3. Podem instal\u00b7lar-nos una aplicaci\u00f3 gr\u00e0fica que fa\u00e7a un poc m\u00e9s atractiva la presentaci\u00f3. La instal\u00b7laci\u00f3 d'aquesta eina \u00e9s totalment optativa , no cal que la feu. De fet, ens els exemples que es mostraran en tot el tema nom\u00e9s s'utilitzar\u00e0 el mode consola. \u00c9s completament independent del servidor, i podem instal\u00b7lar-la perfectament sense tenir el servidor, utilitzant-la aleshores per a connectar a un servidor remot. El podem baixar lliurement de la p\u00e0gina oficial redis.io/insight on podrem comprovar que tenim per a totes les plataformes: Instal\u00b7laci\u00f3 en Windows En Windows el que ens baixarem \u00e9s un exe. L'executem (permetent l'execuci\u00f3 quan ho pregunta Windows) i li podem donar a totes les opcions per defecte. Quan l'executem, ens eixir\u00e0 la seg\u00fcent pantalla: Podem comprovar que tenim el bot\u00f3 per a afegir una BD Redis (+ Add Redis database). Per a connectar al servidor local la conexi\u00f3 ser\u00e0 redis://default@127.0.0.1:6379 . En la imatge s'ha fet el test de connexi\u00f3. Per a connectar a un remot, posarem la seua adre\u00e7a. En aquesta imatge es veu com hem connectat perfectament als dos servidors. 2.3 - Utilitzaci\u00f3 de Redis Anam a veure la utilitzaci\u00f3 de Redis, Ens connectarem com a clients i intentarem fer operacions. Les primeres seran les m\u00e9s senzilles, utilitzant \u00fanicament el tipus de dades String . Posteriorment mirarem com treballar amb les claus: buscar-ne una, veure si existeix, buscar unes quantes, ... Despr\u00e9s ja anirem a pels tipus de dades m\u00e9s complicats: Hash List Set Sorted Set 2.2.1 - Strings \u00c9s el tipus de dades m\u00e9s senzill, m\u00e9s b\u00e0sic. Ser\u00e0 una cadena de car\u00e0cters de tipus binary safe en la qual normalment guardarem les habituals cadenes de car\u00e0cters, per\u00f2 que tamb\u00e9 podr\u00edem guardar imatges o objectes serialitzats. La grand\u00e0ria m\u00e0xima \u00e9s de 512Mb. Ara veurem els comandos m\u00e9s habituals que afecten a aquest tipus. Com a norma general, hem de ser conscients que els comandos no s\u00f3n sensibles a maj\u00fascules o min\u00fascules, per\u00f2 les claus i els valors s\u00ed que ho s\u00f3n. \u00c9s a dir, el comando get tamb\u00e9 es pot escriure GET o Get . Per\u00f2 la clau Hola \u00e9s diferent de la clau hola . GET Sintaxi get clau Torna el valor de la clau especificada, sempre que siga de tipus String . Si la clau \u00e9s d'un altre tipus, donar\u00e0 error. I si la clau no existeix, tornar\u00e0 el valor especial nil . Exemples 127.0.0.1:6379> get clau_1 \"primera\" 127.0.0.1:6379> get clau_2 (nil) SET Sintaxi set clau valor Assigna a la clau especificada com a primer par\u00e0metre el valor especificat com a segon par\u00e0metre. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Redis sempre guardar\u00e0 el valor com a string, encara que nosaltres pensem que li passem un valor enter o real. I una altra caracter\u00edstica \u00e9s que si la clau existeix ja, matxacar\u00e0 el seu contingut, com era de esperar. Exemples 127.0.0.1:6379> set clau_2 segona OK 127.0.0.1:6379> set text \"Un text amb m\u00e9s d'una paraula\" OK 127.0.0.1:6379> set quatre 4 OK 127.0.0.1:6379> get quatre \"4\" 127.0.0.1:6379> set pi 3.14159265359 OK 127.0.0.1:6379> get pi \"3.14159265359\" Nota Si poseu algun accent, en tornar el valor (fent get) us semblar\u00e0 que no s'ha guardat b\u00e9. S\u00ed que s'haur\u00e0 guardat b\u00e9, el que passa \u00e9s que posteriorment no es visualitza b\u00e9 en fer el get. Es pot comprovar entrant en el client amb l'opci\u00f3 raw , \u00e9s a dir redis-cli --raw El comando SET t\u00e9 una opci\u00f3 molt interessant, que servir\u00e0 per a donar un temps de vida a la clau, transcorregut el qual desapareix la clau (amb el seu valor clar). A\u00e7\u00f2 s'anomena temps d'expiraci\u00f3 i s'aconsegueix amb el par\u00e0metre EX del comando SET seguit del n\u00famero de segons que volem que dure la clau. Exemples 127.0.0.1:6379> set clau_3 tercera ex 10 OK 127.0.0.1:6379> get clau_3 \"tercera\" 127.0.0.1:6379> get clau_3 (nil) Primer s\u00ed que existeix, per\u00f2 al cap de 10 segons ha deixat d'existir. De forma equivalent es pot expressar el temps en milisegons, amb el par\u00e0metre PX en compte de EX . Hav\u00edem comentat al principi, que si en el moment de fer el SET la clau ja existia, es reempla\u00e7ar\u00e0 el seu contingut. Podem modificar aquest comportament amb el par\u00e0metre NX (Not eXists): si no existia la clau, la crear\u00e0 amb el valor, per\u00f2 si ja existia, la deixar\u00e0 com estava. Ens ho indicar\u00e0 dient OK en cas de crear-la i NIL en cas de no crear-la perqu\u00e0 ja existia. 127.0.0.1:6379> set clau_4 quarta nx OK 127.0.0.1:6379> set clau_1 quarta nx (nil) 127.0.0.1:6379> get clau_4 \"quarta\" 127.0.0.1:6379> get clau_1 \"primera\" I de forma inversa, si posem el par\u00e0metre XX , si ja existeix la clau, reempla\u00e7ar\u00e0 el valor, per\u00f2 si no existia, no far\u00e0 res. SETEX Sintaxi setex clau segons valor Funciona igual que el SET amb el par\u00e0metre EX : crear\u00e0 la clau amb el valor, per\u00f2 tindr\u00e0 una exist\u00e8ncia dels segons indicats. PSETEX Sintaxi psetex clau milisegons valor Funciona igual que l'anterior, per\u00f2 el que especifiquem s\u00f3n els milisegons d'exist\u00e8ncia. MGET Sintaxi mget clau1 clau2 clauN Torna una llista de valors, els de les claus indicades. Exemples 127.0.0.1:6379> set mes1 gener OK 127.0.0.1:6379> set mes2 febrer OK 127.0.0.1:6379> set mes3 mar\u00e7 OK 127.0.0.1:6379> mget mes1 mes2 mes3 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" Nota Recordeu que els car\u00e0cters com vocals accentuades, \u00e7, \u00f1, ... s'han introdu\u00eft b\u00e9, per\u00f2 potser no es visualiten b\u00e9. Es pot evitar entrant en el client d'aquesta manera redis-cli --raw Si alguna de les claus no exiteix, tornar\u00e0 nil en el seu lloc MSET Sintaxi mset clau1 valor1 clau2 valor2 clauN valorN Assigna els valors corresponents a les claus. \u00c9s una operaci\u00f3 at\u00f2mica: es posen (o canvien) tots els valors a l'hora. 127.0.0.1:6379> mset mes4 abril mes5 maig mes6 juny mes7 juliol OK 127.0.0.1:6379> mget mes1 mes2 mes3 mes4 mes5 mes6 mes7 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" 4) \"abril\" 5) \"maig\" 6) \"juny\" 7) \"juliol\" Si no vulgu\u00e9rem reempla\u00e7ar valors, podr\u00edem utilitzar el comando MSETNX , totalment equivalent, per\u00f2 haur\u00edem de tenir en compte que si alguna ja existeix i per tant no pot canviar el valor, no faria l'operaci\u00f3, \u00e9s a dir, tampoc crearia les altres. APPEND Sintaxi append clau1 valor1 Si la clau no existeix la crea assignant-li el valor (com el SET ), per\u00f2 si ja existeix, concatena el valor al final de la cadena que ja hi havia. 127.0.0.1:6379> append salutacio Hola (integer) 4 127.0.0.1:6379> get salutacio \"Hola\" 127.0.0.1:6379> append salutacio \", com va?\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola, com va?\" STRLEN Sintaxi strlen clau1 Torna el n\u00famero de car\u00e0cters que hi ha en el valor de la clau. Si la clau no existeix, tornar\u00e0 0. Si la clau \u00e9s d'un altre tipus, tornar\u00e0 error. 127.0.0.1:6379> strlen salutacio (integer) 13 127.0.0.1:6379> strlen sal (integer) 0 GETRANGE Sintaxi getrange clau1 inici final Extrau una subcadena del valor de la clau (ha de ser de tipus String ) des del n\u00famero de car\u00e0cter d'inici fins al n\u00famero del final (ambd\u00f3s inclosos). El primer car\u00e0cter \u00e9s el 0. Si posem de final un n\u00famero major que l'\u00faltim, igual ho traur\u00e0 fins el final. Es poden posar tamb\u00e9 valor negatius que ens ajuden a agafar la cadena des del final. El -1 \u00e9s l'\u00faltim car\u00e0cter, el -2 el pen\u00faltim, ... I es poden barrejar n\u00fameros positius i negatius. Aix\u00ed el rang 0 -1 \u00e9s tota la cadena. 127.0.0.1:6379> getrange salutacio 1 3 \"ola\" 127.0.0.1:6379> getrange salutacio 6 50 \"com va?\" 127.0.0.1:6379> getrange salutacio 6 -1 \"com va?\" 127.0.0.1:6379> getrange salutacio -7 -5 \"com\" SETRANGE Sintaxi setrange clau1 despla\u00e7ament valor Substitueix part del valor de la cadena, a partir del despla\u00e7ament, amb el vaolr proporcionat. No s'admenten en despla\u00e7ament valors negatius. 127.0.0.1:6379> get salutacio \"Hola, com va?\" 127.0.0.1:6379> setrange salutacio 4 \". C\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola. Com va?\" INCR Sintaxi incr clau1 A pesar de que Redis guarda els strings com a tals, com a cadenes de car\u00e0cters, en algunes ocasions \u00e9s capa\u00e7 de transformar la cadena a un n\u00famero. \u00c9s el cas del comando INCR , que converteix la cadena en un enter (si pot) i incrementa aquest valor en una unitat. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 1. Si el valor de la clau no era un n\u00famero enter, donar\u00e0 un error. 127.0.0.1:6379> set compt1 20 OK 127.0.0.1:6379> get compt1 \"20\" 127.0.0.1:6379> incr compt1 (integer) 21 127.0.0.1:6379> get compt1 \"21\" 127.0.0.1:6379> incr compt2 (integer) 1 127.0.0.1:6379> get compt2 \"1\" 127.0.0.1:6379> incr clau_1 (error) ERR value is not an integer or out of range 127.0.0.1:6379> set compt3 4.25 OK 127.0.0.1:6379> incr compt3 (error) ERR value is not an integer or out of range DECR Sintaxi decr clau1 Decrementa en una unitat el valor de la clau (senpre que siga un enter). Pot agafar valors negatius. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 -1. 127.0.0.1:6379> decr compt2 (integer) 0 127.0.0.1:6379> decr compt2 (integer) -1 127.0.0.1:6379> get compt2 \"-1\" INCRBY Sintaxi incrby clau1 increment Incrementa el valor de la clau en el n\u00famero d'unitats indicat en increment (el valor ha de ser enter). L'increment pot ser negatiu. 127.0.0.1:6379> incrby compt1 10 (integer) 31 127.0.0.1:6379> incrby compt1 -20 (integer) 11 DECRBY Sintaxi decrby clau1 decrement Decrementa el valor de la clau el n\u00famero d'unitat indicat en decrement . 127.0.0.1:6379> decrby compt1 5 (integer) 6 2.2.2 - Keys Ara anem a veure comandos que ens permeten treballar amb les claus, per a buscar-les, veure si existeixen, etc. No importar\u00e0 el tipus de les claus (de moment nom\u00e9s hem treballat amb claus de tipus String , per\u00f2 si ja en tingu\u00e9rem dels altres tipus tamb\u00e9 es veurien afectades). En cap cas d'aquestos comandos accedirem al valor de les claus. KEYS Sintaxi keys patr\u00f3 Torna totes les claus que coincideixen amb el patr\u00f3. En el patr\u00f3 podem posar car\u00e0cters comod\u00ed: * : equival a 0 o m\u00e9s car\u00e0cters. Per exemple \"Mar*a\" podria tornar \"Mara\", \"Maria\", \"Marta\", \"Margarita\", ... ? : equival exactament a un car\u00e0cter. Per exemple \"Mar?a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Mara\", \"Margarita\", ... [ab] : ser\u00e0 cert si en el lloc corresponent hi ha un dels car\u00e0cters especificats entre els claud\u00e0tors. Per exemple \"Mar[it]a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Marga\" Per a tornar totes les claus utilitzarem **keys *** 127.0.0.1:6379> keys * 1) \"compt3\" 2) \"mes5\" 3) \"mes3\" 4) \"comp3\" 5) \"mes7\" 6) \"mes2\" 1) \"mes6\" 2) \"salutacio\" 3) \"mes4\" 4) \"mes1\" 5) \"clau_1\" 6) \"compt1\" 7) \"compt2\" 127.0.0.1:6379> keys mes? 1) \"mes5\" 2) \"mes3\" 3) \"mes7\" 4) \"mes2\" 5) \"mes6\" 6) \"mes4\" 7) \"mes1\" 127.0.0.1:6379> keys c* 1) \"compt3\" 2) \"comp3\" 3) \"clau_1\" 4) \"compt1\" 5) \"compt2\" 127.0.0.1:6379> keys mes[125] 1) \"mes5\" 2) \"mes2\" 3) \"mes1\" EXISTS Sintaxi exists clau Torna 1 si la clau existeix, i 0 si no existeix. No importa de quin tipus siga la clau. 127.0.0.1:6379> exists clau_1 (integer) 1 127.0.0.1:6379> exists clau_25 (integer) 0 DEL Sintaxi del clau1 clau2 clauN Elimina la clau o claus especificades. Si posem m\u00e9s d'una clau i alguna no existeix, la ignorar\u00e0 i s\u00ed que esborrar\u00e0 les altres. 127.0.0.1:6379> del compt2 (integer) 1 127.0.0.1:6379> del mes6 mes7 mes8 mes9 (integer) 2 Observeu que ens indica quantes claus ha esborrat. En el primer exemple ha esborrat la clau especificada, i en el segon diu que ha esborrat 2, que seran mes6 i mes7 , ja que mes8 i mes9 no existien. TYPE Sintaxi type clau Torna el tipus de la clau especificada. Els valors possibles s\u00f3n: string hash list set zset (conjunt ordenat) Exemples 127.0.0.1:6379> type clau_1 string RENAME Sintaxi rename clau novaclau Canvia el nom de la clau a la clau nova, conservant el valor. D\u00f3na error si la clau antiga no existeix. Si la clau nova ja existia reempla\u00e7ar\u00e0 el seu valor. Exemples 127.0.0.1:6379> get salutacio \"Hola. Com va?\" 127.0.0.1:6379> rename salutacio saludar OK 127.0.0.1:6379> get salutacio (nil) 127.0.0.1:6379> get saludar \"Hola. Com va?\" 127.0.0.1:6379> rename clau_22 clau_23 (error) ERR no such key RENAMENX Sintaxi renamenx clau novaclau Igual que l'anterior per\u00f2 \u00fanicament si la clau nova no existia. Si ja existia no fa res (tornant 0 per a indicar-h0). Exemples 127.0.0.1:6379> renamenx compt1 compt3 (integer) 0 127.0.0.1:6379> get compt1 \"9\" Estem suposant que la clau compt3 ja existeix EXPIRE Sintaxi expire clau segons Assigna com a temps d'expiraci\u00f3 de la clau els segons especificats. Si ja tenia temps d'expiraci\u00f3, el modifica posant-li aquest valor especificat. En cas que a una clau amb temps d'expiraci\u00f3 li canviem el nom amb RENAME , continuar\u00e0 amb temps d'expiraci\u00f3 que li quedava. PEXPIRE Sintaxi pexpire clau milisegons El mateix per\u00f2 en milisegons TTL Sintaxi ttl clau Torna el temps de vida (fins l'expiraci\u00f3) d'una clau. Si la clau no t\u00e9 temps d'expiraci\u00f3, torna -1. Exemples 127.0.0.1:6379> expire compt3 10 (integer) 1 127.0.0.1:6379> ttl compt3 (integer) 6 127.0.0.1:6379> ttl compt3 (integer) 3 127.0.0.1:6379> ttl compt3 (integer) 0 127.0.0.1:6379> get compt3 (nil) PTTL Sintaxi pttl clau Igual que l'anterior, per\u00f2 ens torna el temps en milisegons. PERSIST Sintaxi persist clau Elimina el temps d'expiraci\u00f3 d'una clau, si \u00e9s que en tenia. Ara la clau no expirar\u00e0 mai. Exemples 127.0.0.1:6379> expire compt1 20 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) 12 127.0.0.1:6379> ttl compt1 (integer) 7 127.0.0.1:6379> persist compt1 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) -1 127.0.0.1:6379> get compt1 \"9\" 2.2.3 - Hash Ja hav\u00edem comentat que el tipus Hash \u00e9s una esp\u00e8cie de registre, amb subcamps (en realitat haur\u00edem de dir sub-claus). Pot tenir qualsevol n\u00famero de subcamps que s\u00f3n de tipus String. Redis \u00e9s molt eficient en quant a l'espai que ocupen els Hash , i sobretot en el temps de recuperaci\u00f3 de les dades. Els comandos que vam veure per al String no es poden aplicar al Hash . Tanmateix els comandos del Hash s\u00f3n molt similars a aquells, comen\u00e7ant sempre per H . HSET Sintaxi hset clau camp valor Assigna al camp especificat de la clau especificada el valor especificat. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Si la clau no existia, la crear\u00e0, i si ja existia, senzillament afegir\u00e0 el camp. I si d'aquesta clau ja existia el camp, modificar\u00e0 el seu valor. Evidentment, en claus diferents poden haver camps amb els mateixos noms. Exemples 127.0.0.1:6379> hset empleat_1 nom Andreu (integer) 1 127.0.0.1:6379> hset empleat_1 departament 10 (integer) 1 127.0.0.1:6379> hset empleat_1 sou 1000.0 (integer) 1 127.0.0.1:6379> hset empleat_2 nom Berta (integer) 1 127.0.0.1:6379> hset empleat_2 sou 1500.0 (integer) 1 HGET Sintaxi hget clau camp Torna el valor del camp de la clau. Si no existia (el camp o la clau) torna nil . Nom\u00e9s podem especificar un camp. Exemples 127.0.0.1:6379> hget empleat_1 nom \"Andreu\" 127.0.0.1:6379> hget empleat_1 departament \"10\" 127.0.0.1:6379> hget empleat_2 nom \"Berta\" 127.0.0.1:6379> hget empleat_2 departament (nil) HGETALL Sintaxi hgetall clau Torna una llista amb tots els camps i els seus valors de la clau. La seq\u00fc\u00e8ncia \u00e9s: camp1 valor1 camp2 valor2 ... Per\u00f2 no ens podem fiar que l'ordre siga el mateix ordre que quan el vam definir. Exemples 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"departament\" 4) \"10\" 5) \"sou\" 6) \"1000.0\" HDEL Sintaxi hdel clau camp1 camp2 campN Elimina el o els camps especificats. Si no existeixen algun d'ells, senzillament l'ignora i si que elimina els altres. Exemples 127.0.0.1:6379> hdel empleat_1 departament (integer) 1 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"sou\" 4) \"1000.0\" HKEYS Sintaxi hkeys clau Torna una llista amb els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hkeys empleat_1 1) \"nom\" 2) \"sou\" HVALS Sintaxi hvals clau Torna una llista amb els valors (\u00fanicament els valors) de tots els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hvals empleat_1 1) \"Andreu\" 2) \"1000.0\" Altres Comandos Tamb\u00e9 existeixen altres comandos, de funcionament com cabria esperar (els hem vist tots en el cas de String ): hmget : Torna m\u00e9s d'un camp de la clau hmset : assigna m\u00e9s d'un camp a una clau hexists : indica si existeix el subcamp de la clau hsetnx : assigna \u00fanicament en cas de que no existisca el camp. hincrby : incrementa el camp de la clau 2.2.4 - List Les Llistes en Redis s\u00f3n llistes de Strings ordenades, on cada element est\u00e0 associat a un \u00edndex de la llista. Es poden recuperar els elements tant de forma ordenada (per l'\u00edndex) com accedint directament a una posici\u00f3. Els elements es poden afegir al principi, al final o tamb\u00e9 en una posici\u00f3 determinada. La llista es crea en el moment en qu\u00e8 s'insereix el primer element, i desapareix quan llevem l'\u00faltim element que quede. Estan molt ben optimitzades per a la inserci\u00f3 i per a la consulta. Els comandos que afecten a les llistes comencen quasi tots per L , excepte alguns que comencen per R indicant que fan l'operaci\u00f3 per la dreta. Els valors dels elements es poden repetir. LPUSH Sintaxi lpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en la primera posici\u00f3, o tamb\u00e9 podr\u00edem dir que per l'esquerra ( Left PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. Si posem m\u00e9s d'un valor, s'aniran introduint sempre en la primera posici\u00f3. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> lpush llista1 primera segona tercera (integer) 3 127.0.0.1:6379> lrange llista1 0 -1 1) \"tercera\" 2) \"segona\" 3) \"primera\" 127.0.0.1:6379> lpush llista1 quarta cinquena (integer) 5 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" Nota Per a veure el contingut de la llista utilitzarem el comando lrange llista 0 -1 , que torna la llista sencera. Veurem de forma m\u00e9s completa aquest comando amb posterioritat. RPUSH Sintaxi rpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en l'\u00faltima posici\u00f3, o tamb\u00e9 podr\u00edem dir que per la dreta ( Right PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> rpush llista1 sisena setena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" 6) \"sisena\" 7) \"setena\" LPOP Sintaxi lpop clau Torna i elimina el primer element (el de m\u00e9s a l'esquerra). Exemples 127.0.0.1:6379> lpop llista1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\" 6) \"setena\" RPOP Sintaxi rpop clau Torna i elimina l'\u00faltim element (el de m\u00e9s a la dreta). Exemples 127.0.0.1:6379> rpop llista1 \"setena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\" LSET Sintaxi lset clau index valor Substitueix el valor de la posici\u00f3 indicada per l'\u00edndex. Tant la clau com l'element de la posici\u00f3 indicada han d'existir, sin\u00f3 donar\u00e0 error. Ara la L no significa Left sin\u00f3 List . La primera posici\u00f3 \u00e9s la 0. I tamb\u00e9 es poden posar n\u00fameros negatius: -1 \u00e9s l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lset llista1 2 quarta OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 127.0.0.1:6379> lset llista1 -1 cinquena OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" Observeu com es poden repetir els valors LINDEX Sintaxi lindex clau index Torna l'element situat en la posici\u00f3 indicada per l'\u00edndex, per\u00f2 sense eliminar-lo de la llista . Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> lindex llista1 0 \"quarta\" 127.0.0.1:6379> lindex llista1 3 \"primera\" 127.0.0.1:6379> lindex llista1 -1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" LINSERT Sintaxi linsert clau BEFORE | AFTER valor1 valor2 Insereix el valor2 abans o despr\u00e9s (segons el que triem) de la primera vegada que troba el valor1. No substitueix, sin\u00f3 que insereix en una determinada posici\u00f3. Els elements que van despr\u00e9s de l'element introdu\u00eft veuran actualitzat el seu \u00edndex. Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> linsert llista1 AFTER quarta segona (integer) 6 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"cinquena\" 127.0.0.1:6379> linsert llista1 BEFORE cinquena sisena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 Si intentem inserir abans o despr\u00e9s un element que no existeix, tornar\u00e0 -1 indicant que no l'ha trobat i no far\u00e0 la inserci\u00f3. 127.0.0.1:6379> linsert llista1 BEFORE desena setena (integer) -1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" LRANGE Sintaxi lrange clau inici final Torna els elements de la llista inclosos entre els index inici i final, ambd\u00f3s inclosos. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 2 4 1) \"tercera\" 2) \"quarta\" 3) \"primera\" 127.0.0.1:6379> lrange llista1 1 -2 4) \"segona\" 5) \"tercera\" 6) \"quarta\" 7) \"primera\" 8) \"sisena\" 127.0.0.1:6379> lrange llista1 4 4 1) \"primera\" LLEN Sintaxi llen clau Torna el n\u00famero d'elements de la llista Exemples 127.0.0.1:6379> llen llista1 (integer) 7 LREM Sintaxi lrem clau n\u00famero valor Elimina elements de la llista que coincidisquen amb el valor proporcionat. Ja sabem que els valors es poden repetir. Amb el n\u00famero indiquem quants elements volem que s'esborrencomen\u00e7ant per l'esquerra: si posem 1 s'esborrar\u00e0 el primer element amb aquest valor, si posem 2 s'esborraran els dos primers elements (els de m\u00e9s a l'esquerra) que tingen aquest valor. Si posem 0 s'esborraran tots els elements amb aquest valor Exemples 127.0.0.1:6379> rpush llista1 segona (integer) 8 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 8) \"segona\" 127.0.0.1:6379> lrem llista1 1 segona (integer) 1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 6) \"cinquena\" 7) \"segona\" 127.0.0.1:6379> lrem llista1 0 quarta (integer) 2 127.0.0.1:6379> lrange llista1 0 -1 8) \"tercera\" 9) \"primera\" 10) \"sisena\" 11) \"cinquena\" 12) \"segona\" LTRIM Sintaxi ltrim clau inici final Elimina els elements que queden fora dels \u00edndex inici i final, \u00e9s a dir elimina els que estiguen a l'esquerra d'inici, i els que estiguen a la dreta de final. Exemples 127.0.0.1:6379> ltrim llista1 1 -2 OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"primera\" 2) \"sisena\" 3) \"cinquena\" 2.2.5 - Set Els Sets de Redis s\u00f3n conjunts de valors de tipus String no ordenats. Podrem afegir, actualitzar i esborrar aquestos elements de forma c\u00f2moda i eficient. No es permetran els valors duplicats. A m\u00e9s Redis ens ofereix operacions interessants com la uni\u00f3, intersecci\u00f3 i difer\u00e8ncia de conjunts. Com sempre, els comandos s\u00f3n espec\u00edfics, \u00e9s a dir no ens valen els de Strings, List o Hash. Tots els comandos comencen per S . SADD Sintaxi sadd clau valor1 valor2 valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari). Recordem que l'ordre no \u00e9s important, i que no es poden repetir els valors; si intentem introduir un repetit, no donar\u00e0 error, per\u00f2 no l'introduir\u00e0. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> sadd colors roig verd blau (integer) 3 127.0.0.1:6379> sadd colors verd groc (integer) 1 SMEMBERS Sintaxi smembers clau Torna tots els valors del conjunt. Si la clau no existeix tornar\u00e0 un conjunt buit. Recordeu que l'ordre dels elements no \u00e9s predecible Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"verd\" 3) \"roig\" 4) \"blau\" SISMEMBER Sintaxi sismember clau valor Comprova si el valor est\u00e0 en el conjunt, tornant 1 en cas afirmatiu i 0 en cas negatiu. Exemples 127.0.0.1:6379> sismember colors verd (integer) 1 127.0.0.1:6379> sismember colors negre (integer) 0 SCARD Sintaxi sard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt en l'actualitat. Exemples 127.0.0.1:6379> scard colors (integer) 4 SREM Sintaxi srem clau valor1 valor2 valorN Elimina els valors del conjunt. Si el conjunt es queda buit, eliminar\u00e0 la clau tamb\u00e9. Si algun dels valor no \u00e9s cap element del conjunt, senzillament s'ignorar\u00e0. El comando torna el n\u00famero d'elements realment eliminat. Exemples 127.0.0.1:6379> srem colors verd negre (integer) 1 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\" SPOP Sintaxi spop clau Torna i elimina un valor aleatori del conjunt. Recordeu que a m\u00e9s de tornar- lo, l'elimina del conjunt. Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> spop colors \"groc\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" SRANDMEMBER Sintaxi srandmember clau Molt paregut a l'anterior. Torna un valor aleatori del conjunt, per\u00f2 en aquesta ocasi\u00f3 no l'elimina del conjunt. Exemples 127.0.0.1:6379> srandmember colors \"blau\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" SUNION Sintaxi sunion clau1 clau2 clauN Torna la uni\u00f3 dels elements dels conjunts especificats. \u00c9s una uni\u00f3 correcta, \u00e9s a dir, no es repetir\u00e0 cap valor. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> sadd colors1 verd roig groc (integer) 3 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunion colors colors1 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\" SUNIONSTORE Sintaxi sunionstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la uni\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunionstore colors2 colors colors1 (integer) 4 127.0.0.1:6379> smembers colors2 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\" SDIFF Sintaxi sdiff clau1 clau2 clauN Torna la difer\u00e8ncia dels elements del primer conjunt respecte de la uni\u00f3 de tots els altres. \u00c9s a dir, torna els elements del primer conjunt que no pertanyen acap dels altres. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiff colors1 colors 1) \"verd\" 2) \"groc\" SDIFFSTORE Sintaxi sdiffstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la difer\u00e8ncia en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiffstore colors3 colors1 colors (integer) 2 127.0.0.1:6379> smembers colors3 1) \"verd\" 2) \"groc\" SINTER Sintaxi sinter clau1 clau2 clauN Torna la intersecci\u00f3 dels elements dels conjunts. \u00c9s a dir, torna els elements que pertanyen a tots els conjunts especificats. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sinter colors colors1 1) \"roig\" SINTERSTORE Sintaxi sinterstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la intersecci\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 3) \"groc\" 4) \"roig\" 5) \"verd\" 127.0.0.1:6379> sinterstore colors4 colors colors1 (integer) 1 127.0.0.1:6379> smembers colors4 6) \"roig\" SMOVE Sintaxi smove clau_font clau_dest\u00ed valor Meneja el valor del conjunt or\u00edgen (el primer conjunt) al conjunt dest\u00ed (el segon). Aix\u00f2 suposar\u00e0 eliminar-lo del primer i afegir-lo al segon. Tornar\u00e0 1 si l'ha menejat, i 0 si no l'ha menejat. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> smove colors1 colors verd (integer) 1 127.0.0.1:6379> smembers colors 1) \"verd\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 2.2.6 - Set ordenat Els Sets Ordenats ( Sorted Set ) de Redis s\u00f3n Sets que a m\u00e9s de guardar els valors, guarden tamb\u00e9 una puntuaci\u00f3 ( score ) per a cada valor, i Redis mantindr\u00e0 el conjunt ordenat per aquesta puntuaci\u00f3. Els valors no es podran repetir, per\u00f2 s\u00ed les puntuacions. Molts dels comandos seran iguals que els del Set , ja que un conjunt ordenat no deixa de ser un conjunt, per\u00f2 amb la informaci\u00f3 de la puntuaci\u00f3. En aquesta ocasi\u00f3 comen\u00e7aran per Z ZADD Sintaxi zadd clau puntuaci\u00f31 valor1 puntuaci\u00f32 valor2 puntuaci\u00f3N valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari) amb les puntuacions corresponents. Les puntuacions seran Strings de valors reals (float). No es poden repetir els valors, per\u00f2 s\u00ed les puntuacions. Si intentem introduir un valor repetit, el que far\u00e0 ser\u00e0 actualitzar la puntuaci\u00f3. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> zadd puntuacions 1 Nom1 2 Nom2 5 Nom3 4 Nom4 (integer) 4 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\" ZCARD Sintaxi zcard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt ordenat en l'actualitat. Exemples 127.0.0.1:6379> zcard puntuacions (integer) 4 ZSCORE Sintaxi zscore clau valor Torna la puntuaci\u00f3 (score) del valor especificat del conjunt ordenat. Si no existeix el valor o no existaix la clao, torna nil. Exemples 127.0.0.1:6379> zscore puntuacions Nom3 \"5\" 127.0.0.1:6379> zscore puntuacions Nom7 (nil) ZCOUNT Sintaxi zcount clau min max Torna el n\u00famero de valors que estan entre les puntuacions especificades (ambdues incloses). Exemples 127.0.0.1:6379> zcount puntuacions 2 5 (integer) 3 ZRANGE Sintaxi zrange clau inici final [withscores] Torna els elements del conjunt ordenat inclosos entre els index inici i final, ambd\u00f3s inclosos. I es trauen per ordre ascentent de puntuaci\u00f3. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element Exemples 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom1\" 2) \"1\" 3) \"Nom2\" 4) \"2\" 5) \"Nom4\" 6) \"4\" 7) \"Nom3\" 8) \"5\" Si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGE ( reverse range ). 127.0.0.1:6379> zrevrange puntuacions 0 -1 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\" 7) \"Nom1\" 8) \"1\" ZRANGEBYSCORE Sintaxi zrangebyscore clau min max [withscores] Torna els elements del conjunt ordenat que tenen una puntuaci\u00f3 compresa entre min i max (ambdues incloses). I es trauen per ordre ascentent de puntuaci\u00f3. Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element. **** Exemples 127.0.0.1:6379> zrangebyscore puntuacions 2 5 1) \"Nom2\" 2) \"Nom4\" 3) \"Nom3\" 127.0.0.1:6379> zrangebyscore puntuacions 2 5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\" Si vulgu\u00e9rem que les puntuacions foren estrictament majors que la puntiuaci\u00f3 m\u00ednima i/o estrictament menor que la puntuaci\u00f3 m\u00e0xima, posar\u00edem un par\u00e8ntesi davany de min i/o max : 127.0.0.1:6379> zrangebyscore puntuacions 2 (5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" I si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGEBYSCORE ( reverse range ). Cuideu que com va en ordre invers, ara el valor m\u00e0xim ha de ser el primer, i el m\u00ednim el segon. 127.0.0.1:6379> zrevrangebyscore puntuacions 5 2 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\" ZRANK Sintaxi zrank clau valor Torna el n\u00famero d'ordre de l'element amb el valor especificat. El primer valor \u00e9s el 0. Si no existeix, torna nil . Exemples 127.0.0.1:6379> zrank puntuacions Nom1 (integer) 0 127.0.0.1:6379> zrank puntuacions Nom4 (integer) 2 127.0.0.1:6379> zrank puntuacions Nom7 (nil) Si volem saber el n\u00famero d'ordre per\u00f2 des del final de la llista (en ordre invers), hem d'utilitzar ZREVRANK : 127.0.0.1:6379> zrevrank puntuacions Nom1 (integer) 3 127.0.0.1:6379> zrevrank puntuacions Nom4 (integer) 1 ZREM Sintaxi zrem clau valor1 valor2 valorN Elimina els elements amb els valors especificats. Si algun valor no existeix, senzillament l'ignora. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zrem puntuacions Nom1 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\" ZREMRANGEBYSCORE Sintaxi zremrangebyscore clau min max Elimina els elements amb puntuaci\u00f3 compresa entre el m\u00ednim i el m\u00e0xim de forma inclusiva.els valors especificats. Si volem fer-ho de forma excusiva (sense incloure les puntuacions dels extrems) posarem un par\u00e8ntesi avant del m\u00ednim i/o el m\u00e0xim. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zremrangebyscore puntuacions (2 4 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom3\" 4) \"5\" ZINCRBY Sintaxi zincrby clau increment valor Incrementa la puntuaci\u00f3 de l'element especificat. El valor de la puntuaci\u00f3 a incrementar \u00e9s un n\u00famero real. Torna el valor la puntuaci\u00f3 final de l'element. Si l'element no existia, l'inserir\u00e0, assumint una puntuaci\u00f3 inicial de 0. Exemples 127.0.0.1:6379> zincrby puntuacions 1.5 Nom2 \"3.5\" 127.0.0.1:6379> zincrby puntuacions 2.75 Nom5 \"2.75\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom5\" 2) \"2.75\" 3) \"Nom2\" 4) \"3.5\" 5) \"Nom3\" 6) \"5\" 2.4 - Connexi\u00f3 des de Kotlin La utilitzaci\u00f3 des de Java \u00e9s molt senzilla, i podrem utilitzar tots els comandos que hem vist. Haurem d'incorporar en el projecte una llibreria. Podem utilitzar per exemple la de Jedis (acr\u00f2nim de J ava R edis ). A la seg\u00fcent adre\u00e7a la podeu trobar: https://repo1.maven.org/maven2/redis/clients/jedis/3.5.0/jedis-3.5.0.jar No \u00e9s l'\u00faltima versi\u00f3, per\u00f2 \u00e9s suficient per a nosaltres i \u00e9s molt f\u00e0cil d'utilitzar Per a fer proves, creem un nou projecte anomenat Tema7 , i incorporem la llibreria de Jedis . Creem un paquet anomenat ExemplesRedis , per separar aquestos dels exercicis. Connexi\u00f3 La connexi\u00f3 \u00e9s tan senzilla com el seg\u00fcent: val con = Jedis(\"localhost\") con.connect() \u00c9s a dir, obtenim un objecte Jedis passant-li al constructor l'adre\u00e7a del servidor, i despr\u00e9s connectem amb el m\u00e8tode connect . Si el servidor no el tenim en la mateixa m\u00e0quina, nom\u00e9s haurem de substituir localhost per l'adre\u00e7a on estiga el servidor. L'objecte Jedis representar\u00e0 una connexi\u00f3 amb el servidor Redis . Tots els comandos que hem vist per a utilitzar des del client de Redis, seran m\u00e8todes d'aquest objecte. Nom\u00e9s haurem d'anar amb compte amb el que ens torna el servidor quan fem una petici\u00f3. Moltes vegades ser\u00e0 un String , per\u00f2 en moltes altres ocasions seran col\u00b7leccions; sets, lists, ... Per a tancar la connexi\u00f3: con.close() Comandos que tornen Strings Tots els comandos que vam veure seran ara m\u00e8todes de l'objecte Jedis . En concret obtenir el valor d'una clau (comando get clau ) ser\u00e0 el m\u00e8tode get al qual li passarem la clau com a par\u00e0metre: Ac\u00ed tenim ja la primera prova. Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova1.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() println(con.get(\"saludar\")) con.close() } Si volem guardar una clau amb un valor, utilitzarem el m\u00e8tode set(clau,valor) , al qual com veiem li hem de passar els dos par\u00e0metres. Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova2.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val valor = \"Aquesta clau \u00e9s una clau creada des de Kotlin\" con.set(\"clau_Java\", valor) println(con.get(\"clau_Java\")) con.close() } Comandos que tornen conjunts En moltes ocasions, el que ens tornar\u00e0 Redis no \u00e9s un \u00fanic String, sin\u00f3 un conjunt de Strings. A\u00e7\u00f2 ser\u00e0 cert quan treballem amb Sets , per\u00f2 tamb\u00e9 en moltes altres ocasions. Per exemple quan demanem unes quantes claus amb MGET , o quan utilitzem KEYS per a que ens torne les claus que coincideixen amb el patr\u00f3. En algunes ocasions ho haurem d'arreplegar amb un objecte Set , quan no importe l'ordre. En altres ocasions amb un objecte List quan aquest ordre s\u00ed que importe. Per exemple, si volem obtenir amb MGET els valors d'unes quantes claus, s\u00ed que importa l'ordre (el primer valor \u00e9s de la primera clau, el segon de la segona). Aleshores ho obtindrem en un List . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova3.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val c = con.mget(\"mes1\", \"mes2\", \"mes3\") // c ser\u00e0 un MutableList for (s in c) println(s) con.close() } Per\u00f2 en canvi si volem obtenir totes les claus utilitzarem el m\u00e8tode keys passant-li el patr\u00f3 com a par\u00e0metre. L'ordre no importa, i a m\u00e9s no el podem predir. Per tant arreplegarem el resultat amb un Set . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova4.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val c = con.keys(\"*\") //c \u00e9s un MutableSet for (s in c) println(s) con.close() } I evidentment tamb\u00e9 ser\u00e0 el cas quan accedim als tipus de dades List , Set i segurament tamb\u00e9 Hash . Per a accedir a tot el contingut d'un List utilitzem per exemple lrange 0 -1 . Si utilitzem aquest m\u00e8tode de Jedis ens tornar\u00e0 un MutableList . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova5.kt : import redis.clients.jedis.Jedis fun main(){ val con = Jedis(\"localhost\") con.connect() val ll = con.lrange(\"llista1\", 0, -1) // ll \u00e9s un MutableList for (e in ll) println(e) con.close() } Si \u00e9s un Set accedirem amb el m\u00e8tode smembers que tornar\u00e0 un MutableSet . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova6.kt : import redis.clients.jedis.Jedis fun main(){ val con = Jedis(\"localhost\") con.connect() val s = con.smembers(\"colors\") // s \u00e9s un MutableSet for (e in s) println(e) con.close() } I en el cas de Hash , amb el m\u00e8tode hkeys podem obtenir tots els camps (subclaus), i a partir d'ells els seus valors. El que torna hkeys \u00e9s un MutableSet . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova7.kt : import redis.clients.jedis.Jedis fun main(){ val con = Jedis(\"localhost\") con.connect() val subcamps = con.hkeys(\"empleat_1\") // sucamps \u00e9s un MutableSet for (subcamp in subcamps) System.out.println(subcamp + \": \" + con.hget(\"empleat_1\", subcamp)) con.close() } Tractament dels conjunts ordenats Els conjunts ordenats ( Sorted Sets ) tenen m\u00e8todes espec\u00edfics, igual que tots els tipus. Alguns d'aquestos m\u00e8todes tornen Strings, i un altres conjunts ( MutableSet ). No hi ha problema amb aquestos tipus, que ja els hem tractat. Per\u00f2 hi ha uns m\u00e8todes que tornen llistes amb m\u00e9s d'un valor per cada element . \u00c9s el cas dels m\u00e8todes ZRANGE (amb les variants ZREVRANGE , ZRANGEBYSCORE i ZREVRANGEBYSCORE ), que tenen la possibilitat de dur el par\u00e0metre WITHSCORES . En aquest cas cada element constar\u00e0 del valor i de la puntuaci\u00f3. El que tornaran els m\u00e8todes \u00e9s un MutableSet de Tuples , objecte proporcionat per Jedis , que disposar\u00e0 dels m\u00e8todes getElement() per al valor i getScore() per a la puntuaci\u00f3. Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova8.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val conjOrd = con.zrangeWithScores(\"puntuacions\", 0, -1) // conjOrd \u00e9s un MutableSet<Tuple> for (t in conjOrd) println(t.getElement() + \" ---> \" + t.getScore()) con.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"2 - Bases de Dades Clau-Valor (Redis)"},{"location":"2__bases_de_dades_clauvalor/#2-bases-de-dades-clau-valor","text":"Segurament de tots els tipus de Bases de Dades NoSQL existents, la de m\u00e9s f\u00e0cil comprensi\u00f3 \u00e9s la Base de Dades Clau-Valor . En ella s'aniran guardant parelles clau-valor, \u00e9s a dir, el nom d'una determinada propietat i el seu valor. La clau ha de ser \u00fanica, \u00e9s a dir, no es pot repetir ja que en cas contrari no es podria tornar a recuperar. Per tant no hi ha definici\u00f3 de taules ni cap altra estructura; es van guardant parelles clau-valor i prou. En el moment de recuperar la informaci\u00f3 veurem que podrem obtenir el contingut d'una clau, o el de m\u00e9s d'una al mateix temps. L'exemple que veurem de Base de Dades Clau-Valor \u00e9s Redis , molt famosa per a seua pot\u00e8ncia i efici\u00e8ncia. La clau sempre \u00e9s de tipus String, i com ja hem comentat no poden haver dues claus iguals. En Redis els valors poden ser de 5 tipus diferents: Cadenes de car\u00e0cters (String) . Per exemple: nom_1 -- > Albert Mapes (Hashes) que vindria a ser un registre amb subcamps (sub-claus). Per exemple: empleat_1 -- > [ nom=\"Albert\" , departament=\"10\" , sou=\"1000.0\" ] Llistes (Lists) que s\u00f3n conjunts ordenats de valors. Per exemple: llista_1 -- > { \"Primer\" , \"Segon\" , \"Tercer\" } Conjunts (Sets) s\u00f3n conjunts desordenats de valors. No importa el seu ordre, i de fet ser\u00e0 impredecible l'ordre amb el qual els torna Redis. Per exemple: colors -- > { \"Blau\" , \"Verd\" , \"Roig\" } **** Conjunts Ordenats (Sorted Sets) , que intenten reunir els avantatges dels conjunts, per\u00f2 que seran ordenats. Ja veurem la difer\u00e8ncia entre llistes i conjunts ordenats. Algunes caracter\u00edstiques de Redis s\u00f3n: \u00c9s una arquitectura client-servidor \u00c9s extraordin\u00e0riament eficient quan es pot carregar tota en mem\u00f2ria, encara que si no pot carregar-la tamb\u00e9 funcionar\u00e0 de forma molt r\u00e0pida. I a m\u00e9s mant\u00e9 una sincronitzaci\u00f3 constant a disc per a fer les dades persistents. Aquesta tasca la fa en segon pla, de manera que no afecta al servei. Per a poder suportar ratios de lectura molt alts fa una replicaci\u00f3 master/slave, \u00e9s a dir que pot haver m\u00e9s d'un servidor, i un \u00e9s el que actua de master i els altres s\u00f3n r\u00e8pliques del primer. El slave rep una c\u00f2pia inicial de la Base de Dades sencera. A mida que es van realitzant escriptures en el master, es van enviant a tots els slaves connectats. Els clients es poden connectar als distints servidors, b\u00e9 siga al master o als slaves, sense haver de carregar sempre al master.","title":"2 - Bases de Dades Clau-Valor"},{"location":"2__bases_de_dades_clauvalor/#21-installacio-de-redis","text":"Redis est\u00e0 constru\u00eft per a Linux. Tamb\u00e9 funciona, per\u00f2, des de Windows com veurem una miqueta m\u00e9s avant. Instal\u00b7laci\u00f3 en Linux El lloc des d'on baixar-lo \u00e9s la p\u00e0gina oficial: https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-from-source/ En el moment de fer aquestos apunts, l'\u00faltima versi\u00f3 estable \u00e9s la 7.4.1 . Per obtenir els fitxers font de la darrera versi\u00f3 estable de Redis des del lloc de desc\u00e0rregues de Redis, executeu: wget https://download.redis.io/redis-stable.tar.gz Compilando Redis Suposarem que el fitxer est\u00e0 col\u00b7locat en el lloc on volem que estiga instal\u00b7lat de forma definitiva. Per compilar Redis, primer extrae el fitxer tar, canvia al directori arrel i despr\u00e9s executa make: tar -xzvf redis-stable.tar.gz cd redis-stable make Amb a\u00e7\u00f2 s'haurien d'haver generat els executables, i ja hauria de funcionar. Per a posar en marxa el servidor, quasi que el m\u00e9s c\u00f2mode ser\u00e0 obrir un terminal, situar-nos en el directori redis-stable/src i des d'ahi executar redis-server . Hauria d'eixir una finestra similar a la seg\u00fcent, amb m\u00e9s o menys avisos (observeu que al principi de la imatge est\u00e0n les ordres donades per a executar el servidor). Entre altres coses diu que el servidor est\u00e0 en marxa esperant connexions al port 6379, que \u00e9s el port per defecte de Redis. Aquesta finestra del terminal l'haurem de deixar en marxa. Quan vulguem detenir Redis, senzillament fem ctrl-c , i detindrem l'execuci\u00f3 de forma ordenada (guardant-se les dades no guardades) Podr\u00edem haver executat directament redis-server fent-li doble-clic des d'un explorador d'arxius, per exemple, per\u00f2 aleshores no podr\u00edem parar-lo i en definitiva controlar-lo tan c\u00f2modament. Per a fer una connexi\u00f3 des d'un client, tamb\u00e9 des d'un terminal (un altre) executem redis-cli : Ja ha fet la connexi\u00f3, concretament a localhost (127.0.0.1) i al port 6379, que hav\u00edem quedat que \u00e9s el port per defecte. Comprovem que s\u00ed que funciona. Encara no hi ha dades, perqu\u00e8 l'acabem d'instal\u00b7lar. I recordeu que \u00e9s una Base de Dades clau-valor. Per crear una entrada posarem set clau valor . Per a obtenir-la posarem get clau . En la imatge es pot comprovar: Hem creat una clau anomenada clau_1 amb el valor primera , com es pot comprovar en el moment d'obtenir-la amb get . Si al programa redis-cli no li posem par\u00e0metres, intentar\u00e0 fer una connexi\u00f3 local (localhost). Si volem connectar a un servidor situat en una altra adre\u00e7a, li la posem amb el par\u00e0metre -h adre\u00e7a , per exemple: redis-cli -h 192.168.1.26 Connexi\u00f3 al servidor de l'Institut En el servidor de dades de l'Institut tamb\u00e9 tenim instal\u00b7lat redis. Per\u00f2 per a no tenir accessos no desitjats, cal una autenticaci\u00f3. Senzillament \u00e9s posar el comando auth amb la contrasenya que ja hem utilitzat en altres ocasions: auth ieselcaminas.ad En la seg\u00fcent imatge es veu com s\u00ed que hem pogut connectar Instal\u00b7laci\u00f3 en Windows de 64 bits Encara que Redis est\u00e0 constru\u00eft per a Linux, hi ha versions per a Windows, preferiblement de 64 bits. El lloc on poder baixar els fitxers de Redis per a Windows de 64 bits \u00e9s: https://github.com/MSOpenTech/redis/releases Versi\u00f3 En el moment de fer aquestos apunts, la darreara versi\u00f3 es la 3.0.504. Ens baixem el zip, el descomprimim, i ja ho tindrem disponible (sense fer make ni res). Observeu com en la carpeta resultat de descomprimir ja tenim els executables redis-server i redis-cli que s\u00f3n els que ens interessen: Executem redis-server directament i ja el tindrem en marxa: Executem tamb\u00e9 el redis-cli i el resultat ser\u00e0 el mateix que en Linux.","title":"2.1 - Instal\u00b7laci\u00f3 de Redis"},{"location":"2__bases_de_dades_clauvalor/#22-entron-grafic-redis-insight","text":"Com hem comprovat en el punt anterior, la connexi\u00f3 que fem des del client \u00e9s a trav\u00e9s de consola. Per tant haurem de posar comandos i ens contestar\u00e0 la seua execuci\u00f3. Podem instal\u00b7lar-nos una aplicaci\u00f3 gr\u00e0fica que fa\u00e7a un poc m\u00e9s atractiva la presentaci\u00f3. La instal\u00b7laci\u00f3 d'aquesta eina \u00e9s totalment optativa , no cal que la feu. De fet, ens els exemples que es mostraran en tot el tema nom\u00e9s s'utilitzar\u00e0 el mode consola. \u00c9s completament independent del servidor, i podem instal\u00b7lar-la perfectament sense tenir el servidor, utilitzant-la aleshores per a connectar a un servidor remot. El podem baixar lliurement de la p\u00e0gina oficial redis.io/insight on podrem comprovar que tenim per a totes les plataformes: Instal\u00b7laci\u00f3 en Windows En Windows el que ens baixarem \u00e9s un exe. L'executem (permetent l'execuci\u00f3 quan ho pregunta Windows) i li podem donar a totes les opcions per defecte. Quan l'executem, ens eixir\u00e0 la seg\u00fcent pantalla: Podem comprovar que tenim el bot\u00f3 per a afegir una BD Redis (+ Add Redis database). Per a connectar al servidor local la conexi\u00f3 ser\u00e0 redis://default@127.0.0.1:6379 . En la imatge s'ha fet el test de connexi\u00f3. Per a connectar a un remot, posarem la seua adre\u00e7a. En aquesta imatge es veu com hem connectat perfectament als dos servidors.","title":"2.2 - Entron gr\u00e0fic: Redis Insight"},{"location":"2__bases_de_dades_clauvalor/#23-utilitzacio-de-redis","text":"Anam a veure la utilitzaci\u00f3 de Redis, Ens connectarem com a clients i intentarem fer operacions. Les primeres seran les m\u00e9s senzilles, utilitzant \u00fanicament el tipus de dades String . Posteriorment mirarem com treballar amb les claus: buscar-ne una, veure si existeix, buscar unes quantes, ... Despr\u00e9s ja anirem a pels tipus de dades m\u00e9s complicats: Hash List Set Sorted Set","title":"2.3 - Utilitzaci\u00f3 de Redis"},{"location":"2__bases_de_dades_clauvalor/#221-strings","text":"\u00c9s el tipus de dades m\u00e9s senzill, m\u00e9s b\u00e0sic. Ser\u00e0 una cadena de car\u00e0cters de tipus binary safe en la qual normalment guardarem les habituals cadenes de car\u00e0cters, per\u00f2 que tamb\u00e9 podr\u00edem guardar imatges o objectes serialitzats. La grand\u00e0ria m\u00e0xima \u00e9s de 512Mb. Ara veurem els comandos m\u00e9s habituals que afecten a aquest tipus. Com a norma general, hem de ser conscients que els comandos no s\u00f3n sensibles a maj\u00fascules o min\u00fascules, per\u00f2 les claus i els valors s\u00ed que ho s\u00f3n. \u00c9s a dir, el comando get tamb\u00e9 es pot escriure GET o Get . Per\u00f2 la clau Hola \u00e9s diferent de la clau hola .","title":"2.2.1 - Strings"},{"location":"2__bases_de_dades_clauvalor/#get","text":"Sintaxi get clau Torna el valor de la clau especificada, sempre que siga de tipus String . Si la clau \u00e9s d'un altre tipus, donar\u00e0 error. I si la clau no existeix, tornar\u00e0 el valor especial nil . Exemples 127.0.0.1:6379> get clau_1 \"primera\" 127.0.0.1:6379> get clau_2 (nil)","title":"GET"},{"location":"2__bases_de_dades_clauvalor/#set","text":"Sintaxi set clau valor Assigna a la clau especificada com a primer par\u00e0metre el valor especificat com a segon par\u00e0metre. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Redis sempre guardar\u00e0 el valor com a string, encara que nosaltres pensem que li passem un valor enter o real. I una altra caracter\u00edstica \u00e9s que si la clau existeix ja, matxacar\u00e0 el seu contingut, com era de esperar. Exemples 127.0.0.1:6379> set clau_2 segona OK 127.0.0.1:6379> set text \"Un text amb m\u00e9s d'una paraula\" OK 127.0.0.1:6379> set quatre 4 OK 127.0.0.1:6379> get quatre \"4\" 127.0.0.1:6379> set pi 3.14159265359 OK 127.0.0.1:6379> get pi \"3.14159265359\" Nota Si poseu algun accent, en tornar el valor (fent get) us semblar\u00e0 que no s'ha guardat b\u00e9. S\u00ed que s'haur\u00e0 guardat b\u00e9, el que passa \u00e9s que posteriorment no es visualitza b\u00e9 en fer el get. Es pot comprovar entrant en el client amb l'opci\u00f3 raw , \u00e9s a dir redis-cli --raw El comando SET t\u00e9 una opci\u00f3 molt interessant, que servir\u00e0 per a donar un temps de vida a la clau, transcorregut el qual desapareix la clau (amb el seu valor clar). A\u00e7\u00f2 s'anomena temps d'expiraci\u00f3 i s'aconsegueix amb el par\u00e0metre EX del comando SET seguit del n\u00famero de segons que volem que dure la clau. Exemples 127.0.0.1:6379> set clau_3 tercera ex 10 OK 127.0.0.1:6379> get clau_3 \"tercera\" 127.0.0.1:6379> get clau_3 (nil) Primer s\u00ed que existeix, per\u00f2 al cap de 10 segons ha deixat d'existir. De forma equivalent es pot expressar el temps en milisegons, amb el par\u00e0metre PX en compte de EX . Hav\u00edem comentat al principi, que si en el moment de fer el SET la clau ja existia, es reempla\u00e7ar\u00e0 el seu contingut. Podem modificar aquest comportament amb el par\u00e0metre NX (Not eXists): si no existia la clau, la crear\u00e0 amb el valor, per\u00f2 si ja existia, la deixar\u00e0 com estava. Ens ho indicar\u00e0 dient OK en cas de crear-la i NIL en cas de no crear-la perqu\u00e0 ja existia. 127.0.0.1:6379> set clau_4 quarta nx OK 127.0.0.1:6379> set clau_1 quarta nx (nil) 127.0.0.1:6379> get clau_4 \"quarta\" 127.0.0.1:6379> get clau_1 \"primera\" I de forma inversa, si posem el par\u00e0metre XX , si ja existeix la clau, reempla\u00e7ar\u00e0 el valor, per\u00f2 si no existia, no far\u00e0 res.","title":"SET"},{"location":"2__bases_de_dades_clauvalor/#setex","text":"Sintaxi setex clau segons valor Funciona igual que el SET amb el par\u00e0metre EX : crear\u00e0 la clau amb el valor, per\u00f2 tindr\u00e0 una exist\u00e8ncia dels segons indicats.","title":"SETEX"},{"location":"2__bases_de_dades_clauvalor/#psetex","text":"Sintaxi psetex clau milisegons valor Funciona igual que l'anterior, per\u00f2 el que especifiquem s\u00f3n els milisegons d'exist\u00e8ncia.","title":"PSETEX"},{"location":"2__bases_de_dades_clauvalor/#mget","text":"Sintaxi mget clau1 clau2 clauN Torna una llista de valors, els de les claus indicades. Exemples 127.0.0.1:6379> set mes1 gener OK 127.0.0.1:6379> set mes2 febrer OK 127.0.0.1:6379> set mes3 mar\u00e7 OK 127.0.0.1:6379> mget mes1 mes2 mes3 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" Nota Recordeu que els car\u00e0cters com vocals accentuades, \u00e7, \u00f1, ... s'han introdu\u00eft b\u00e9, per\u00f2 potser no es visualiten b\u00e9. Es pot evitar entrant en el client d'aquesta manera redis-cli --raw Si alguna de les claus no exiteix, tornar\u00e0 nil en el seu lloc","title":"MGET"},{"location":"2__bases_de_dades_clauvalor/#mset","text":"Sintaxi mset clau1 valor1 clau2 valor2 clauN valorN Assigna els valors corresponents a les claus. \u00c9s una operaci\u00f3 at\u00f2mica: es posen (o canvien) tots els valors a l'hora. 127.0.0.1:6379> mset mes4 abril mes5 maig mes6 juny mes7 juliol OK 127.0.0.1:6379> mget mes1 mes2 mes3 mes4 mes5 mes6 mes7 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" 4) \"abril\" 5) \"maig\" 6) \"juny\" 7) \"juliol\" Si no vulgu\u00e9rem reempla\u00e7ar valors, podr\u00edem utilitzar el comando MSETNX , totalment equivalent, per\u00f2 haur\u00edem de tenir en compte que si alguna ja existeix i per tant no pot canviar el valor, no faria l'operaci\u00f3, \u00e9s a dir, tampoc crearia les altres.","title":"MSET"},{"location":"2__bases_de_dades_clauvalor/#append","text":"Sintaxi append clau1 valor1 Si la clau no existeix la crea assignant-li el valor (com el SET ), per\u00f2 si ja existeix, concatena el valor al final de la cadena que ja hi havia. 127.0.0.1:6379> append salutacio Hola (integer) 4 127.0.0.1:6379> get salutacio \"Hola\" 127.0.0.1:6379> append salutacio \", com va?\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola, com va?\"","title":"APPEND"},{"location":"2__bases_de_dades_clauvalor/#strlen","text":"Sintaxi strlen clau1 Torna el n\u00famero de car\u00e0cters que hi ha en el valor de la clau. Si la clau no existeix, tornar\u00e0 0. Si la clau \u00e9s d'un altre tipus, tornar\u00e0 error. 127.0.0.1:6379> strlen salutacio (integer) 13 127.0.0.1:6379> strlen sal (integer) 0","title":"STRLEN"},{"location":"2__bases_de_dades_clauvalor/#getrange","text":"Sintaxi getrange clau1 inici final Extrau una subcadena del valor de la clau (ha de ser de tipus String ) des del n\u00famero de car\u00e0cter d'inici fins al n\u00famero del final (ambd\u00f3s inclosos). El primer car\u00e0cter \u00e9s el 0. Si posem de final un n\u00famero major que l'\u00faltim, igual ho traur\u00e0 fins el final. Es poden posar tamb\u00e9 valor negatius que ens ajuden a agafar la cadena des del final. El -1 \u00e9s l'\u00faltim car\u00e0cter, el -2 el pen\u00faltim, ... I es poden barrejar n\u00fameros positius i negatius. Aix\u00ed el rang 0 -1 \u00e9s tota la cadena. 127.0.0.1:6379> getrange salutacio 1 3 \"ola\" 127.0.0.1:6379> getrange salutacio 6 50 \"com va?\" 127.0.0.1:6379> getrange salutacio 6 -1 \"com va?\" 127.0.0.1:6379> getrange salutacio -7 -5 \"com\"","title":"GETRANGE"},{"location":"2__bases_de_dades_clauvalor/#setrange","text":"Sintaxi setrange clau1 despla\u00e7ament valor Substitueix part del valor de la cadena, a partir del despla\u00e7ament, amb el vaolr proporcionat. No s'admenten en despla\u00e7ament valors negatius. 127.0.0.1:6379> get salutacio \"Hola, com va?\" 127.0.0.1:6379> setrange salutacio 4 \". C\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola. Com va?\"","title":"SETRANGE"},{"location":"2__bases_de_dades_clauvalor/#incr","text":"Sintaxi incr clau1 A pesar de que Redis guarda els strings com a tals, com a cadenes de car\u00e0cters, en algunes ocasions \u00e9s capa\u00e7 de transformar la cadena a un n\u00famero. \u00c9s el cas del comando INCR , que converteix la cadena en un enter (si pot) i incrementa aquest valor en una unitat. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 1. Si el valor de la clau no era un n\u00famero enter, donar\u00e0 un error. 127.0.0.1:6379> set compt1 20 OK 127.0.0.1:6379> get compt1 \"20\" 127.0.0.1:6379> incr compt1 (integer) 21 127.0.0.1:6379> get compt1 \"21\" 127.0.0.1:6379> incr compt2 (integer) 1 127.0.0.1:6379> get compt2 \"1\" 127.0.0.1:6379> incr clau_1 (error) ERR value is not an integer or out of range 127.0.0.1:6379> set compt3 4.25 OK 127.0.0.1:6379> incr compt3 (error) ERR value is not an integer or out of range","title":"INCR"},{"location":"2__bases_de_dades_clauvalor/#decr","text":"Sintaxi decr clau1 Decrementa en una unitat el valor de la clau (senpre que siga un enter). Pot agafar valors negatius. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 -1. 127.0.0.1:6379> decr compt2 (integer) 0 127.0.0.1:6379> decr compt2 (integer) -1 127.0.0.1:6379> get compt2 \"-1\"","title":"DECR"},{"location":"2__bases_de_dades_clauvalor/#incrby","text":"Sintaxi incrby clau1 increment Incrementa el valor de la clau en el n\u00famero d'unitats indicat en increment (el valor ha de ser enter). L'increment pot ser negatiu. 127.0.0.1:6379> incrby compt1 10 (integer) 31 127.0.0.1:6379> incrby compt1 -20 (integer) 11","title":"INCRBY"},{"location":"2__bases_de_dades_clauvalor/#decrby","text":"Sintaxi decrby clau1 decrement Decrementa el valor de la clau el n\u00famero d'unitat indicat en decrement . 127.0.0.1:6379> decrby compt1 5 (integer) 6","title":"DECRBY"},{"location":"2__bases_de_dades_clauvalor/#222-keys","text":"Ara anem a veure comandos que ens permeten treballar amb les claus, per a buscar-les, veure si existeixen, etc. No importar\u00e0 el tipus de les claus (de moment nom\u00e9s hem treballat amb claus de tipus String , per\u00f2 si ja en tingu\u00e9rem dels altres tipus tamb\u00e9 es veurien afectades). En cap cas d'aquestos comandos accedirem al valor de les claus.","title":"2.2.2 - Keys"},{"location":"2__bases_de_dades_clauvalor/#keys","text":"Sintaxi keys patr\u00f3 Torna totes les claus que coincideixen amb el patr\u00f3. En el patr\u00f3 podem posar car\u00e0cters comod\u00ed: * : equival a 0 o m\u00e9s car\u00e0cters. Per exemple \"Mar*a\" podria tornar \"Mara\", \"Maria\", \"Marta\", \"Margarita\", ... ? : equival exactament a un car\u00e0cter. Per exemple \"Mar?a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Mara\", \"Margarita\", ... [ab] : ser\u00e0 cert si en el lloc corresponent hi ha un dels car\u00e0cters especificats entre els claud\u00e0tors. Per exemple \"Mar[it]a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Marga\" Per a tornar totes les claus utilitzarem **keys *** 127.0.0.1:6379> keys * 1) \"compt3\" 2) \"mes5\" 3) \"mes3\" 4) \"comp3\" 5) \"mes7\" 6) \"mes2\" 1) \"mes6\" 2) \"salutacio\" 3) \"mes4\" 4) \"mes1\" 5) \"clau_1\" 6) \"compt1\" 7) \"compt2\" 127.0.0.1:6379> keys mes? 1) \"mes5\" 2) \"mes3\" 3) \"mes7\" 4) \"mes2\" 5) \"mes6\" 6) \"mes4\" 7) \"mes1\" 127.0.0.1:6379> keys c* 1) \"compt3\" 2) \"comp3\" 3) \"clau_1\" 4) \"compt1\" 5) \"compt2\" 127.0.0.1:6379> keys mes[125] 1) \"mes5\" 2) \"mes2\" 3) \"mes1\"","title":"KEYS"},{"location":"2__bases_de_dades_clauvalor/#exists","text":"Sintaxi exists clau Torna 1 si la clau existeix, i 0 si no existeix. No importa de quin tipus siga la clau. 127.0.0.1:6379> exists clau_1 (integer) 1 127.0.0.1:6379> exists clau_25 (integer) 0","title":"EXISTS"},{"location":"2__bases_de_dades_clauvalor/#del","text":"Sintaxi del clau1 clau2 clauN Elimina la clau o claus especificades. Si posem m\u00e9s d'una clau i alguna no existeix, la ignorar\u00e0 i s\u00ed que esborrar\u00e0 les altres. 127.0.0.1:6379> del compt2 (integer) 1 127.0.0.1:6379> del mes6 mes7 mes8 mes9 (integer) 2 Observeu que ens indica quantes claus ha esborrat. En el primer exemple ha esborrat la clau especificada, i en el segon diu que ha esborrat 2, que seran mes6 i mes7 , ja que mes8 i mes9 no existien.","title":"DEL"},{"location":"2__bases_de_dades_clauvalor/#type","text":"Sintaxi type clau Torna el tipus de la clau especificada. Els valors possibles s\u00f3n: string hash list set zset (conjunt ordenat) Exemples 127.0.0.1:6379> type clau_1 string","title":"TYPE"},{"location":"2__bases_de_dades_clauvalor/#rename","text":"Sintaxi rename clau novaclau Canvia el nom de la clau a la clau nova, conservant el valor. D\u00f3na error si la clau antiga no existeix. Si la clau nova ja existia reempla\u00e7ar\u00e0 el seu valor. Exemples 127.0.0.1:6379> get salutacio \"Hola. Com va?\" 127.0.0.1:6379> rename salutacio saludar OK 127.0.0.1:6379> get salutacio (nil) 127.0.0.1:6379> get saludar \"Hola. Com va?\" 127.0.0.1:6379> rename clau_22 clau_23 (error) ERR no such key","title":"RENAME"},{"location":"2__bases_de_dades_clauvalor/#renamenx","text":"Sintaxi renamenx clau novaclau Igual que l'anterior per\u00f2 \u00fanicament si la clau nova no existia. Si ja existia no fa res (tornant 0 per a indicar-h0). Exemples 127.0.0.1:6379> renamenx compt1 compt3 (integer) 0 127.0.0.1:6379> get compt1 \"9\" Estem suposant que la clau compt3 ja existeix","title":"RENAMENX"},{"location":"2__bases_de_dades_clauvalor/#expire","text":"Sintaxi expire clau segons Assigna com a temps d'expiraci\u00f3 de la clau els segons especificats. Si ja tenia temps d'expiraci\u00f3, el modifica posant-li aquest valor especificat. En cas que a una clau amb temps d'expiraci\u00f3 li canviem el nom amb RENAME , continuar\u00e0 amb temps d'expiraci\u00f3 que li quedava.","title":"EXPIRE"},{"location":"2__bases_de_dades_clauvalor/#pexpire","text":"Sintaxi pexpire clau milisegons El mateix per\u00f2 en milisegons","title":"PEXPIRE"},{"location":"2__bases_de_dades_clauvalor/#ttl","text":"Sintaxi ttl clau Torna el temps de vida (fins l'expiraci\u00f3) d'una clau. Si la clau no t\u00e9 temps d'expiraci\u00f3, torna -1. Exemples 127.0.0.1:6379> expire compt3 10 (integer) 1 127.0.0.1:6379> ttl compt3 (integer) 6 127.0.0.1:6379> ttl compt3 (integer) 3 127.0.0.1:6379> ttl compt3 (integer) 0 127.0.0.1:6379> get compt3 (nil)","title":"TTL"},{"location":"2__bases_de_dades_clauvalor/#pttl","text":"Sintaxi pttl clau Igual que l'anterior, per\u00f2 ens torna el temps en milisegons.","title":"PTTL"},{"location":"2__bases_de_dades_clauvalor/#persist","text":"Sintaxi persist clau Elimina el temps d'expiraci\u00f3 d'una clau, si \u00e9s que en tenia. Ara la clau no expirar\u00e0 mai. Exemples 127.0.0.1:6379> expire compt1 20 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) 12 127.0.0.1:6379> ttl compt1 (integer) 7 127.0.0.1:6379> persist compt1 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) -1 127.0.0.1:6379> get compt1 \"9\"","title":"PERSIST"},{"location":"2__bases_de_dades_clauvalor/#223-hash","text":"Ja hav\u00edem comentat que el tipus Hash \u00e9s una esp\u00e8cie de registre, amb subcamps (en realitat haur\u00edem de dir sub-claus). Pot tenir qualsevol n\u00famero de subcamps que s\u00f3n de tipus String. Redis \u00e9s molt eficient en quant a l'espai que ocupen els Hash , i sobretot en el temps de recuperaci\u00f3 de les dades. Els comandos que vam veure per al String no es poden aplicar al Hash . Tanmateix els comandos del Hash s\u00f3n molt similars a aquells, comen\u00e7ant sempre per H .","title":"2.2.3 - Hash"},{"location":"2__bases_de_dades_clauvalor/#hset","text":"Sintaxi hset clau camp valor Assigna al camp especificat de la clau especificada el valor especificat. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Si la clau no existia, la crear\u00e0, i si ja existia, senzillament afegir\u00e0 el camp. I si d'aquesta clau ja existia el camp, modificar\u00e0 el seu valor. Evidentment, en claus diferents poden haver camps amb els mateixos noms. Exemples 127.0.0.1:6379> hset empleat_1 nom Andreu (integer) 1 127.0.0.1:6379> hset empleat_1 departament 10 (integer) 1 127.0.0.1:6379> hset empleat_1 sou 1000.0 (integer) 1 127.0.0.1:6379> hset empleat_2 nom Berta (integer) 1 127.0.0.1:6379> hset empleat_2 sou 1500.0 (integer) 1","title":"HSET"},{"location":"2__bases_de_dades_clauvalor/#hget","text":"Sintaxi hget clau camp Torna el valor del camp de la clau. Si no existia (el camp o la clau) torna nil . Nom\u00e9s podem especificar un camp. Exemples 127.0.0.1:6379> hget empleat_1 nom \"Andreu\" 127.0.0.1:6379> hget empleat_1 departament \"10\" 127.0.0.1:6379> hget empleat_2 nom \"Berta\" 127.0.0.1:6379> hget empleat_2 departament (nil)","title":"HGET"},{"location":"2__bases_de_dades_clauvalor/#hgetall","text":"Sintaxi hgetall clau Torna una llista amb tots els camps i els seus valors de la clau. La seq\u00fc\u00e8ncia \u00e9s: camp1 valor1 camp2 valor2 ... Per\u00f2 no ens podem fiar que l'ordre siga el mateix ordre que quan el vam definir. Exemples 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"departament\" 4) \"10\" 5) \"sou\" 6) \"1000.0\"","title":"HGETALL"},{"location":"2__bases_de_dades_clauvalor/#hdel","text":"Sintaxi hdel clau camp1 camp2 campN Elimina el o els camps especificats. Si no existeixen algun d'ells, senzillament l'ignora i si que elimina els altres. Exemples 127.0.0.1:6379> hdel empleat_1 departament (integer) 1 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"sou\" 4) \"1000.0\"","title":"HDEL"},{"location":"2__bases_de_dades_clauvalor/#hkeys","text":"Sintaxi hkeys clau Torna una llista amb els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hkeys empleat_1 1) \"nom\" 2) \"sou\"","title":"HKEYS"},{"location":"2__bases_de_dades_clauvalor/#hvals","text":"Sintaxi hvals clau Torna una llista amb els valors (\u00fanicament els valors) de tots els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hvals empleat_1 1) \"Andreu\" 2) \"1000.0\"","title":"HVALS"},{"location":"2__bases_de_dades_clauvalor/#altres-comandos","text":"Tamb\u00e9 existeixen altres comandos, de funcionament com cabria esperar (els hem vist tots en el cas de String ): hmget : Torna m\u00e9s d'un camp de la clau hmset : assigna m\u00e9s d'un camp a una clau hexists : indica si existeix el subcamp de la clau hsetnx : assigna \u00fanicament en cas de que no existisca el camp. hincrby : incrementa el camp de la clau","title":"Altres Comandos"},{"location":"2__bases_de_dades_clauvalor/#224-list","text":"Les Llistes en Redis s\u00f3n llistes de Strings ordenades, on cada element est\u00e0 associat a un \u00edndex de la llista. Es poden recuperar els elements tant de forma ordenada (per l'\u00edndex) com accedint directament a una posici\u00f3. Els elements es poden afegir al principi, al final o tamb\u00e9 en una posici\u00f3 determinada. La llista es crea en el moment en qu\u00e8 s'insereix el primer element, i desapareix quan llevem l'\u00faltim element que quede. Estan molt ben optimitzades per a la inserci\u00f3 i per a la consulta. Els comandos que afecten a les llistes comencen quasi tots per L , excepte alguns que comencen per R indicant que fan l'operaci\u00f3 per la dreta. Els valors dels elements es poden repetir.","title":"2.2.4 - List"},{"location":"2__bases_de_dades_clauvalor/#lpush","text":"Sintaxi lpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en la primera posici\u00f3, o tamb\u00e9 podr\u00edem dir que per l'esquerra ( Left PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. Si posem m\u00e9s d'un valor, s'aniran introduint sempre en la primera posici\u00f3. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> lpush llista1 primera segona tercera (integer) 3 127.0.0.1:6379> lrange llista1 0 -1 1) \"tercera\" 2) \"segona\" 3) \"primera\" 127.0.0.1:6379> lpush llista1 quarta cinquena (integer) 5 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" Nota Per a veure el contingut de la llista utilitzarem el comando lrange llista 0 -1 , que torna la llista sencera. Veurem de forma m\u00e9s completa aquest comando amb posterioritat.","title":"LPUSH"},{"location":"2__bases_de_dades_clauvalor/#rpush","text":"Sintaxi rpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en l'\u00faltima posici\u00f3, o tamb\u00e9 podr\u00edem dir que per la dreta ( Right PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> rpush llista1 sisena setena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" 6) \"sisena\" 7) \"setena\"","title":"RPUSH"},{"location":"2__bases_de_dades_clauvalor/#lpop","text":"Sintaxi lpop clau Torna i elimina el primer element (el de m\u00e9s a l'esquerra). Exemples 127.0.0.1:6379> lpop llista1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\" 6) \"setena\"","title":"LPOP"},{"location":"2__bases_de_dades_clauvalor/#rpop","text":"Sintaxi rpop clau Torna i elimina l'\u00faltim element (el de m\u00e9s a la dreta). Exemples 127.0.0.1:6379> rpop llista1 \"setena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\"","title":"RPOP"},{"location":"2__bases_de_dades_clauvalor/#lset","text":"Sintaxi lset clau index valor Substitueix el valor de la posici\u00f3 indicada per l'\u00edndex. Tant la clau com l'element de la posici\u00f3 indicada han d'existir, sin\u00f3 donar\u00e0 error. Ara la L no significa Left sin\u00f3 List . La primera posici\u00f3 \u00e9s la 0. I tamb\u00e9 es poden posar n\u00fameros negatius: -1 \u00e9s l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lset llista1 2 quarta OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 127.0.0.1:6379> lset llista1 -1 cinquena OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" Observeu com es poden repetir els valors","title":"LSET"},{"location":"2__bases_de_dades_clauvalor/#lindex","text":"Sintaxi lindex clau index Torna l'element situat en la posici\u00f3 indicada per l'\u00edndex, per\u00f2 sense eliminar-lo de la llista . Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> lindex llista1 0 \"quarta\" 127.0.0.1:6379> lindex llista1 3 \"primera\" 127.0.0.1:6379> lindex llista1 -1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\"","title":"LINDEX"},{"location":"2__bases_de_dades_clauvalor/#linsert","text":"Sintaxi linsert clau BEFORE | AFTER valor1 valor2 Insereix el valor2 abans o despr\u00e9s (segons el que triem) de la primera vegada que troba el valor1. No substitueix, sin\u00f3 que insereix en una determinada posici\u00f3. Els elements que van despr\u00e9s de l'element introdu\u00eft veuran actualitzat el seu \u00edndex. Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> linsert llista1 AFTER quarta segona (integer) 6 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"cinquena\" 127.0.0.1:6379> linsert llista1 BEFORE cinquena sisena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 Si intentem inserir abans o despr\u00e9s un element que no existeix, tornar\u00e0 -1 indicant que no l'ha trobat i no far\u00e0 la inserci\u00f3. 127.0.0.1:6379> linsert llista1 BEFORE desena setena (integer) -1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\"","title":"LINSERT"},{"location":"2__bases_de_dades_clauvalor/#lrange","text":"Sintaxi lrange clau inici final Torna els elements de la llista inclosos entre els index inici i final, ambd\u00f3s inclosos. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 2 4 1) \"tercera\" 2) \"quarta\" 3) \"primera\" 127.0.0.1:6379> lrange llista1 1 -2 4) \"segona\" 5) \"tercera\" 6) \"quarta\" 7) \"primera\" 8) \"sisena\" 127.0.0.1:6379> lrange llista1 4 4 1) \"primera\"","title":"LRANGE"},{"location":"2__bases_de_dades_clauvalor/#llen","text":"Sintaxi llen clau Torna el n\u00famero d'elements de la llista Exemples 127.0.0.1:6379> llen llista1 (integer) 7","title":"LLEN"},{"location":"2__bases_de_dades_clauvalor/#lrem","text":"Sintaxi lrem clau n\u00famero valor Elimina elements de la llista que coincidisquen amb el valor proporcionat. Ja sabem que els valors es poden repetir. Amb el n\u00famero indiquem quants elements volem que s'esborrencomen\u00e7ant per l'esquerra: si posem 1 s'esborrar\u00e0 el primer element amb aquest valor, si posem 2 s'esborraran els dos primers elements (els de m\u00e9s a l'esquerra) que tingen aquest valor. Si posem 0 s'esborraran tots els elements amb aquest valor Exemples 127.0.0.1:6379> rpush llista1 segona (integer) 8 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 8) \"segona\" 127.0.0.1:6379> lrem llista1 1 segona (integer) 1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 6) \"cinquena\" 7) \"segona\" 127.0.0.1:6379> lrem llista1 0 quarta (integer) 2 127.0.0.1:6379> lrange llista1 0 -1 8) \"tercera\" 9) \"primera\" 10) \"sisena\" 11) \"cinquena\" 12) \"segona\"","title":"LREM"},{"location":"2__bases_de_dades_clauvalor/#ltrim","text":"Sintaxi ltrim clau inici final Elimina els elements que queden fora dels \u00edndex inici i final, \u00e9s a dir elimina els que estiguen a l'esquerra d'inici, i els que estiguen a la dreta de final. Exemples 127.0.0.1:6379> ltrim llista1 1 -2 OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"primera\" 2) \"sisena\" 3) \"cinquena\"","title":"LTRIM"},{"location":"2__bases_de_dades_clauvalor/#225-set","text":"Els Sets de Redis s\u00f3n conjunts de valors de tipus String no ordenats. Podrem afegir, actualitzar i esborrar aquestos elements de forma c\u00f2moda i eficient. No es permetran els valors duplicats. A m\u00e9s Redis ens ofereix operacions interessants com la uni\u00f3, intersecci\u00f3 i difer\u00e8ncia de conjunts. Com sempre, els comandos s\u00f3n espec\u00edfics, \u00e9s a dir no ens valen els de Strings, List o Hash. Tots els comandos comencen per S .","title":"2.2.5 - Set"},{"location":"2__bases_de_dades_clauvalor/#sadd","text":"Sintaxi sadd clau valor1 valor2 valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari). Recordem que l'ordre no \u00e9s important, i que no es poden repetir els valors; si intentem introduir un repetit, no donar\u00e0 error, per\u00f2 no l'introduir\u00e0. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> sadd colors roig verd blau (integer) 3 127.0.0.1:6379> sadd colors verd groc (integer) 1","title":"SADD"},{"location":"2__bases_de_dades_clauvalor/#smembers","text":"Sintaxi smembers clau Torna tots els valors del conjunt. Si la clau no existeix tornar\u00e0 un conjunt buit. Recordeu que l'ordre dels elements no \u00e9s predecible Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"verd\" 3) \"roig\" 4) \"blau\"","title":"SMEMBERS"},{"location":"2__bases_de_dades_clauvalor/#sismember","text":"Sintaxi sismember clau valor Comprova si el valor est\u00e0 en el conjunt, tornant 1 en cas afirmatiu i 0 en cas negatiu. Exemples 127.0.0.1:6379> sismember colors verd (integer) 1 127.0.0.1:6379> sismember colors negre (integer) 0","title":"SISMEMBER"},{"location":"2__bases_de_dades_clauvalor/#scard","text":"Sintaxi sard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt en l'actualitat. Exemples 127.0.0.1:6379> scard colors (integer) 4","title":"SCARD"},{"location":"2__bases_de_dades_clauvalor/#srem","text":"Sintaxi srem clau valor1 valor2 valorN Elimina els valors del conjunt. Si el conjunt es queda buit, eliminar\u00e0 la clau tamb\u00e9. Si algun dels valor no \u00e9s cap element del conjunt, senzillament s'ignorar\u00e0. El comando torna el n\u00famero d'elements realment eliminat. Exemples 127.0.0.1:6379> srem colors verd negre (integer) 1 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\"","title":"SREM"},{"location":"2__bases_de_dades_clauvalor/#spop","text":"Sintaxi spop clau Torna i elimina un valor aleatori del conjunt. Recordeu que a m\u00e9s de tornar- lo, l'elimina del conjunt. Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> spop colors \"groc\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\"","title":"SPOP"},{"location":"2__bases_de_dades_clauvalor/#srandmember","text":"Sintaxi srandmember clau Molt paregut a l'anterior. Torna un valor aleatori del conjunt, per\u00f2 en aquesta ocasi\u00f3 no l'elimina del conjunt. Exemples 127.0.0.1:6379> srandmember colors \"blau\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\"","title":"SRANDMEMBER"},{"location":"2__bases_de_dades_clauvalor/#sunion","text":"Sintaxi sunion clau1 clau2 clauN Torna la uni\u00f3 dels elements dels conjunts especificats. \u00c9s una uni\u00f3 correcta, \u00e9s a dir, no es repetir\u00e0 cap valor. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> sadd colors1 verd roig groc (integer) 3 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunion colors colors1 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\"","title":"SUNION"},{"location":"2__bases_de_dades_clauvalor/#sunionstore","text":"Sintaxi sunionstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la uni\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunionstore colors2 colors colors1 (integer) 4 127.0.0.1:6379> smembers colors2 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\"","title":"SUNIONSTORE"},{"location":"2__bases_de_dades_clauvalor/#sdiff","text":"Sintaxi sdiff clau1 clau2 clauN Torna la difer\u00e8ncia dels elements del primer conjunt respecte de la uni\u00f3 de tots els altres. \u00c9s a dir, torna els elements del primer conjunt que no pertanyen acap dels altres. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiff colors1 colors 1) \"verd\" 2) \"groc\"","title":"SDIFF"},{"location":"2__bases_de_dades_clauvalor/#sdiffstore","text":"Sintaxi sdiffstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la difer\u00e8ncia en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiffstore colors3 colors1 colors (integer) 2 127.0.0.1:6379> smembers colors3 1) \"verd\" 2) \"groc\"","title":"SDIFFSTORE"},{"location":"2__bases_de_dades_clauvalor/#sinter","text":"Sintaxi sinter clau1 clau2 clauN Torna la intersecci\u00f3 dels elements dels conjunts. \u00c9s a dir, torna els elements que pertanyen a tots els conjunts especificats. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sinter colors colors1 1) \"roig\"","title":"SINTER"},{"location":"2__bases_de_dades_clauvalor/#sinterstore","text":"Sintaxi sinterstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la intersecci\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 3) \"groc\" 4) \"roig\" 5) \"verd\" 127.0.0.1:6379> sinterstore colors4 colors colors1 (integer) 1 127.0.0.1:6379> smembers colors4 6) \"roig\"","title":"SINTERSTORE"},{"location":"2__bases_de_dades_clauvalor/#smove","text":"Sintaxi smove clau_font clau_dest\u00ed valor Meneja el valor del conjunt or\u00edgen (el primer conjunt) al conjunt dest\u00ed (el segon). Aix\u00f2 suposar\u00e0 eliminar-lo del primer i afegir-lo al segon. Tornar\u00e0 1 si l'ha menejat, i 0 si no l'ha menejat. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> smove colors1 colors verd (integer) 1 127.0.0.1:6379> smembers colors 1) \"verd\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\"","title":"SMOVE"},{"location":"2__bases_de_dades_clauvalor/#226-set-ordenat","text":"Els Sets Ordenats ( Sorted Set ) de Redis s\u00f3n Sets que a m\u00e9s de guardar els valors, guarden tamb\u00e9 una puntuaci\u00f3 ( score ) per a cada valor, i Redis mantindr\u00e0 el conjunt ordenat per aquesta puntuaci\u00f3. Els valors no es podran repetir, per\u00f2 s\u00ed les puntuacions. Molts dels comandos seran iguals que els del Set , ja que un conjunt ordenat no deixa de ser un conjunt, per\u00f2 amb la informaci\u00f3 de la puntuaci\u00f3. En aquesta ocasi\u00f3 comen\u00e7aran per Z","title":"2.2.6 - Set ordenat"},{"location":"2__bases_de_dades_clauvalor/#zadd","text":"Sintaxi zadd clau puntuaci\u00f31 valor1 puntuaci\u00f32 valor2 puntuaci\u00f3N valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari) amb les puntuacions corresponents. Les puntuacions seran Strings de valors reals (float). No es poden repetir els valors, per\u00f2 s\u00ed les puntuacions. Si intentem introduir un valor repetit, el que far\u00e0 ser\u00e0 actualitzar la puntuaci\u00f3. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> zadd puntuacions 1 Nom1 2 Nom2 5 Nom3 4 Nom4 (integer) 4 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\"","title":"ZADD"},{"location":"2__bases_de_dades_clauvalor/#zcard","text":"Sintaxi zcard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt ordenat en l'actualitat. Exemples 127.0.0.1:6379> zcard puntuacions (integer) 4","title":"ZCARD"},{"location":"2__bases_de_dades_clauvalor/#zscore","text":"Sintaxi zscore clau valor Torna la puntuaci\u00f3 (score) del valor especificat del conjunt ordenat. Si no existeix el valor o no existaix la clao, torna nil. Exemples 127.0.0.1:6379> zscore puntuacions Nom3 \"5\" 127.0.0.1:6379> zscore puntuacions Nom7 (nil)","title":"ZSCORE"},{"location":"2__bases_de_dades_clauvalor/#zcount","text":"Sintaxi zcount clau min max Torna el n\u00famero de valors que estan entre les puntuacions especificades (ambdues incloses). Exemples 127.0.0.1:6379> zcount puntuacions 2 5 (integer) 3","title":"ZCOUNT"},{"location":"2__bases_de_dades_clauvalor/#zrange","text":"Sintaxi zrange clau inici final [withscores] Torna els elements del conjunt ordenat inclosos entre els index inici i final, ambd\u00f3s inclosos. I es trauen per ordre ascentent de puntuaci\u00f3. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element Exemples 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom1\" 2) \"1\" 3) \"Nom2\" 4) \"2\" 5) \"Nom4\" 6) \"4\" 7) \"Nom3\" 8) \"5\" Si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGE ( reverse range ). 127.0.0.1:6379> zrevrange puntuacions 0 -1 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\" 7) \"Nom1\" 8) \"1\"","title":"ZRANGE"},{"location":"2__bases_de_dades_clauvalor/#zrangebyscore","text":"Sintaxi zrangebyscore clau min max [withscores] Torna els elements del conjunt ordenat que tenen una puntuaci\u00f3 compresa entre min i max (ambdues incloses). I es trauen per ordre ascentent de puntuaci\u00f3. Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element. **** Exemples 127.0.0.1:6379> zrangebyscore puntuacions 2 5 1) \"Nom2\" 2) \"Nom4\" 3) \"Nom3\" 127.0.0.1:6379> zrangebyscore puntuacions 2 5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\" Si vulgu\u00e9rem que les puntuacions foren estrictament majors que la puntiuaci\u00f3 m\u00ednima i/o estrictament menor que la puntuaci\u00f3 m\u00e0xima, posar\u00edem un par\u00e8ntesi davany de min i/o max : 127.0.0.1:6379> zrangebyscore puntuacions 2 (5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" I si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGEBYSCORE ( reverse range ). Cuideu que com va en ordre invers, ara el valor m\u00e0xim ha de ser el primer, i el m\u00ednim el segon. 127.0.0.1:6379> zrevrangebyscore puntuacions 5 2 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\"","title":"ZRANGEBYSCORE"},{"location":"2__bases_de_dades_clauvalor/#zrank","text":"Sintaxi zrank clau valor Torna el n\u00famero d'ordre de l'element amb el valor especificat. El primer valor \u00e9s el 0. Si no existeix, torna nil . Exemples 127.0.0.1:6379> zrank puntuacions Nom1 (integer) 0 127.0.0.1:6379> zrank puntuacions Nom4 (integer) 2 127.0.0.1:6379> zrank puntuacions Nom7 (nil) Si volem saber el n\u00famero d'ordre per\u00f2 des del final de la llista (en ordre invers), hem d'utilitzar ZREVRANK : 127.0.0.1:6379> zrevrank puntuacions Nom1 (integer) 3 127.0.0.1:6379> zrevrank puntuacions Nom4 (integer) 1","title":"ZRANK"},{"location":"2__bases_de_dades_clauvalor/#zrem","text":"Sintaxi zrem clau valor1 valor2 valorN Elimina els elements amb els valors especificats. Si algun valor no existeix, senzillament l'ignora. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zrem puntuacions Nom1 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\"","title":"ZREM"},{"location":"2__bases_de_dades_clauvalor/#zremrangebyscore","text":"Sintaxi zremrangebyscore clau min max Elimina els elements amb puntuaci\u00f3 compresa entre el m\u00ednim i el m\u00e0xim de forma inclusiva.els valors especificats. Si volem fer-ho de forma excusiva (sense incloure les puntuacions dels extrems) posarem un par\u00e8ntesi avant del m\u00ednim i/o el m\u00e0xim. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zremrangebyscore puntuacions (2 4 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom3\" 4) \"5\"","title":"ZREMRANGEBYSCORE"},{"location":"2__bases_de_dades_clauvalor/#zincrby","text":"Sintaxi zincrby clau increment valor Incrementa la puntuaci\u00f3 de l'element especificat. El valor de la puntuaci\u00f3 a incrementar \u00e9s un n\u00famero real. Torna el valor la puntuaci\u00f3 final de l'element. Si l'element no existia, l'inserir\u00e0, assumint una puntuaci\u00f3 inicial de 0. Exemples 127.0.0.1:6379> zincrby puntuacions 1.5 Nom2 \"3.5\" 127.0.0.1:6379> zincrby puntuacions 2.75 Nom5 \"2.75\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom5\" 2) \"2.75\" 3) \"Nom2\" 4) \"3.5\" 5) \"Nom3\" 6) \"5\"","title":"ZINCRBY"},{"location":"2__bases_de_dades_clauvalor/#24-connexio-des-de-kotlin","text":"La utilitzaci\u00f3 des de Java \u00e9s molt senzilla, i podrem utilitzar tots els comandos que hem vist. Haurem d'incorporar en el projecte una llibreria. Podem utilitzar per exemple la de Jedis (acr\u00f2nim de J ava R edis ). A la seg\u00fcent adre\u00e7a la podeu trobar: https://repo1.maven.org/maven2/redis/clients/jedis/3.5.0/jedis-3.5.0.jar No \u00e9s l'\u00faltima versi\u00f3, per\u00f2 \u00e9s suficient per a nosaltres i \u00e9s molt f\u00e0cil d'utilitzar Per a fer proves, creem un nou projecte anomenat Tema7 , i incorporem la llibreria de Jedis . Creem un paquet anomenat ExemplesRedis , per separar aquestos dels exercicis.","title":"2.4 - Connexi\u00f3 des de Kotlin"},{"location":"2__bases_de_dades_clauvalor/#connexio","text":"La connexi\u00f3 \u00e9s tan senzilla com el seg\u00fcent: val con = Jedis(\"localhost\") con.connect() \u00c9s a dir, obtenim un objecte Jedis passant-li al constructor l'adre\u00e7a del servidor, i despr\u00e9s connectem amb el m\u00e8tode connect . Si el servidor no el tenim en la mateixa m\u00e0quina, nom\u00e9s haurem de substituir localhost per l'adre\u00e7a on estiga el servidor. L'objecte Jedis representar\u00e0 una connexi\u00f3 amb el servidor Redis . Tots els comandos que hem vist per a utilitzar des del client de Redis, seran m\u00e8todes d'aquest objecte. Nom\u00e9s haurem d'anar amb compte amb el que ens torna el servidor quan fem una petici\u00f3. Moltes vegades ser\u00e0 un String , per\u00f2 en moltes altres ocasions seran col\u00b7leccions; sets, lists, ... Per a tancar la connexi\u00f3: con.close()","title":"Connexi\u00f3"},{"location":"2__bases_de_dades_clauvalor/#comandos-que-tornen-strings","text":"Tots els comandos que vam veure seran ara m\u00e8todes de l'objecte Jedis . En concret obtenir el valor d'una clau (comando get clau ) ser\u00e0 el m\u00e8tode get al qual li passarem la clau com a par\u00e0metre: Ac\u00ed tenim ja la primera prova. Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova1.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() println(con.get(\"saludar\")) con.close() } Si volem guardar una clau amb un valor, utilitzarem el m\u00e8tode set(clau,valor) , al qual com veiem li hem de passar els dos par\u00e0metres. Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova2.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val valor = \"Aquesta clau \u00e9s una clau creada des de Kotlin\" con.set(\"clau_Java\", valor) println(con.get(\"clau_Java\")) con.close() }","title":"Comandos que tornen Strings"},{"location":"2__bases_de_dades_clauvalor/#comandos-que-tornen-conjunts","text":"En moltes ocasions, el que ens tornar\u00e0 Redis no \u00e9s un \u00fanic String, sin\u00f3 un conjunt de Strings. A\u00e7\u00f2 ser\u00e0 cert quan treballem amb Sets , per\u00f2 tamb\u00e9 en moltes altres ocasions. Per exemple quan demanem unes quantes claus amb MGET , o quan utilitzem KEYS per a que ens torne les claus que coincideixen amb el patr\u00f3. En algunes ocasions ho haurem d'arreplegar amb un objecte Set , quan no importe l'ordre. En altres ocasions amb un objecte List quan aquest ordre s\u00ed que importe. Per exemple, si volem obtenir amb MGET els valors d'unes quantes claus, s\u00ed que importa l'ordre (el primer valor \u00e9s de la primera clau, el segon de la segona). Aleshores ho obtindrem en un List . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova3.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val c = con.mget(\"mes1\", \"mes2\", \"mes3\") // c ser\u00e0 un MutableList for (s in c) println(s) con.close() } Per\u00f2 en canvi si volem obtenir totes les claus utilitzarem el m\u00e8tode keys passant-li el patr\u00f3 com a par\u00e0metre. L'ordre no importa, i a m\u00e9s no el podem predir. Per tant arreplegarem el resultat amb un Set . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova4.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val c = con.keys(\"*\") //c \u00e9s un MutableSet for (s in c) println(s) con.close() } I evidentment tamb\u00e9 ser\u00e0 el cas quan accedim als tipus de dades List , Set i segurament tamb\u00e9 Hash . Per a accedir a tot el contingut d'un List utilitzem per exemple lrange 0 -1 . Si utilitzem aquest m\u00e8tode de Jedis ens tornar\u00e0 un MutableList . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova5.kt : import redis.clients.jedis.Jedis fun main(){ val con = Jedis(\"localhost\") con.connect() val ll = con.lrange(\"llista1\", 0, -1) // ll \u00e9s un MutableList for (e in ll) println(e) con.close() } Si \u00e9s un Set accedirem amb el m\u00e8tode smembers que tornar\u00e0 un MutableSet . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova6.kt : import redis.clients.jedis.Jedis fun main(){ val con = Jedis(\"localhost\") con.connect() val s = con.smembers(\"colors\") // s \u00e9s un MutableSet for (e in s) println(e) con.close() } I en el cas de Hash , amb el m\u00e8tode hkeys podem obtenir tots els camps (subclaus), i a partir d'ells els seus valors. El que torna hkeys \u00e9s un MutableSet . Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova7.kt : import redis.clients.jedis.Jedis fun main(){ val con = Jedis(\"localhost\") con.connect() val subcamps = con.hkeys(\"empleat_1\") // sucamps \u00e9s un MutableSet for (subcamp in subcamps) System.out.println(subcamp + \": \" + con.hget(\"empleat_1\", subcamp)) con.close() }","title":"Comandos que tornen conjunts"},{"location":"2__bases_de_dades_clauvalor/#tractament-dels-conjunts-ordenats","text":"Els conjunts ordenats ( Sorted Sets ) tenen m\u00e8todes espec\u00edfics, igual que tots els tipus. Alguns d'aquestos m\u00e8todes tornen Strings, i un altres conjunts ( MutableSet ). No hi ha problema amb aquestos tipus, que ja els hem tractat. Per\u00f2 hi ha uns m\u00e8todes que tornen llistes amb m\u00e9s d'un valor per cada element . \u00c9s el cas dels m\u00e8todes ZRANGE (amb les variants ZREVRANGE , ZRANGEBYSCORE i ZREVRANGEBYSCORE ), que tenen la possibilitat de dur el par\u00e0metre WITHSCORES . En aquest cas cada element constar\u00e0 del valor i de la puntuaci\u00f3. El que tornaran els m\u00e8todes \u00e9s un MutableSet de Tuples , objecte proporcionat per Jedis , que disposar\u00e0 dels m\u00e8todes getElement() per al valor i getScore() per a la puntuaci\u00f3. Guardeu el seg\u00fcent codi en un fitxer kotlin anomenat Prova8.kt : import redis.clients.jedis.Jedis fun main() { val con = Jedis(\"localhost\") con.connect() val conjOrd = con.zrangeWithScores(\"puntuacions\", 0, -1) // conjOrd \u00e9s un MutableSet<Tuple> for (t in conjOrd) println(t.getElement() + \" ---> \" + t.getScore()) con.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Tractament dels conjunts ordenats"},{"location":"3__mongodb/","text":"3 - MongoDB Segurament MongoDB \u00e9s el m\u00e9s fam\u00f3s dels Sistemes Gestors de Bases de Dades NoSQL . El nom de MongoDB prov\u00e9 de la paraula anglesa hu mongo us , que significa enorme, que \u00e9s el prop\u00f2sit d'aquesta Base de Dades: guardar grans quantitats d'informaci\u00f3. \u00c9s de codi obert i est\u00e0 programada en C++. El va crear l'empresa 10gen (actualment MongoDB Inc. ) \u00c9s un SGBD Documental , \u00e9s a dir, que servir\u00e0 per a guardar documents. La manera interna de guardar-los \u00e9s en format BSON (Binary JSON) que en ess\u00e8ncia \u00e9s una variant del JSON per a poder guardar f\u00edsicament les dades d'una manera m\u00e9s eficient. En un servidor Mongo poden haver m\u00e9s d'una Base de Dades, encara que nosaltres nom\u00e9s en gastarem una: test . En cada Base de Dades la informaci\u00f3 es guardar\u00e0 en col\u00b7leccions . Cada col\u00b7lecci\u00f3 constar\u00e0 d'uns quants documents . I cada document seran una s\u00e8rie de dades guardades en forma de clau-valor , dels tipus suportats per MongoDB, i amb el format JSON (en realitat BSON) Per tant, en Mongo no hi ha taules. Mirem uns exemples de documents JSON per a guardar la informaci\u00f3 de llibres i autors. Depenen de com s'haja d'accedir a la informaci\u00f3 ens podem plantejar guardar els llibres amb els seus autors, o guardar els autors, amb els seus llibres. Fins i tot ens podr\u00edem guardar els dos, per a poder accedir de totes les maneres, encara que \u00e9s a costa de doblar la informaci\u00f3. De la primera manera, guardant els llibres amb el seu autor, podr\u00edem tenir documents amb aquesta estructura, que es podrien guardar en una col\u00b7lecci\u00f3 anomenada Llibres : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observeu com els objectes no tenen per qu\u00e8 tenir la mateixa estructura. La manera d'accedir al nom d'un autor seria aquesta: objecte.autor.nom Una manera alternativa de guardar la informaci\u00f3, com hav\u00edem comentat abans seria organitzar per autors, amb els seus llibres. D'aquesta manera podr\u00edem anar omplint la col\u00b7lecci\u00f3 Autors amb un o m\u00e9s documents d'aquest estil: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observeu com per a un autor, ara tenim un array ( els claud\u00e0tors: [ ] ) amb els seus llibres. Quina de les dues maneres \u00e9s millor per a guardar la informaci\u00f3? Doncs dep\u00e9n de l'acc\u00e9s que s'haja de fer a les dades. La millor ser\u00e0 segurament aquella que depenent dels accessos que s'hagen de fer, torne la informaci\u00f3 de forma m\u00e9s r\u00e0pida. 3.1 - Estructura JSON Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veja'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes, que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames , que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu 3.2 - Instal\u00b7laci\u00f3 de MongoDB Podrem instal\u00b7lar MongoDB en qualsevol plataforma. I fins i tot sense tenir permisos d'administrador, com veurem en el cas d'Ubuntu. Tamb\u00e9 est\u00e0 la possibilitat de crear un servidor en el n\u00favol, fins i tot gratu\u00eft. \u00c9s l'opci\u00f3 que ens suggereix Mongo per defecte, per\u00f2 nosaltres no la utilitzarem. Instal\u00b7laci\u00f3 en Linux Per a poder fer la instal\u00b7laci\u00f3 m\u00e9s b\u00e0sica, podrem fer-lo sense permisos d'administrador. Si els tenim tot \u00e9s m\u00e9s c\u00f2mode, per\u00f2 si no en tenim tamb\u00e9 ho podem fer, com veurem i remarcarem a continuaci\u00f3. Instal\u00b7laci\u00f3 del servidor (Linux) De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/community ) anem al men\u00fa Products - > Comunity Edition ->Comunity Server i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions. I millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , aquest fitxer \u00e9s: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.0.5.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. Senzillament descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. Per defecte el directori de la Base de Dades \u00e9s /data/db L'\u00fanic problema que podr\u00edem tenir si no som administradors \u00e9s que no tinguem perm\u00eds per crear aquest directori. Aleshores crearem un altre directori i en el moment d'arrancar el servidor, li especificarem aquest lloc. La manera d'arrancar el servidor ser\u00e0: <directori arrel MongoDB>./bin/mongod Opcionalment li podem dir on est\u00e0 la Base de Dades (si no ho especifiquem assumir\u00e0 que est\u00e0 en /data/db ): <directori arrel MongoDB>./bin/mongod --dbpath <directori de la BD> Resumint, i estant situats al directori on hem descomprimit MongoDB: Creem el directori de dades: mkdir /data mkdir /data/db Si no som administradors, arranquem el servidor: ./bin/mongod --dbpath ./data/db Si som administradors, arranquem el servidor: ./bin/mongod La seg\u00fcent imatge il\u00b7lustra aquesta segona opci\u00f3. Est\u00e0 per a una versi\u00f3 anterior de MongoDB, per\u00f2 \u00e9s totalment equivalent: Nota Una vegada en marxa el servidor, no hem de tancar aquesta terminal, ja que parar\u00edem el servidor. Instal\u00b7laci\u00f3 del client MongoShell (Linux) De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/shell ) anem al men\u00fa Products - > Tools ->MongoDB Shell i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions, i millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , triarem l'opi\u00f3 gen\u00e8rica Linux 64 ja que \u00e9s la opci\u00f3 que t\u00e9 el paquet tgz , i aquest fitxer \u00e9s: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. Senzillament descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. Per a connectar un client, obrim una segona terminal i executem el client mongosh : <directori arrel Mongosh>/bin/mongosh ./bin/mongosh Instal\u00b7laci\u00f3 en Windows Instal\u00b7laci\u00f3 del servidor (Windows) No ofereix cap dificultat. Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows, que resultar\u00e0 ser un .msi directament executable. En el moment de fer aquestos apunts, la versi\u00f3 de 64 bits \u00e9s la 8.0.5: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.0.5-signed.msi Com en el cas de Linux, abans d'executar el servidor haurem de tenir el directori creat. Per defecte el directori ser\u00e0 \\data\\db Aqueste serien les ordres per a crear el directori i despr\u00e9s arrancar el servidor. mkdir \\data\\db C:\\Program Files\\MongoDB\\Server\\8.0\\bin\\mongod.exe Hauria d'apar\u00e8ixer la imatge seg\u00fcent Nota Si vas instal\u00b7lar MongoDB amb el MongoDB MSI Installer, normalment el servei ja estar\u00e0 instal\u00b7lat i no caldr\u00e0 executar-lo. Instal\u00b7laci\u00f3 del client MongoShell (Windows) Per a connectar-nos com a clients, ho haurem de fer des d'una altra terminal, amb mongosh.exe , que \u00e9s la interf\u00edcie de l\u00ednia d'ordres (CLI) oficial de MongoDB, utilitzada per interactuar amb la base de dades mitjan\u00e7ant ordres en JavaScript: Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Mongo Compass Tamb\u00e9 us podeu descarregar la versi\u00f3 MongoDB Compass , que \u00e9s l'eina gr\u00e0fica oficial de MongoDB que permet visualitzar, explorar i administrar bases de dades de MongoDB sense necessitat d'utilitzar la l\u00ednia de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe Probar el funcionament Per a provar el seu funcionament, anem a fer un parell de comandos: un per a guardar un document i un altre per a reculerar-lo. Per a qualsevol operaci\u00f3 s'ha de posar db seguit del nom de la col\u00b7lecci\u00f3, i despr\u00e9s l'operaci\u00f3 que volem fer. Amb el sg\u00fcent: db.exemple.insertOne( {msg:\"Hola, qu\u00e8 tal?\"} ) Ens contestar\u00e0: WriteResult({ \"nInserted\" : 1 }) Indicant que ha inserit un document en la col\u00b7lecci\u00f3 exemple (si no estava creada, la crear\u00e0). I amb el seg\u00fcent comando recuperem la informaci\u00f3: db.exemple.find() Que ens tornar\u00e0: { \"_id\" : ObjectId(\"56cc1acd73b559230de8f71b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } Tot ho fa en la mateixa terminal, i a cadasc\u00fa de nosaltres ens donar\u00e0 un n\u00famero diferent en ObjectId . En la seg\u00fcent imatge es veuen les dues operacions: En realitat estem connectats a una Base de Dades anomenada test . Podem crear i utilitzar m\u00e9s d'una Base de Dades, per\u00f2 en aquest curs tindr\u00e9s m\u00e9s que suficient amb aquesta Base de Dades. Per a comprovar-ho podem executar la seg\u00fcent sent\u00e8ncia, que ens torna el nom de la Base de Dades: db.getName() test 3.3 - Utilitzaci\u00f3 de MongoDB Comen\u00e7arem la utilitzaci\u00f3 de MongoDB des de la consola que hav\u00edem arrancat al final de la instal\u00b7laci\u00f3. Recordeu que tindrem dues teminals: Una amb el servidor en marxa (i que no hem de tancar): mongod Una altra amb el client que es connecta al servidor: mongosh En aquesta \u00faltima consola del client podem utilitzar sent\u00e8ncies del llenguatge Javascipt , per\u00f2 el que m\u00e9s ens interessar\u00e0, evidentment, s\u00f3n les sent\u00e8ncies d'acc\u00e9s a dades. Del llenguatge Javascript pr\u00e0cticament l'\u00fanic que utilitzarem s\u00f3n variables i algunes funcions. Utilitzaci\u00f3 de variables Com coment\u00e0vem el que m\u00e9s utilitzarem del llenguatge Javascript \u00e9s la utilitzaci\u00f3 de variables, que ens pot ser molt \u00fatil en algunes ocasions. Podrem utilitzar-les durant la sessi\u00f3, per\u00f2 evidentment no perduraran d'una sessi\u00f3 a l'altra. Per a definir una variable podem posar opcionalment davant la paraula reservada var , per\u00f2 no \u00e9s necessari. Posarem el nom de la variable, el signe igual, i a continuaci\u00f3 el valor de la variable, que pot ser una constant, o una expressi\u00f3 utilitzant constants, operadors, altres variables, funcions de Javascript, ... Especialment interessant s\u00f3n les variables que poden contenir un document JSON. Per exemple: > a = 30 30 > b = a/4 7.5 > Math.sqrt(b) 2.7386127875258306 > doc = {camp1: \"Hola\", camp2: 45, camp3: new Date()} { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\") } > Una variable de tipus JSON es podr\u00e0 modificar molt f\u00e0cilment, tota ella, o algun dels elements. Per a arribar als elements posarem nom_variable.nom_camp : > doc.camp4 = 3.141592 3.141592 > doc.camp5 = [ 2 , 4 , 6 , 8] [ 2, 4, 6, 8 ] I si ara intentem traure el contingut de la variable: > doc { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\"), \"camp4\" : 3.141592, \"camp5\" : [ 2, 4, 6, 8 ] } > Tamb\u00e9 hem de fer constar que en un document, que ser\u00e0 de tipus JSON (pr\u00e0cticament), ser\u00e0 un conjunt de parelles clau-valor, amb algunes restriccions: El document (que moltes vegades l'associarem a objecte de JSON) va entre claus ( { } ) Els elements d'un objecte van separats per comes, i s\u00f3n parelles clau-valor. La clau no pot ser nula, ni repetir-se en el mateix objecte (s\u00ed en diferents objectes, clar) Els valors s\u00f3n dels tipus que veurem en la pregunta 3.2.1 Un document guardat ha de contenir obligat\u00f2riament un camp anomenat _id , i que contindr\u00e0 un valor \u00fanic en la col\u00b7lecci\u00f3 i servir\u00e0 per a identificar-lo. Si en guardar un document no li hem posat camp _id , el generar\u00e0 autom\u00e0ticament MongoDB. 3.3.1 - Tipus de dades Els valors dels elements, \u00e9s a dir de les parelles clau valor, poden ser d'uns quants tipus. Fem un r\u00e0pid rep\u00e0s. En els exemples que van a continuaci\u00f3 definim senzillament parelles clau-valor dels diferents tipus, o en tot cas ens ho guardem en variables, per\u00f2 no guardarem encara en la Base de Dades (ho farem en la seg\u00fcent pregunta). Quan guardem en una variable es mostrar\u00e0 el prompt, la definici\u00f3 de la variable i despr\u00e9s el resultat d'haver guardat la variable. Utilitzarem requadres blancs. Els requadres grocs s\u00f3n \u00fanicament de la definici\u00f3 d'una clau-valor d'un determinat tipus NULL M\u00e9s que un tipus de dades \u00e9s un valor, millor dit, l'abs\u00e8ncia de valor { \"x\" : null } BOOLEAN El tipus boole\u00e0, que pot agafar els valors true o false. { \"x\" : true } { \"y\" : false } NUMBER Per defecte, el tiups de dades num\u00e8rics ser\u00e0 el de coma flotant ( float ), simple precisi\u00f3. Si volem un altre tiups (enter, doble precisi\u00f3, ...) ho haurem d'indicar expressament. Aix\u00ed els dos seg\u00fcents valors s\u00f3n float: { \"x\" : 3.14 } { \"y\" : 3 } Si volem que siga estrictament enter, per exemple, haurem d'utilitzar una funci\u00f3 de conversi\u00f3: { \"x\" : NumberDouble(\"3.14\") } { \"y\" : NumberInt(\"3\") } STRING Es pot guardar qualsevol cadena amb car\u00e0cters de la codificaci\u00f3 UTF-8 { x : \"Hola, qu\u00e8 tal?\"} DATE Es guarda data i hora, i internament es guarden en milisegons des de l'any inicial. No es guarda el Time zone , \u00e9s a dir, la desviaci\u00f3 respecte a l'hora internacional. { x : ISODate(\"2022-01-16T11:15:27.471Z\") } Normalment utilitzarem funcions de tractament de la data-hora. L'anterior era per a convertir el string en data-hora. La seg\u00fcent \u00e9s per a obtenir la data- hora actual: { x : new Date() } \u00c9s a dir, que si no posem par\u00e0metre, ens d\u00f3na la data-hora actual. Per\u00f2 li podem posar com a par\u00e0metre la data-hora que volem que genere. En aquest exemple, nom\u00e9s posem data, per tant l'hora ser\u00e0 les 00:00: > z = new Date(\"2022-01-16\") ISODate(\"2022-01-16T00:00:00Z\") En aquest s\u00ed que posem una determinada hora, i observeu com hem deposar la T (Time) entre el dia i l'hora: > z = new Date(\"2022-02-16T18:00\") ISODate(\"2022-01-16T18:00:00Z\") \u00c9s molt important que posem sempre New Date() per a generar una data-hora. Si posem \u00fanicament Date() , el que estem generant \u00e9s un string (segurament amb la data i hora actual, per\u00f2 un string): > z = Date(\"2022-01-16\") Sun Jan 16 2022 22:20:09 GMT+0100 (CET) ARRAY \u00c9s un conjunt d'elements, cadascun de qualsevol tipus, encara que el m\u00e9s habitual \u00e9s que siguen del mateix tipus. Van entre claud\u00e0tors ( [ ] ) i els elements separats per comes. { x : [ 2 , 4 , 6 , 8 ] } Com coment\u00e0vem, cada element de l'array pot ser de qualsevol tipus: { y : [ 2 , 3.14 , \"Hola\" , new Date() ] } En MongoDB podrem treballar molt b\u00e9 amb arrays, i tindrem operacions per a poder buscar dins de l'array, modificar un element, crear \u00edndex, ... DOCUMENTS (OBJECTES) Els documents poden contenir com a elements uns altres documents ( objectes en la terminologia JSON, per\u00f2 documents en la terminologia de MongoDB). Van entre claus ( { } ), i els elements que contindran van separats per comes i seran parelles clau-valor de qualsevol tipus (fins i tot altres documents). { x : { a : 1 , b : 2 } } Posar documents dins d'uns altres documents (el que s'anomena embedded document ) ens permet guardar la informaci\u00f3 d'una manera m\u00e9s real, no tan plana. Aix\u00ed per exemple, les dades d'una persona les podr\u00edem definir de la seg\u00fcent manera. Les posarem en una variable, per veure despr\u00e9s com podem accedir als diferents elements, encara que el m\u00e9s normal ser\u00e0 guardar-lo en la Base de Dades (amb insert() ). Si copiem el que va a continuaci\u00f3 al terminal de Mongo, ens apareixer\u00e0 amb un format estrany. \u00c9s perqu\u00e8 la sent\u00e8ncia d'assignaci\u00f3 a la variable ocupa m\u00e9s d'una l\u00ednia, i apareixeran 3 punts al principi per a indicar que continua la sent\u00e8ncia. Per\u00f2 funcionar\u00e0 perfectament : doc = { n om : \"Joan Mart\u00ed\" , adre\u00e7a : { carrer : \"Major\" , n \u00famero : 1 , poblaci\u00f3 : \"Castell\u00f3\" } , tel \u00e8 f o ns : [ 964223344 , 678345123 ] } Observeu com aquesta estructura que ha quedat tan clara, segurament en una Base de Dades Relacional ens hauria tocat guardar en 3 taules: la de persones, la d'adreces i la de tel\u00e8fons. Per a accedir als elements d'un document pos\u00e0vem el punt. Doncs el mateix per als elements d'un document dins d'un document. I tamb\u00e9 podem accedir als elements d'un array, posant l'\u00edndex entre claud\u00e0tors. > doc.nom Joan Mart\u00ed > doc.adre\u00e7a { \"carrer\" : \"Major\", \"n\u00famero\" : 1, \"poblaci\u00f3\" : \"Castell\u00f3\" } > doc.adre\u00e7a.carrer Major > doc.tel\u00e8fons [ 964223344, 678345123 ] > doc.tel\u00e8fons[0] 964223344 OBJECT ID \u00c9s un tipus que defineix MongoDB per a poder obtenir valors \u00fanics. \u00c9s el valor per defecte de l'element _id , necessari en tot document (atenci\u00f3: en un document, no en un element de tipus document que hem dit equivalent a l'objecte de JSON). \u00c9s un n\u00famero long, \u00e9s a dir que utilitza 24 bytes. Farem proves de la seua utilitzaci\u00f3 en la se\u00fcent pregunta, en el moment d'inserir diferents documents. 3.3.2 - Operacions b\u00e0siques En aquest punt anem a veure les operacions m\u00e9s b\u00e0siques, per a poder treballar sobre exemples pr\u00e0ctics, i aix\u00ed disposar ja d'unes dades inicials per a practicar. Inserci\u00f3 elemental: insert La funci\u00f3 insert afegir\u00e0 documents a una col\u00b7lecci\u00f3. En el par\u00e0metre posem el document directament, o una variable que continga el document. Si la col\u00b7lecci\u00f3 no existia, la crear\u00e0 i despr\u00e9s afegir\u00e0 el document. En la seg\u00fcent sent\u00e8ncia estem treballant sobre la col\u00b7lecci\u00f3 exemple , que segurament ja existir\u00e0 de quan vam fer la pregunta 3.1 d'instal\u00b7laci\u00f3 de MongoDB, que per a provar vam inserir un document. Per\u00f2 si no existia, la crear\u00e0 sense problemes. > db.exemple.insert({ msg2 : \"Com va la cosa?\"}) WriteResult({ \"nInserted\" : 1 }) Acabem d'inserir un nou document, i aix\u00ed ens ho avisa ( { \"nInserted\" : 1 } , s'ha inserit un document). Autom\u00e0ticament haur\u00e0 creat un element _id de tipus ObjectId , ja que li fa falta per a identificar el document entre tots els altres de la col\u00b7lecci\u00f3. I en aquest exemple ens guardem el document en la variable doc , i despr\u00e9s l'inserim > doc = { msg3 : \"Per ac\u00ed no ens podem queixar ...\"} { \"msg3\" : \"Per ac\u00ed no ens podem queixar ...\" } > db.exemple.insert(doc) WriteResult({ \"nInserted\" : 1 }) Tamb\u00e9 ens indica que ha inserit un document. I haur\u00e0 creat tamb\u00e9 el camp _id com veurem en el seg\u00fcent punt. Lectura: find Tenim dues funcions per a recuperar informaci\u00f3: find i findOne . find() : recuperar\u00e0 tots els documents de la col\u00b7lecci\u00f3, encara que podrem posar criteris per a que ens torne tots els documents que acomplesquen aquestos criteris (ho veurem m\u00e9s avant). findOne() : nom\u00e9s tornar\u00e0 un document, en principi el primer. Pot ser sobre tots els documents (i per tant seria el primer document), o posar una condici\u00f3, i tornaria el primer que acomplir\u00e0 la condici\u00f3. Exemple de find() : > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } { \"_id\" : ObjectId(\"56ce3237c61e04ba81def50d\"), \"msg3\" : \"Per ac\u00ed no ens podem queixar ...\" } > Exemple de findOne() : > db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } > En tots els casos podem comprovar que \u00e9s cert el que ven\u00edem afirmant, que ha creat autom\u00e0ticament l'element _id per a cada document guardat. Evidentment, cadasc\u00fa de nosaltres tindr\u00e0 una valors diferents. Inserci\u00f3 especificant el id Ara que ja sabem consultar els document de la col\u00b7lecci\u00f3 amb find() anem a continuar les insercions de documents, per veure les possibilitats que tenim. En els document que hem inserit fins el moment, no hem especificat el camp _id , i Mongo l'ha generat autom\u00e0ticament de tipus ObjectId . Per\u00f2 nosaltres podrem posar aquest camp _id amb el valor que vulguem. Aix\u00f2 s\u00ed, haurem d'estar segurs que aquest valor no l'agafa cap altre document de la col\u00b7lecci\u00f3, o ens donar\u00e0 un error. Aix\u00ed per exemple anem a inserir la informaci\u00f3 d'uns alumnes. Els posarem en una col\u00b7lecci\u00f3 nova anomenada alumnes , i els intentarem posar un _id personal. Per exemple posarem els n\u00fameros 51, 52, 53, ... > db.alumnes.insert ({_id: 51 , nom: \"Rebeca\" , cognoms: \"Mart\u00ed Peral\"}) WriteResult({ \"nInserted\" : 1 }) Ha anat b\u00e9, i si mirem els documents que tenim en la col\u00b7lecci\u00f3, comprovarem que ens ha respectat el _id : > db.alumnes.find() { \"_id\" : 51, \"nom\" : \"Rebeca\", \"cognoms\" : \"Mart\u00ed Peral\" } > Per\u00f2 si intentem inserir un altre document amb el mateix _id (51), ens donar\u00e0 error: > db.alumnes.insert ({_id: 51 , nom: \"Raquel\" , cognoms: \"Gomis Arnau\"}) WriteResult({ \"nInserted\" : 0, \"writeError\" : { \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: test.alumnes index: _id_ dup key: { : 51.0 }\" } }) > Ens avisa que estem duplicant la clau principal , \u00e9s a dir l'identificador. Inserci\u00f3 m\u00faltiple Quan els documents que volem inserir s\u00f3n senzills, podem inserir m\u00e9s d'un a la vegada, posant dis del insert() un array amb tots els elements. En el seg\u00fcent exemple creem uns quants nombres primers en la col\u00b7lecci\u00f3 del mateix nom: > db.nombresprimers.insert( [ {_id:2} , {_id:3} , {_id:5} , {_id:7} , {_id:11} > , {_id:13} , {_id:17} , {_id:19} ] ) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 8, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) > Ens avisa que ha fet 8 insercions, i ac\u00ed els tenim: > db.nombresprimers.find() { \"_id\" : 2 } { \"_id\" : 3 } { \"_id\" : 5 } { \"_id\" : 7 } { \"_id\" : 11 } { \"_id\" : 13 } { \"_id\" : 17 } { \"_id\" : 19 } > Esborrat: remove Per a esborrar un document d 'una col\u00b7lecci\u00f3 utilitzarem la funci\u00f3 remove , passant-li com a par\u00e0metre la condici\u00f3 del document o documents a esborrar. > db.nombresprimers.remove( {\"_id\" : 19} ) WriteResult({ \"nRemoved\" : 1 }) > Ens avisa que ha esborrat un document. La condici\u00f3 no cal que siga sobre el camp _id . Pot ser sobre qualsevol camp, i esborrar\u00e0 tots els que coincideixen. > db.exemple.remove( {\"msg3\" : \"Per ac\u00ed no ens podem queixar ...\"} ) WriteResult({ \"nRemoved\" : 1 }) > Tamb\u00e9 tenim la possibilitat d'esborrar tota una col\u00b7lecci\u00f3 amb la funci\u00f3 drop() . Pareu atenci\u00f3 perqu\u00e8 \u00e9s molt senzilla d'eliminar, i per tant, potencialment molt perillosa. > db.nombresprimers.drop() true > Actualitzaci\u00f3 - update La funci\u00f3 update servir\u00e0 per a actualitzar un document ja guardat. Tindr\u00e0 dos par\u00e0metres: El primer par\u00e0metre ser\u00e0 la condici\u00f3 per a trobar el document que s'ha d'actualitzar. El segon par\u00e0metre ser\u00e0 el nou document que substituir\u00e0 l'anterior Per exemple, si mirem les dades actuals: > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } Podem comprovar el contingut del segon document, el que te msg2 . Anem a modificar-lo: en el primer par\u00e0metre posem condici\u00f3 de recerca (nom\u00e9s hi haur\u00e0 un) i en el segon posem el nou document que substituir\u00e0 l'anterior > db.exemple.update( {msg2:\"Com va la cosa?\"} , {msg2:\"Qu\u00e8? Com va la cosa?\"}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) Observeu que la contestaci\u00f3 del update () \u00e9s que ha fet match (hi ha hagut coincid\u00e8ncia) amb un document, i que ha modificat un. Si no en troba cap, no donar\u00e0 error, senzillament dir\u00e0 que ha fet match amb 0 documents, i que ha modificat 0 documents. Mirem com efectivament ha canviat el segon document > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Qu\u00e8? Com va la cosa?\" } Ens vindran molt b\u00e9 les variables per a les actualitzacions, ja que en moltes ocasions ser\u00e0 modificar lleugerament el document, canviant o afegint algun element. Ho podrem fer c\u00f2modament amb la variable: primer guardem el document a modificar en una variable; despr\u00e9s modifiquem la variable; i per \u00faltim fem l'operaci\u00f3 d'actualitzaci\u00f3. Evidentment si tenim alguna variable amb el contingut del document ens podr\u00edem estalviar el primer pas. > doc1 = db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } > doc1.titol = \"Missatge 1\" Missatge 1 > db.exemple.update( {msg:\"Hola, qu\u00e8 tal?\"} , doc1) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\", \"titol\" : \"Missatge 1\" } > 3.3.3 - Operacions d'actualitzaci\u00f3 avan\u00e7ada Al final de la pregunta anterior hem vist l'actualitzaci\u00f3 de documents ja existents a la Base de Dades. Aquesta actualitzaci\u00f3 la f\u00e9iem modificant tot el document, encara que tenim la variant de guardar el document en una variable, modificar aquesta variable i despr\u00e9s fer l'actualitzaci\u00f3 amb aquesta variable. Per\u00f2 observeu que continua sent una modificaci\u00f3 de tot el document, una substituci\u00f3 del document antic per un document nou. En aquesta pregunta veurem la utilitzaci\u00f3 d'uns modificadors ( modifiers ) de l'operaci\u00f3 update() , que ens permetran modificar documents de forma potent: creant i eliminant claus (elements) d'un document, o canviant-los, i fins i tot afegir o eliminar elements d'un array. $set El modificador $set assigna un valor a un camp del document seleccionat de la Base de Dades. Si el camp ja existia, modificar\u00e0 el valor, i si no existia el crear\u00e0. La sintaxi del modificador $set \u00e9s la seg\u00fcent: { $set : { clau : valor} } Per\u00f2 recordeu que \u00e9s un modificador, i l'hem d'utilitzar dins d'una operaci\u00f3 d'actualitzaci\u00f3. Anir\u00e0 en el segon par\u00e0metre del update() , i per tant amb aquestos modificadors ja no posem tot el document en el segon par\u00e0metre, sin\u00f3 \u00fanicament l'operador de modificaci\u00f3. Mirem-ho millor en un exemple: > db.alumnes.insert( {nom:\"Abel\", cognoms:\"Bernat Carrera\"} ) WriteResult({ \"nInserted\" : 1 }) > > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\" } > Suposem ara que li volem afegir l'edat. Abans ho far\u00edem guardant el document en una variable, i afegint el camp, per a guardar despr\u00e9s. Ara ho tenim m\u00e9s f\u00e0cil: > db.alumnes.update( {nom:\"Abel\"} , { $set: {edat:21} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) Ha trobat un, i l'ha modificat. Evidentment, si hi haguera m\u00e9s d'un alumne a mb el nom Abel, els modificaria tots. > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 21 } Es pot especificar m\u00e9s d'un camp amb els valor corresponents. Si no existien es crearan, i si ja existien es modificaran: > db.alumnes.update( {nom:\"Abel\"} , { $set: {nota: 8.5 , edat:22} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : 8.5 } I fins i tot es pot canviar el tipus d'un camp determinat, i utilitzar arrays, i objectes, ... > db.alumnes.update( {nom:\"Abel\"} , { $set: {nota: [8.5,7.5,9] , > adre\u00e7a:{carrer:\"Major\",numero:7,cp:\"12001\"} } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12001\" } } Podem fins i tot modificar ara nom\u00e9s el valor d'un camp d'un objecte del document. Per exemple, anem a modificar el codi postal de l'anterior alumne. La manera d'arribar al codi postal ser\u00e0 adre\u00e7a.cp , per\u00f2 haurem d'anar amb compte que vaja entre cometes per a que el trobe: > db.alumnes.update( {nom:\"Abel\"} , { $set: {adre\u00e7a.cp:\"12502\"} } ) uncaught exception: SyntaxError: missing : after property id : @(shell):1:49 > db.alumnes.update( {nom:\"Abel\"} , { $set: {\"adre\u00e7a.cp\":\"12502\"} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } } $unset El modificador $unset servir\u00e0 per a eliminar elements (camps) d'un o uns documents. Si el camp existia, l'eliminar\u00e0, i si no existia, no donar\u00e0 error (avisar\u00e0 que s'han modificat 0 documents). La sintaxi \u00e9s: { $unset : {camp : 1 } } Haurem de posar un valor al camp que anem a esborrar per a mantenir la sintaxi correcta, i posem 1 que equival a true. Tamb\u00e9 podr\u00edem posar -1, que equival a false, per\u00f2 aleshores no l'esborraria, i per tant no far\u00edem res. Sempre posarem 1. Mirem el seg\u00fcent exemple. Afegim un camp, que ser\u00e0 el n\u00famero d'ordre, i despr\u00e9s el llevarem. > db.alumnes.update( {nom:\"Abel\"} , { $set: {num_ordre:10} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"num_ordre\" : 10 } > db.alumnes.update( {nom:\"Abel\"} , { $unset: {num_ordre:1} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.update( {nom:\"Abel\"} , { $unset: {puntuacio:1} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 0 }) Hem afegit primer el camp num_ordre , i hem mostrat el document per comprovar que existeix. Despr\u00e9s esborrem el camp num_ordre (i ens confirma que ha modificat un document). Despr\u00e9s intentem esborrar un camp que no existeix, puntuacio . No d\u00f3na error, per\u00f2 ens avisa que ha modificat 0 documents. Podem comprovar al final com el document ha quedat com esper\u00e0vem. > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } } $rename El modificador $rename canviar\u00e0 el nom d'un camp. Si no existia, no donar\u00e0 error i senzillament no el modificar\u00e0. Hem de cuidar de posar el nou nom del camp entre cometes, per a que no done error. La sintaxi \u00e9s: { $rename : { camp1 : \"nou_nom1\" , camp2 : \"nou_nom2\" , ... } } Per exemple, canviem el nom del camp nota a notes : > db.alumnes.update( {nom:\"Abel\"} , { $rename: {nota:\"notes\"} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"notes\" : [ 8.5, 7.5, 9 ] } Observeu que l'ha canviat de lloc, cosa que ens fa pensar que en canviar de nom un camp, el que fa \u00e9s tornar a crear-lo amb el nou nom, i esborrar el camp antic. En aquest exemple tornem a canviar el nom a nota , i intentem canviar el nom a un camp inexistent, camp1 . No donar\u00e0 error. > db.alumnes.update( {nom:\"Abel\"} , { $rename: {camp1: \"camp2\" , notes:\"nota\"} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 8.5, 7.5, 9 ] } $inc Com cabria esperar, el modificador $inc servir\u00e0 per a incrementar un camp num\u00e8ric. Si el camp existia, l'incrementar\u00e0 en la quantitat indicada. Si no existia, crear\u00e0 el camp amb un valor inicial de 0, i incrementar\u00e0 el valor amb la quantitat indicada. La quantitat pot ser positiva, negativa o fins i tot amb part fraccion\u00e0ria. Sempre funcionar\u00e0 b\u00e9, excepte quan el camp a incrementar no siga num\u00e8ric, que donar\u00e0 error. La sintaxi \u00e9s aquesta: { $inc : {camp : quantitat } } En els seg\u00fcents exemples, incrementem un camp nou (per tant el crear\u00e0 amb el valor especificat), i despr\u00e9s l'incrementem en quantitats positives, negatives i fraccion\u00e0ries, concretament l'inicialitzem amb un 2 , i desp\u00e9s l'incrementem en 5 , en -4 i en 2.25 , per tant el resultat final ser\u00e0 5.25 : > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:2} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 2 } > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:5} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:-4} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:2.25} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 5.25 } Elements d'un array Per a accedir directament a un element d'un array d'un determinat document es pot utilitzar la seg\u00fcent sintaxi: \"array.index\" Hem de tenir present que el primer element de l'array \u00e9s el de sub\u00edndex 0. I no us oblideu de tancar-ho tot entre comentes per a que ho puga trobar. Si no existeix l'element amb el sub\u00edndex indicat, donar\u00e0 error. Per exemple, anem a pujar un punt la primera nota de l'alumne que estem utilitzant en tots els exemples : >db.alumnes.update( {nom:\"Abel\"} , { $inc : { \"nota.0\" : 1 } } ) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] } Inserci\u00f3 en Arrays: $push La manera m\u00e9s senzilla d'introduir un element en un array \u00e9s utilitzar $push sense m\u00e9s. Si existia l'array, introduir\u00e0 el o els nous elements al final. Si no existia l'array, el crear\u00e0 amb aquest o aquestos elements. La sintaxi \u00e9s: { $push : { clau : element } } Per exemple anem a afegir una nota a l'alumne de sempre, i posem-la diferent per veure que s'introdueix al final: > db.alumnes.update( {nom:\"Abel\"} , { $push : { nota : 7 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7 ] } Tamb\u00e9 hi ha manera d'introduir un element en una determinada posici\u00f3 que no siga al final, per\u00f2 es complica prou la cosa, ja que hem d'utilitzar per una banda el modificador $position per a dir on s'ha d'inserir, i per una altra banda el modificador $each per a poder especificar el o els valors que es volen inserir. Es posa a continuaci\u00f3 \u00fanicament de forma il\u00b7lustrativa. Per a inserir en una determinada posici\u00f3 hem d'utilitzar obligat\u00f2riament 2 modificadors m\u00e9s: $position indicar\u00e0 a partir de quina posici\u00f3 es far\u00e0 l'acci\u00f3 (normalment d'inserir en l'array, \u00e9s a dir, $push ) $each ens permet especificar una s\u00e8rie de valors com un array, i vol dir que es far\u00e0 l'operaci\u00f3 per a cada valor de l'array Els dos modificadors seguiran la sintaxi de sempre, de clau valor, per tant el conjunt de la sintaxi \u00e9s: { $ push : { clau_del_array : { $position : _posici\u00f3_ , $each : [ _valors_ ] } } } Ac\u00ed tenim un exemple on introdu\u00efm una nota en la primera posici\u00f3: > db.alumnes.update( {nom:\"Abel\"} , { $push : { nota : { $position : 0 , $each > : [5] } } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] } Eliminaci\u00f3 en arrays: $pop i $pull Hi ha m\u00e9s d'una manera d'eliminar elements d'un array. $pop Si volem eliminar el primer element o l'\u00faltim, el modificador adequat \u00e9s $pop . La sintaxi \u00e9s { $pop : { clau : posicio } } On en posici\u00f3 podrem posar: -1 , i esborrar\u00e0 el primer element 1 , i esborrar\u00e0 l'\u00faltim En els seg\u00fcents exemples s'esborren primer l'\u00faltim element i despr\u00e9s el primer. > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] } > db.alumnes.update( {nom:\"Abel\"} , { $pop : { nota : 1 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9 ] } > db.alumnes.update( {nom:\"Abel\"} , { $pop : { nota : -1 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] } $pull Amb aquest modificador esborrarem els elements de l'array que coincidesquen amb una condici\u00f3, estiguen en la posici\u00f3 que estiguem. Observeu com es pot eliminar m\u00e9s d'un element. Per a poder comprovar-lo b\u00e9, primer inserim un altre element al final de l'array, amb el valor 7.5 (si heu seguit els mateixos exemples que en aquestos apunts, aquest valor ja es troba en la segona posici\u00f3). > db.alumnes.update( {nom:\"Abel\"} , { $push : { nota : 7.5 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7.5 ] } Ara anem a esborrar amb $pull l'element de valor 7.5 > db.alumnes.update( {nom:\"Abel\"} , { $pull : { nota : 7.5 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } Upsert Aquesta paraula ja l'hav\u00edem comentada en un punt anterior. En el update() normal, si la condici\u00f3 de b\u00fasqueda no donava cap resultat (parlant r\u00e0pid, si no feis matching amb cap document), doncs no actualitzava cap document i punt. El Upsert \u00e9s una variant de l'update, que quan no coincidesca cap document amb la condici\u00f3, crear\u00e0 un document nou que ser\u00e0 el resultat de combinar el criteri que s'ha utilitzat en la condici\u00f3 amb les operacions d'actualitzaci\u00f3 fetes en el segon par\u00e0metre Per a que un Update actue d'aquesta manera, li hem de posar un tercer par\u00e0metre amb el valor true : update ( {...} , {...} , true ) Recordeu que el primer par\u00e0metre era la condici\u00f3, i el segon l'actualitzaci\u00f3. Mirem-ho en l'exemple dels alumnes. Si anem a actualitzar els cognoms, i es troba el document, s'actualitzar\u00e0: > db.alumnes.update( { nom:\"Abel\" } , { $set : { cognoms : \"Bernat Cantera\" }} , true ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) Efectivament, ens diu que ha modificat un document. Per\u00f2 si no es troba el document (per exemple perqu\u00e8 li hem posat el nom Berta ): > db.alumnes.update( { nom:\"Berta\" } , { $set : { cognoms : \"Bernat Cantero\" }} , true ) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\") }) Ja ens avisa que no ha fet cap matching , i ha fet un Upsert . Ho podem comprovar mirant tots els document de la col\u00b7lecci\u00f3: > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } > El nou document tindr\u00e0 els camps: _id , amb el que ens havia avisat que generaria Els camps de la condici\u00f3, que en el nostre exemple \u00e9s { nom:\"Berta\" } Els camps de l'actualitzaci\u00f3, que en el nostre exemple eren els cognoms 3.4 - Consulta de documents En la pregunta anterior hem vist com introduir, eliminar i modificar documents. Les consultes de documents han segut molt senzilles, per a comprovar \u00fanicament els resultats. En aquesta pregunta veurem en profunditat la consulta de documents. Funcions find() i findOne() , que s\u00f3n les que hem utilitzat fina ara. Veurem en profunditat la seua sintaxi i pot\u00e8ncia. Limitarem i ordenarem tamb\u00e9 els resultats Fins i tot podrem elaborar m\u00e9s els resultats, agrupant els resultats, utilitzant funcions d'agregaci\u00f3 (o millor dir operadors d'agregaci\u00f3) i donant-los un aspecte diferent 3.4.1 - Par\u00e0metres de les funcions find() i findOne() Les funcions find() i findOne() s\u00f3n absolutament equivalents, amb l'\u00fanica difer\u00e8ncia que la primera torna tots els documents trobats, mentre que la segona nom\u00e9s torna el primer document trobat. Per una millor comprensi\u00f3, utilitzarem \u00fanicament find() , per veure tots els resultats obtinguts. La funci\u00f3 find() s'ha comparat tradicionalment amb la sent\u00e8ncia SELECT de SQL. Sempre tornar\u00e0 un conjunt de documents, que poden variar des de no tornar cap document, a tornar-los tots els de la col\u00b7lecci\u00f3. La funci\u00f3 find() pot tenir uns quants par\u00e0metres. El primer indica una condici\u00f3 o criteri, i tornar\u00e0 aquells documents de la col\u00b7lecci\u00f3 que acomplesquen la condici\u00f3 o criteri. Aquesta condici\u00f3 ve donada en forma de document (o objecte) JSON, i \u00e9s com l'hav\u00edem vist en la funci\u00f3 update() : db.col_leccio1.find( { clau1 : valor1 } ) Tornar\u00e0 tots els documents de la col\u00b7lecci\u00f3 col_leccio1 que tinguen el camp clau1 i que en ell tinguen el valor valor1 . Aquest criteri pot ser el complicat que fa\u00e7a falta, formant-lo en JSON. Pot tenir m\u00e9s d'un membre. En definitiva, tornar\u00e0 aquells documents que facen matching amb el document del criteri, \u00e9s a dir, funcionaria com un and en cas que tinga m\u00e9s d'un membre en la condici\u00f3 db.col_leccio1.find( { clau1 : valor1 , clau2 : valor2 } ) que tornaria aquells documents de la col_lecci\u00f31 que tenen el camp clau1 amb el valor valor1 i que tenen el camp clau2 amb el valor valor2 Si no volem posar cap criteri, per a que els torne tots, no posem res com a par\u00e0metre, o encara millor, li passem un document (objecte) buit, de manera que tots els documents de la col\u00b7lecci\u00f3 faran matching amb ell. db.col_leccio1.find( { } ) Tindrem a\u00e7\u00f2 present, sobretot quan ens toque utilitzar el segon par\u00e0metre de find . Si no volem cap criteri, posarem el document buit com l'exemple anterior. El segon par\u00e0metre ens servir\u00e0 per a delimitar els camps dels documents que es tornaran. Tamb\u00e9 tindr\u00e0 el format JSON d'un objecte al qual li posarem com a claus els diferents camps que volem que apareguen o no, i com a valor 1 per a que s\u00ed que apareguen i 0 per a que no apareguen. Si posem algun camp a que s\u00ed que aparega (\u00e9s a dir, amb el valor 1), els \u00fanics que apareixeran seran aquestos, a m\u00e9s del _id que per defecte sempre apareix. > db.alumnes.find({},{nom:1}) { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\" } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\" } Per tant si no volem que aparega _id posarem: > db.alumnes.find({},{_id:0}) { \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } I si volem traure \u00fanicament el nom: > db.alumnes.find({},{nom:1,_id:0}) { \"nom\" : \"Abel\" } { \"nom\" : \"Berta\" } Per \u00faltim, com que a partir d'ara utilitzarem documents m\u00e9s complicats, si volem que ens apareguen els camps que retornem d'una forma un poc m\u00e9s elegant o bonica ( pretty ), posarem aquesta funci\u00f3 al final: find().pretty() > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } 3.4.2 - Operadors de les condicions Abans de comen\u00e7ar aquesta pregunta, anem a agafar unes dades de prova, que estan en el fitxer libros_ejemplo.json Nom\u00e9s heu de copiar el contingut del fitxer en la terminal del client de Mongo. Posem ac\u00ed el contingut per a que pugueu pegar-li una miradeta sense necessitat d'obrir-lo. Anir\u00e0 b\u00e9 per als exemples posteriors. db.libro.insert({ \"_id\":\"9788408117117\", \"titulo\":\"Circo M\u00e1ximo\", \"autor\":\"Santiago Posteguillo\", \"editorial\":\"Planeta\", \"enstock\":true, \"paginas\":1100, \"precio\":21.75, \"fecha\":new ISODate(\"2013-08-29T00:00:00Z\"), \"resumen\":\"Circo M\u00e1ximo, de Santiago Posteguillo, que ha escrito otras obras de narrativa hist\u00f3rica como Las Legiones Malditas o La traici\u00f3n de Roma, es la segunda parte de la trilog\u00eda de Trajano, que comenz\u00f3 con Los asesinos del emperador, un relato impactante, descomunal, descrito con un trepidante pulso narrativo destinado a trasla dar al lector a la Roma imperial de los c\u00e9sares. Santiago posteguillo se ha convertido en el autor espa\u00f1ol de referencia de la novela hist\u00f3rica sobre Roma y el mundo antiguo. Bienvenidos al mundo de Marco Ulpio Trajano. Circo M\u00e1ximo es la historia de Trajano y su gobierno, guerras y traiciones, lealtades insobornables e historias de amor imposibles. Hay una vestal, un juicio, inocentes acusados, un abogado especial, mensajes cifrados, c\u00f3digos secretos, batallas campales, fortalezas inexpugnables, asedios sin fin, dos aurigas rivales, el Anfiteatro, los gladiadores y tres carreras de cuadrigas. Hay tambi\u00e9n un caballo especial, diferente a todos, leyes antiguas olvidadas, sacrificios humanos, amargura y terror, pero tambi\u00e9n destellos de nobleza y esperanza, como la llama de Vesta, que mientras arde preserva a Roma. S\u00f3lo que hay noches en las que la llama del Templo de Vesta tiembla. La rueda de la Fortuna comienza entonces a girar. En esos momentos, todo puede pasar y hasta la vida del propio Trajano, aunque \u00e9l no lo sepa, corre peligro. Y, esto es lo mejor de todo, ocurri\u00f3: hubo un complot para asesinar a Marco Ulpio Trajano.\" }) db.libro.insert({ \"_id\":\"9788401342158\", \"titulo\":\"El juego de Ripper\", \"autor\":\"Isabel Allende\", \"editorial\":\"Plaza & Janes\", \"enstock\":true, \"paginas\":480, \"precio\":21.75, \"fecha\":new ISODate(\"2014-03-01T00:00:00Z\"), \"resumen\":\"Tal como predijo la astr\u00f3loga m\u00e1s reputada de San Francisco, una oleada de cr\u00edmenes comienza a sacudir la ciudad. En la investigaci\u00f3n sobre los asesinatos, el inspector Bob Mart\u00edn recibir\u00e1 la ayuda inesperada de un grupo de internautas especializados en juegos de rol, Ripper. 'Mi madre todav\u00eda est\u00e1 viva, pero la matar\u00e1 el Viernes Santo a medianoche', le advirti\u00f3 Amanda Mart\u00edn al inspector jefe y \u00e9ste no lo puso en duda, porque la chica hab\u00eda dado pruebas de saber m\u00e1s que \u00e9l y todos sus colegas del Departamento de Homicidios. La mujer estaba cautiva en alg\u00fan punto de los dieciocho mil kil\u00f3metros cuadrados de la bah\u00eda de San Francisco, ten\u00edan pocas horas para encontrarla con vida y \u00e9l no sab\u00eda por d\u00f3nde empezar a buscarla\", }) db.libro.insert({ \"_id\":\"9788496208919\", \"titulo\":\"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"autor\":\"George R.R. Martin\", \"editorial\":\"Gigamesh\", \"enstock\":true, \"paginas\":793, \"precio\":9.5, \"fecha\":new ISODate(\"2011-11-24T00:00:00Z\"), \"resumen\":\"Tras el largo verano, el invierno se acerca a los Siete Reinos. Lord Eddars Stark, se\u00f1or de Invernalia, deja sus dominios para unirse a la corte del rey Robert Baratheon el Usurpador, hombre d\u00edscolo y otrora guerrero audaz cuyas mayores aficiones son comer, beber y engendrar bastardos. Eddard Stark desempe\u00f1ar\u00e1 el cargo de M ano del Rey e intentar\u00e1 desentra\u00f1ar una mara\u00f1a de intrigas que pondr\u00e1 en peligro su vida... y la de los suyos. En un mundo cuyas estaciones duran d\u00e9cadas y en el que retazos de una magia inmemorial y olvidada surgen en los rincones m\u00e1s sombrios y maravillosos, la traici\u00f3n y la lealtad, la compasi\u00f3n y la sed de venganza, el amor y el poder hacen del juego de tronos una poderosa trampa que atrapa en sus fauces a los personajes... y al lector. 'El regreso triunfal de Martin a la fantas\u00eda de m\u00e1s alta calidad... con personajes desarrollados con maestr\u00eda, prosa h\u00e1bil y pura obstinaci\u00f3n.'\" }) db.libro.insert({ \"_id\":\"9788499088075\", \"titulo\":\"La ladrona de libros\", \"autor\":\"Markus Zusak\", \"editorial\":\"Debolsillo\", \"enstock\":false, \"paginas\":544, \"precio\":9.45, \"fecha\":new ISODate(\"2009-01-09T00:00:00Z\"), \"resumen\":\"En plena II Guerra Mundial, la peque\u00f1a Liesel hallar\u00e1 su salvaci\u00f3n en la lectura. Una novela preciosa, tremendamente humana y emocionante, que describe las peripecias de una ni\u00f1a alemana de nueve a\u00f1os desde que es dada en adopci\u00f3n por su madre hasta el final de la guerra. Su nueva familia, gente sencilla y nada afecta al na zismo, le ense\u00f1a a leer y a trav\u00e9s de los libros Rudy logra distraerse durante los bombardeos y combatir la tristeza. Pero es el libro que ella misma est\u00e1 escribiendo el que finalmente le salvar\u00e1 la vida.\", }) db.libro.insert({ \"_id\":\"9788415140054\", \"titulo\":\"La princesa de hielo\", \"autor\":\"Camilla Lackberg\", \"editorial\":\"Embolsillo\", \"enstock\":true, \"precio\":11, \"fecha\":new ISODate(\"2012-10-30T00:00:00Z\"), \"resumen\":\"Misterio y secretos familiares en una emocionante novela de suspense Erica vuelve a su pueblo natal tras el fallecimiento de sus padres, pero se va a encontrar con un nuevo drama. Aparentemente su amiga de la infancia, Alex, se ha suicidado. Pronto se descubre que no solamente fue asesinada sino que estaba embarazada. El primer sospechoso es Anders, un artista fracasado con quien Alex manten\u00eda una relaci\u00f3n especial. Pero poco despu\u00e9s de ser liberado por falta de pruebas, Anders aparece muerto en su domicilio. Con la ayuda del comisario Patrik, Erica investigar\u00e1 el pasado de su amiga Alex.\" }) db.libro.insert({ \"_id\":\"9788408113331\", \"titulo\":\"Las carreras de Escorpio\", \"autor\":\"Maggie Stiefvater\", \"editorial\":\"Planeta\", \"enstock\":false, \"paginas\":290, \"precio\":17.23, \"fecha\":new ISODate(\"2013-06-04T00:00:00Z\"), \"resumen\":\"En la peque\u00f1a isla de Thisby, cada noviembre los caballos de agua de la mitolog\u00eda celta emergen del mar. Y cada noviembre, los hombres los capturan para participar en una emocionante carrera mortal. En las carreras de Escorpio, algunos compiten para ganar. Otros para sobrevivir. Los jinetes intentan dominar a sus caballos de agua el tiempo suficiente para acabar la carrera. Algunos lo consiguen. El resto, muere en el intento. Sean Kendrick es el favorito, y necesita ganar la carrera para ganar, tambi\u00e9n, su libertad. Pero Puck Connolly est\u00e1 dispuesta a ser su m\u00e1s dura adversaria. Ella nunca quiso participar en las carreras. Pero no tiene elecci\u00f3n: o compite y gana o\u2026 lo pierde todo.\", }) db.libro.insert({ \"_id\":\"9788468738895\", \"titulo\":\"Las reglas del juego\", \"autor\":\"Anna Casanovas\", \"enstock\":true, \"paginas\":null, \"precio\":15.90, \"fecha\":new ISODate(\"2014-02-06T00:00:00Z\"), \"resumen\":\"Susana Lobato tiene la vida perfectamente planeada y est\u00e1 a punto de conseguir todo lo que quiere: va a tener su propio programa de noticias econ\u00f3micas y en dos meses va a casarse con un hombre maravilloso. Pero una noche Tim anula la boda y la abandona para perseguir un sue\u00f1o que no la incluye a ella.Kev MacMurray acaba de cumplir treinta y cinco a\u00f1os y siente que ha llegado el momento de dar un cambio a su vida. No sabe por qu\u00e9, pero \u00faltimamente se est\u00e1 asfixiando y est\u00e1 convencido de que no puede seguir donde est\u00e1. Lo \u00fanico que lo retiene es la boda de Tim, su mejor amigo.Pero Tim anula la boda y una noche Kev coincide con Susana y respira por primera vez en mucho tiempo.\u00bfPor qu\u00e9 no le hab\u00eda sucedido antes? Se supon\u00eda que \u00e9l y Susana no se soportaban \u00bfDesde cu\u00e1ndo siente que si no besa a la prometida de su mejor amigo no podr\u00e1 seguir respirando?Susana nunca hab\u00eda reaccionado as\u00ed con nadie. \u00bfPuede correr el riesgo de averiguar qu\u00e9 pasar\u00e1 si se entrega a Kev?Y qu\u00e9 pasar\u00e1 si vuelve Tim, \u00bfpodr\u00e1n dar un paso atr\u00e1s?.\", }) Podeu comprovar que hi ha 7 documents en la nova col\u00b7lecci\u00f3 libro : > db.libro.count() 7 I tamb\u00e9 podem consultar els t\u00edtols de forma c\u00f2moda: > db.libro.find( {} , {titulo:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I un altre exemple, on consultem els llibres que estan en stock (hi ha un camp boole\u00e0 que ho diu: enstock ), mostrant t\u00edtol, editorial i preu > db.libro.find( {enstock: true} , {titulo:1 , editorial:1 , precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } I un \u00faltim exemple, on consultem els llibres que estan en stock i tenen un preu de 21.75 \u20ac, mostrant tot excepte el _id i el resum > db.libro.find( {enstock: true , precio: 21.75} , {titulo:1 , editorial:1 , > precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Anem a mirar ara operadors que ens serviran per fer millor les consultes. Operadors de comparaci\u00f3 Fins ara en totes les condicions hem utilitzat la igualtat, si un determinat camp era igual a un determinat valor. Per\u00f2 hi ha infinitat de consultes en les quals voldrem altres operacions de comparaci\u00f3: major, major o igual, menor, ... Aquestos s\u00f3n els operadors de comparaci\u00f3: $lt ( less than ) menor $lte ( less than or equal ) menor o igual $gt ( gretaer than ) major $gte ( gretaer than or equal ) major o igual $ne ( not equal ) distint $eq ( equal ) igual (per\u00f2 aquest quasi que no caldria, perqu\u00e8 en no posar res es refereix a la igualtat com fins ara) La sintaxi per a la seua utilitzaci\u00f3 \u00e9s, com sempre, acoplar-se a la sintaxi JSON: clau : { $operador : valor [, ... ] } Aix\u00ed per exemple, per a buscar els llibres de m\u00e9s de 10 \u20ac: > db.libro.find( { precio : { $gt : 10 } } , { titulo:1 , precio:1 } ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } I per a buscar els llibres entre 10 i 20 \u20ac: > db.libro.find( { precio : { $gt : 10 , $lt:20 } } , { titulo:1 , precio:1 } > ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } \u00c9s especialment \u00fatil per a les dates, ja que dif\u00edcilment trobarem una data (i hora) exacta, i voldrem quasi sempre els documents anteriors a una data, o posteriors, o entre dues dates. Haurem d'anar amb compte pel tractament especial de les dates: hem de comparar coses del mateix tipus, i per tant la data amb la qual volem comparar l'haurem de tenir en forma de data: > var d = new ISODate(\"2013-01-01T00:00:00Z\") > db.libro.find( {fecha:{$gte:d} } , {fecha:1} ) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\") } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\") } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\") } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\") } $in Servir\u00e0 per a comprovar si el valor d'un camp est\u00e0 entre els d'una llista, proporcionada com un array. La sitaxi \u00e9s: clau : { $in : [valor1 , valor2 , ... , valorN] } I ac\u00ed tenim un exemple, els llibre de les editorials Planeta i Debolsillo: > db.libro.find( { editorial: {$in : [\"Planeta\" , \"Debolsillo\"]} } , {titulo:1 > , editorial:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } $nin \u00c9s el contrari, traura els que no estan en la llista. > db.libro.find( { editorial: {$nin : [\"Planeta\" , \"Debolsillo\"]} } , > {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Observeu com tamb\u00e9 trau els llibres que no tenen editorial, com \u00e9s el cas de l'\u00faltim llibre, Las reglas del juego $or L'operador anterior, $in , ja feia una esp\u00e8cie de OR, per\u00f2 sempre sobre el mateix camp. Si l'operaci\u00f3 OR la volem fer sobre camps distints, haurem d'utilitzar l'operador $or . La seua sintaxi ha de jugar amb la possibilitat de posar molts elements, i per tant conv\u00e9 l'array: $or : [ {clau1:valor1} , {clau2:valor2} , ... , {clauN:valorN} ] Ser\u00e0 cert si s'acompleix alguna de les condicions. Per exemple, traure els llibres que no estan en stock o que no tenen editorial: > db.libro.find( { $or : [ {enstock:false} , {editorial:null} ] } , {titulo:1 > , enstock:1 , editorial:1} ) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"enstock\" : false } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"enstock\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"enstock\" : true} $not Serveix per a negar una altra condici\u00f3. $not : { condici\u00f3 } Per exemple els llibres que no s\u00f3n de l'editorial Planeta (observeu que seria m\u00e9s senzill utilitzar l'operador $ne , per\u00f2 \u00e9s per a mostrar el seu funcionament: > db.libro.find( { editorial: {$not : {$eq:\"Planeta\"} } } , {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } $exists Servir\u00e0 per a saber els documents que tenen un determinat camp clau : { $exists : _boolean_ } Depenet del valor boolean , el funcionament ser\u00e0: true : torna els documents en els quals existeix el camp, encara que el seu valor siga nul false : torna els documents que no tenen el camp. Anem a traure els llibres que tenen el camp paginas : > db.libro.find( { paginas: {$exists:true} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null } Observeu com ens apareix tamb\u00e9 l'ultim llibre, que t\u00e9 el camp paginas amb el valor nul . En canvi si hagu\u00e9rem fet la consulta preguntant pels que s\u00f3n diferents de nul, no apareixeria aquest \u00faltim llibre: > db.libro.find( { paginas: {$ne:null} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } I si posem false al valor en el $exists , \u00fanicament ens apareixer\u00e0 el llibre que no t\u00e9 el camp: > db.libro.find( { paginas: {$exists:false} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } I per la mateixa ra\u00f3 que abans, si traiem els que tenen paginas a null, ens eixir\u00e0 tant qui no t\u00e9 el camp, com qui el t\u00e9 per\u00f2 amb valor nul: > db.libro.find( { paginas: null } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null} Per tant, per a segons quines coses, ens interessa l'operador $exists , en compte de jugar amb el nul. Expressions regulars Mongo accepta les expressions regulars de forma nativa, cosa que d\u00f3na molta pot\u00e8ncia per a poder buscar informaci\u00f3 diversa. Les expressions regulars en Mongo tenen la mateixa sintaxi que en Perl, i que \u00e9s molt molt pareguda a la major part de llenguatges de programaci\u00f3. Mirem alguns exemples. Els llibres dins dels quals est\u00e0 la paraula juego : > db.libro.find( { titulo: /juego/ } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Ara que tenen la paraula juego sense importar maj\u00fascules o min\u00fascules: > db.libro.find( { titulo: /juego/i } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I ara que tenen la paraula juego nom\u00e9s al principi. > db.libro.find( { titulo: /^juego/i } , {titulo:1} ) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } I ara els llibres que en el resum ( resumen ) tenen la paraula amiga o amigo , \u00e9s a dir amig seguit d'una a o una o : > db.libro.find( { resumen: /amig[ao]/i } , {titulo:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Arrays Les consultes dins d'arrays de Mongo s\u00f3n molt senzilles. La m\u00e9s senzilla \u00e9s quan busquem un valor d'un tipus senzill, i en aquest cas el que far\u00e0 Mongo \u00e9s buscar en tot l'array per si est\u00e0 aquest valor. \u00c9s a dir, exactament igual que el que hem fet fins ara. db.col_leccio1.find ( { clau_array : valor } ) Mirem-ho en un exemple. Anem a crear dos documents que tinguen un array cadascun, per exemple de colors. El creem en una col\u00b7lecci\u00f3 nova, anomenada colorins , en dos documents amb el mateix camp de tipus array, color , per\u00f2 amb dades diferents * *: > db.colorins.insert({color: [\"roig\",\"blau\",\"groc\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.insert({color: [\"negre\",\"blanc\",\"roig\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.find(); { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Com es veu en la sintaxi, triar els documents que tenen un camp (en aquest cas d'array) que continga un valor, \u00e9s igual de senzill que quan es tracta d'un camp de tipus string, per exemple: > db.colorins.find({color:\"roig\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 podem utilitzar qualsevol dels operadors vistos fins el moment, com per exemple l'operador $in , que mirar\u00e0 els documents que tenen algun dels colors que s'especifica a continuaci\u00f3: > db.colorins.find({color: {$in : [\"groc\",\"lila\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } O per exemple tamb\u00e9 utilitzar expressions regulars : > db.colorins.find({color: /bl/ }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $ all L'operador $all el podem utilitzar quan vulguem seleccionar els documents que en l'array tiguen tots els elements especificats. Per exemple, anem a buscar els document que tenen el color roig i blau. > db.colorins.find({color : { $all : [\"roig\",\"blau\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Sub\u00edndex Si volem mirar exactament una determinada posici\u00f3 de l'array, podem especificar la posici\u00f3 immediatament despr\u00e9s de la clau, separada per un punt . Recordeu que la primera posici\u00f3 \u00e9s la 0 . Hem de posar entre cometes la clau i la posici\u00f3, sin\u00f3 no sabr\u00e0 trobar-la. Per exemple, busquem els documents que tenen el roig en la primera posici\u00f3. > db.colorins.find({\"color.0\" : \"roig\"} ) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Nota Accedir a una determinada posici\u00f3 \u00e9s f\u00e0cil, per\u00f2 no \u00e9s tan f\u00e0cil accedir a una posici\u00f3 calculada, per exemple a l'\u00faltima posici\u00f3. Ja fa falta coneixements un poc m\u00e9s avan\u00e7ats de JavaScript, per a posar dins del find() una funci\u00f3 en JavaScript, i actuar dins d'aquesta. \u00danicament de manera il\u00b7lustrativa, posem ac\u00ed la manera de traure els documents, l'\u00faltim color dels quals \u00e9s el roig. En ella ens creem una variable amb l'\u00faltim element de l'array (amb pop() ), i el comparem amb el color roig, tornant true en cas de que s\u00ed que siguen iguals: > db.colorins.find(function() { var a =this.color.pop(); return (a ==\"roig\")}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 hi ha una forma alternativa de fer-ho, que \u00e9s utilitzant l'operador $where , que ens permet crear condicions amb sintaxi JavaScript: > db.colorins.find({$where:\"this.color[this.color.length - 1]=='roig'\"}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $size L'operador $size ens servir\u00e0 per a fer condicions sobre el n\u00famero d'elements d'un array. Incorporem 2 documents nous, amb 2 i 4 elements respectivament, per a poder comprovar-lo: > db.colorins.insert({color: [\"negre\",\"blanc\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.insert({color: [\"taronja\",\"gris\",\"lila\",\"verd\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.find() { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Ara anem a seleccionar els documents que tenen 4 colors > db.colorins.find({color:{$size:4}}) { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Nota L'operador $size nom\u00e9s admet un valor num\u00e8ric, i no es poden concatenar expressions amb altres operadors, com per exemple intentar la condici\u00f3 que la grand\u00e0ria de l'array siga menor o igual a un determinat valor. Es pot tornar a esquivar la q\u00fcesti\u00f3 amb l'operador $where , i posar la condici\u00f3 en JavaScript. Aix\u00ed la consulta dels documents que tenen 3 o menys colors la podr\u00edem traure d'aquesta manera: > db.colorins.find({$where:\"this.color.length<=3\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ]} $slice L'operador $slice no \u00e9s un operador que es puga posar en les condicions (criteris), sin\u00f3 que servir\u00e0 per a extraure determinats elements de l'array, pel n\u00famero d'ordre d'aquestos elements en l'array. Nom\u00e9s el podrem posar, per tant, en el segon par\u00e0metre del find() . La sintaxi \u00e9s: clau : {$slice : x } Els valors que pot agafar x s\u00f3n: N\u00fameros positius: ser\u00e0 el n\u00famero d'elements del principi (per l'esquerra) N\u00fameros negatius: ser\u00e0 el n\u00famero d'elements del final (per la dreta) Un array de 2 elements ( [x,y] ): traur\u00e0 a partir de la posici\u00f3 x (0 \u00e9s el primer), tants elements com indique y Per exemple, anem a traure els dos primers colors de cada document: > db.colorins.find({} , {color:{$slice:2} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\" ] } O traure l'\u00faltim color: > db.colorins.find({} , {color:{$slice:-1 }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"verd\" ] } O traure el tercer element, tinguen els que tinguen. Recordeu que el segon element, \u00e9s el de la posici\u00f3 2, i en volem traure 1. > db.colorins.find({} , {color:{$slice:[2,1] }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"lila\" ] } Recerques en objectes Per a fer recerques en camps que a la seua vegada s\u00f3n objectes (o documents dins de documents, en la terminologia de Mongo), nom\u00e9s hem de posar la ruta de les claus separant per mig de punts, i cuidar de posar-la entre cometes. Aix\u00ed, per exemple, anem a fer una consulta sobre la col\u00b7lecci\u00f3 d'alumnes, que eren uns documents en els quals hi havia algun camp de tipus objecte. > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } Es podrien traure els documents (els alumnes) que viuen en el codi postal 12502. Ens ha d'eixir l'\u00fanic alumne del qual tenim l'adre\u00e7a, que justament t\u00e9 aquest codi postal. Recordeu que en la clau (realment clau.subclau), ha d'anar entre cometes. Hem posat al final pretty() per a una millor lectura, per\u00f2 evidentment no \u00e9s necessari. > db.alumnes.find({\"adre\u00e7a.cp\": \"12502\"}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } I funcionaria igual amb qualsevol n\u00famero de subnivells, \u00e9s a dir, documents que tenen objectes, els quals tenen objectes, ... I tamb\u00e9 amb altres tipus d'operadors, o expressions regulars, ... Per exemple, tots els alumnes de Castell\u00f3 (el codi postal ha de comen\u00e7ar per 12 i contenir 3 xifres m\u00e9s, \u00e9s a dir, car\u00e0cter del 0 al 9, i 3 vegades. > db.alumnes.find({\"adre\u00e7a.cp\": /^12[0-9]{3}/}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } Limit, Skip i Sort Una vegada tenim feta una consulta, podem limitar el nombre de documents que ens ha de tornar, o ordenar-los. Per a aix\u00f2 hi ha uns m\u00e8todes que apliqiuem al final del find() , \u00e9s a dir, a continuaci\u00f3 del find() , separats per un punt. Ho aplicarem als llibres, que \u00e9s on tenim m\u00e9s documents. I no mostrem tots els camps, per a una millor lectura: > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } limit( n ) Limita el n\u00famero de documents tornats a n documents. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } Si el n\u00famero de documents que fa la consulta \u00e9s menor que n , doncs se'n tornaran menys. Aix\u00ed per exemple, de l'editorial Planeta nom\u00e9s hi ha dos llibres. Encara que posem limit(3), se'n tornaran 2. > db.libro.find({editorial:\"Planeta\"} , {titulo:1 , precio:1 , > editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\", \"precio\" : 17.23 } skip( n ) Se saltaran els primers n documents. Si hi haguera menys documents dels que se salten, doncs no se'n mostraria cap. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).skip(2) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } sort() Serveix per a ordenar. Com a par\u00e0metre se li passar\u00e0 un objecte JSON amb les claus per a ordenar, i els valors seran: 1: ordre ascendent -1: ordre descendent Si posem m\u00e9s d'una clau, s'ordenar\u00e0 pel primer, en cas d'empat pel segon, ... En aquest exemple ordenem pel preu > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({precio:1}) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } I com d\u00e9iem, es pot posar m\u00e9s d'un camp d'ordenaci\u00f3. Per exemple, per editorial en ordre ascendent, i per preu en ordre descendent > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({editorial:1 , > precio:-1}) { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Observeu com el primer \u00e9s el que no t\u00e9 editorial (equivalent a null). I com que hi ha dos de l'editorial Planeta, apareix primer el m\u00e9s car, i despr\u00e9s el m\u00e9s barat. I evidentment, es poden combinar els m\u00e8todes limit, skip i sort. En aquest exemple traurem el segon i tercer llibre m\u00e9s car. Per a aix\u00f2 ordenem per preu de forma descendent, saltem un i limitem a 2. No importa l'ordre com col\u00b7locar skip, limit i sort. > db.libro.find({} , {titulo:1 , precio:1 , > editorial:1}).sort({precio:-1}).skip(1).limit(2) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } 3.4.3 - Agregaci\u00f3 L'agregaci\u00f3 ens permetr\u00e0 fer consultes molt avan\u00e7ades. \u00c9s un proc\u00e9s un poc complicat per\u00f2 molt potent. Ens donar\u00e0 una pot\u00e8ncia quasi com la del SQL quan comencem a utilitzar el GROUP BY i HAVING. La t\u00e8cnica que s'utilitza \u00e9s la del pipeline , \u00e9s a dir fer una s\u00e8rie de comandos, cadascun agafa les dades que proporciona l'anterior i a la seua vegada proporciona les dades al seg\u00fcent comando. D'aquesta manera es tractar\u00e0 un conjunt de documents i es faran \"operacions\" sobre ells seq\u00fcencialment en blocs: filtrat, projecci\u00f3, agrupacions, ordenaci\u00f3, limitaci\u00f3 i skipping (saltar alguns). La sintaxi ser\u00e0: db.col_leccio1.aggregate ( _operador $matc_ h , _operador $projec_ t , _operador $group_ , _operador $sort_ , _operador $limit_ , _operador $skip_ ) L'ordre dels operadors pot canviar, per\u00f2 hem de tenir en compte que els comandos s'executen en el ordre en qu\u00e8 els posem (d'esquerra a dreta). Aix\u00ed, per exemple, pot ser molt convenient posar el primer operador el $match, que \u00e9s el de seleccionar documents, aix\u00ed les altres operacions es faran sobre menys documents i aniran m\u00e9s r\u00e0pides. Cada par\u00e0metre del aggregate, \u00e9s a dir, cada operador tindr\u00e0 format JSON, i per tant sempre ser\u00e0 de l'estil: { $operador : { clau:valor , ... } } $match Servir\u00e0 per a filtrar els documents. Aleshores, l'agregaci\u00f3 nom\u00e9s afectar\u00e0 als documents seleccionats. Es poden utilitzar tots els operadors que hem anat estudiant. El seg\u00fcent exemple selecciona els documents de l'editorial Planeta. Ho fa per mig de aggregate , per\u00f2 com no fem res m\u00e9s, senzillament selecciona els documents. > db.libro.aggregate({$match:{editorial:\"Planeta\"}}) En el seg\u00fcent exemple, a m\u00e9s de seleccionar els de l'editorial Planeta despr\u00e9s apliquem una projecci\u00f3 sobre els camps t\u00edtol i editorial, per a poder visualitzar millor el resultat. > > db.libro.aggregate({$match:{editorial:\"Planeta\"}},{$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\" } $project Ens permet projectar sobre determinats camps del document, per\u00f2 \u00e9s molt m\u00e9s complet que en la projecci\u00f3 \"normal\" que hav\u00edem fet fins ara, ja que permet tamb\u00e9 renomenar camps, fer c\u00e0lculs, etc. Projeccci\u00f3 La manera m\u00e9s senzilla, evidentment \u00e9s projectar sobre alguns camps dels existents, i el funcionament \u00e9s id\u00e8ntic al de l'altra vegada (valors 1 per a que apareguen, 0 per a que no apareguen; per defecte _id sempre apareix): > db.libro.aggregate({$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Renomenar $project tamb\u00e9 ens permet renomenar camps existents (despr\u00e9s veurem que tamb\u00e9 c\u00e0lculs). La manera ser\u00e0 posar d'aquest manera: { $projec t : { \"nom_nou\" : \"$camp_vell\" }} El secret est\u00e0 en el d\u00f2lar que va davant del camp vell, ja que d'aquesta manera ens referim al valor d'aquest camp. Aix\u00ed per exemple renomenem el camp enstock a disponible , a banda de traure el t\u00edtol: > db.libro.aggregate({$project:{titulo:1 , disponible:\"$enstock\"}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"disponible\" : true } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"disponible\" : true } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" disponible\" : true } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"disponible\" : false } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"disponible\" : true } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"disponible\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"disponible\" : true } Camps calculats Amb aquest nom gen\u00e8ric ens referirem a tots els c\u00e0lculs, expressions i m\u00e9s coses que podrem posar per a trasnsformar el que ja tenim. Com veiem, a\u00e7\u00f2 \u00e9s molt m\u00e9s potent que la projecci\u00f3 normal. Expressions matem\u00e0tiques : Podrem aplicar f\u00f3rmules per a sumar ( $add ), restar ( $subtract ), multiplicar ( $multiply ), dividir ( $divide ) i m\u00e9s coses (pot\u00e8ncia, arrel quadrada, valor absolut, m\u00f2dul, ...). Cada operaci\u00f3 t\u00e9 el seu operador que ser\u00e0 una paraula precedida pel d\u00f2lar, i amb la sintaxi de JSON, on posarem els operands en un array. Per exemple, traurem t\u00edtol del llibre, preu i preu en pessetes (multiplicant per 166.386) > db.libro.aggregate({$project:{titulo:1 , precio:1 , > preu_pessetes:{$multiply:[\"$precio\" , 166.386]}}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"precio\" : 9.5, \"preu_pessetes\" : 1580.667 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"precio\" : 9.45, \"preu_pessetes\" : 1572.3476999999998 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11, \"preu_pessetes\" : 1830.2459999999999 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23, \"preu_pessetes\" : 2866.83078 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9, \"preu_pessetes\" : 2645.5374 } Expressions de dates : Ja veurem i ja podem anar intuint que moltes agregacions estaran basades en el temps, per a poder fer consultes de documents de la setmana passada, o el mes passat, ... Per a poder fer aquestes agregacions, hi ha un conjunt d'expressions que permeten extraure f\u00e0cilment d'una data el seu dia, mes, any, ... en forma de n\u00famero S\u00f3n les expressions: $year, $month, $week, $dayOfMonth, $DayOfWeek, $dayOfYear, $hour, $minute i $second . En el seg\u00fcent exemple traurem tots els documents, projectant per la data, any i mes: > db.libro.aggregate({$project : {fecha:1 , a\u00f1o:{$year:\"$fecha\"} , > mes:{$month:\"$fecha\"}}}) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 8 } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 3 } { \"_id\" : \"9788496208919\", \"fecha\" : ISODate(\"2011-11-24T00:00:00Z\"), \"a\u00f1o\" : 2011, \"mes\" : 11 } { \"_id\" : \"9788499088075\", \"fecha\" : ISODate(\"2009-01-09T00:00:00Z\"), \"a\u00f1o\" : 2009, \"mes\" : 1 } { \"_id\" : \"9788415140054\", \"fecha\" : ISODate(\"2012-10-30T00:00:00Z\"), \"a\u00f1o\" : 2012, \"mes\" : 10 } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 6 } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 2 } Expressions de strings : Ens permeten manipular els strings per a extraure subcadenes, concatenar, passar a maj\u00fascules o min\u00fascules. Aquestes s\u00f3n algunes de les funcions: $substr : [exp , inici , llarg\u00e0ria] : extrau una subcadena del string del primer par\u00e0metre, des de la posici\u00f3 que indica el segon par\u00e0metre (o primer car\u00e0cter) i tants car\u00e0cters com el tercer par\u00e0metre $concat : [ exp1 , exp2 , ...] : concatena les expressions que hi ha en l'array $toLower : exp i $toUpper : exp : converteixen l'expressi\u00f3 a maj\u00fascules i min\u00fascules respectivament Per exemple, anem a traure el t\u00edtol dels llibres amb l'autor entre par\u00e8ntesis: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : [\"$titulo\" , \" (\" , > \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"Circo M\u00e1ximo (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"El juego de Ripper (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"La ladrona de libros (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"La princesa de hielo (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"Las carreras de Escorpio (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"Las reglas del juego (Anna Casanovas)\"} I ara el mateix, per\u00f2 amb el t\u00edtol en maj\u00fascules: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : > [{$toUpper:\"$titulo\"}, \" (\" , \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"CIRCO M\u00e1XIMO (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"EL JUEGO DE RIPPER (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"JUEGO DE TRONOS: CANCI\u00f3N DE HIELO Y FUEGO 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"LA LADRONA DE LIBROS (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"LA PRINCESA DE HIELO (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"LAS CARRERAS DE ESCORPIO (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"LAS REGLAS DEL JUEGO (Anna Casanovas)\" } $group Realitza grups sobre els documents seleccionats pr\u00e8viament, per a valors iguals del camp o expressions que determinem. Posteriorment, amb els grups, podrem realitzar operacions, com sumar o traure la mitjana d'alguna quantitat dels documents del grup, o el m\u00e0xim o m\u00ednim, ... Per a poder agrupar, haurem de definir com a _id del grup el camp o camps pels valors dels quals volem agrupar. Per exemple, si volem agrupar els llibres per l'editorial, haurem de definir el _id del grup el camp editorial $group : { \"_id\" : _camp o camps_ } Si agrupem per un \u00fanic camp, senzillament el posem amb un d\u00f2lar davant i entre cometes. Si \u00e9s m\u00e9s d'un camp, els posem com un objecte. Per exemple, agrupem per editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" } } ) { \"_id\" : \"Debolsillo\" } { \"_id\" : null } { \"_id\" : \"Gigamesh\" } { \"_id\" : \"Embolsillo\" } { \"_id\" : \"Plaza & Janes\" } { \"_id\" : \"Planeta\" } Podem observar com hi ha algun llibre que no t\u00e9 editorial. Ara agrupem per any de publicaci\u00f3 (l'extraurem del camp fecha ): > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } }} ) { \"_id\" : { \"any\" : 2012 } } { \"_id\" : { \"any\" : 2009 } } { \"_id\" : { \"any\" : 2011 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"any\" : 2013 } } I ara agrupem per editorial i any de publicaci\u00f3 (els dos llibres de Planeta s\u00f3n del 2013) > db.libro.aggregate( { $group : { \"_id\" : { \"Editorial\" : \"$editorial\" , > \"any\" : { $year : \"$fecha\" } } } } ) { \"_id\" : { \"Editorial\" : \"Embolsillo\", \"any\" : 2012 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Debolsillo\", \"any\" : 2009 } } { \"_id\" : { \"Editorial\" : \"Gigamesh\", \"any\" : 2011 } } { \"_id\" : { \"Editorial\" : \"Plaza & Janes\", \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Planeta\", \"any\" : 2013 } } Operadors d'agrupaci\u00f3 Ens permetran fer alguna operaci\u00f3 sobre els documents del grup. Es posen com a segon par\u00e0metre del grup (despr\u00e9s de la definici\u00f3 del _id ). $sum : valor : sumar\u00e0 el valor de tots els documents del grup. El valor pot ser un camp num\u00e8ric, o alguna altra cosa m\u00e9s complicada. $avg : valor : calcular\u00e0 la mitjana dels valors per als documents del grup $max : valor : m\u00e0xim $min : valor : m\u00ednim $first : exp : agafar\u00e0 el primer valor de l'expressi\u00f3 del grup, ignorant les altres del grup $last : exp : agafar\u00e0 l'\u00faltim La documentaci\u00f3 diu que tamb\u00e9 existeix l'operador $count , per\u00f2 a partir d'una determinada versi\u00f3. Es pot substituir la seua utilitzaci\u00f3 per l'operador $sum , sumant la quantitat 1. Per exemple, la suma dels preus dels llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : { > $sum : \"$precio\"} } } ) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } O la mitjana dels preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } , > \"mitjana preus\" : { $avg : \"$precio\" } } } ) { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } I ara intentem comptar la quantitat de llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"quants\" : { $sum : > 1} } } ) { \"_id\" : \"Debolsillo\", \"quants\" : 1 } { \"_id\" : null, \"quants\" : 1 } { \"_id\" : \"Gigamesh\", \"quants\" : 1 } { \"_id\" : \"Embolsillo\", \"quants\" : 1 } { \"_id\" : \"Plaza & Janes\", \"quants\" : 1 } { \"_id\" : \"Planeta\", \"quants\" : 2 } $sort Serveix per a ordenar i segueix la mateixa sint\u00e0xi que en les consultes normal (1: ordre ascendent; -1: ordre descendent). Podrem ordenar pels camps normals o per camps clalculats. Per exemple ordenem per la suma de preus de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : { > $sum : \"$precio\"} } } , { $sort : { suma_preus : 1 } }) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } I ara ordenem de forma descendent per la mitjana de preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : {\"any\":{$year:\"$fecha\"}} , \"mitjana > preus\":{$avg:\"$precio\"} } } , {$sort:{\"mitjana preus\":-1}}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } $limit Limita el resultat del aggregate al n\u00famero indicat. Per exemple, els tres anys de mitjana de preus m\u00e9s cara. \u00c9s com l'\u00faltim exemple, afegint el l\u00edmit: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana > preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$limit:3}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } $skip Salta el n\u00famero indicat En l'exemple anterior, ara saltem els 3 primers: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana > preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$skip:3}) { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } 3.5 - Connexi\u00f3 des de Kotlin i Exemples Per a poder connectar des de Java o Kotlin ens sera suficient amb un driver, que haurem d'incorporar al projecte. En la seg\u00fcent p\u00e0gina podem trobar-lo, en diferents versions: https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/ En el moment de fer aquestos apunts, l'\u00faltim driver disponible \u00e9s el seg\u00fcent: https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/3.9.1/mongo- java-driver-3.9.1.jar Per a separar les proves i exercicis de la part de Redis , creem un nou paquet anomenat ExemplesMongo . Connexi\u00f3 La connexi\u00f3 \u00e9s tan senzilla com el seg\u00fcent: val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") \u00c9s a dir, obtenim un objecte MongoClient passant-li al constructor l'adre\u00e7a del servidor i el port de connexi\u00f3 (que per defecte \u00e9s 27017). Posteriorment hem de connectar amb la Base de Dades. Ja hav\u00edem comentat en la instal\u00b7laci\u00f3 de Mongo que nosaltres nom\u00e9s utilitzar\u00edem una Base de Dades ja creada anomenada test . Obtenim un objecte MongoDatabase que far\u00e0 refer\u00e8ncia a la Base de Dades, i \u00e9s l'objecte que utilitzarem a partir d'ara. Evidentment ho podr\u00edem haver fet en una \u00fanica l\u00ednia. Si el servidor no el tenim en la mateixa m\u00e0quina, nom\u00e9s haurem de substituir localhost per l'adre\u00e7a on estiga el servidor. Per a tancar la connexi\u00f3: con.close() Inserci\u00f3 de documents Des de Kotlin podrem inserir documents amb la mateixa facilitat que des de la consola. Nom\u00e9s haurem de crear un objecte Document de BSON (recordeu que \u00e9s el format intern de Mongo, absolutament similar a JSON ). La manera d'anar posant parelles calu valor en aquest document \u00e9s per mig del m\u00e8tode put . Fem un exemple molt senzill on senzillament guardem un document amb una parella clau-valor d'un missatge. Guardeu-lo amb el nom Prova1.kt : import com.mongodb.MongoClient import org.bson.Document fun main(args: Array<String>) { val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val doc = Document() doc.put(\"msg4\", \"Missatge inserit des de Kotlin\") bd.getCollection(\"exemple\").insertOne(doc) con.close() } Segurament traur\u00e0 avisos en la consola, per\u00f2 nom\u00e9s s\u00f3n avisos. Podem comprovar en la terminal com s'ha inserit el document: Consultes Tenim el m\u00e8tode find() per a fer consultes, i li podem posar un document com a par\u00e0metre per a seleccionar determinats documents o traure determinada informaci\u00f3. Guardeu el seg\u00fcent exemple amb el nom Prova2.kt : import com.mongodb.MongoClient fun main(){ val con = MongoClient(\"localhost\" , 27017) val bd = con.getDatabase(\"test\") val llibres = bd.getCollection(\"libro\").find() for (llibre in llibres) println(llibre.get(\"titulo\")) con.close(); } I com coment\u00e0vem podem posar com a par\u00e0metres en el find() per a seleccionar determinats documents, ordenar, etc. Nom\u00e9s hem de cuidar que ho hem de posar en JSON (millor dit BSON ), i per tant haurem de crear un document per a aix\u00f2. Copieu el seg\u00fcent exemple amb el nom Prova3.kt : import com.mongodb.MongoClient import org.bson.Document fun main(){ val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val ordenar = Document() ordenar.put(\"precio\", -1) val llibres = bd.getCollection(\"libro\").find().sort(ordenar) for (llibre in llibres) System.out.println( \"T\u00edtol: \" + llibre.get(\"titulo\").toString() + \". Preu: \" + llibre.get(\"precio\") ) con.close() } El resultat ser\u00e0 aquest: Hem pogut observar en l'execuci\u00f3 dels exemples anteriors que ens trau una gran quantitat d'avisos. No s\u00f3n errors, sin\u00f3 senzillament informaci\u00f3 de com van les connexions, que mongo torna, i apareixen en l'eixida est\u00e0ndar. Si no volem que apareguen podem posar al principi del programa una sent\u00e8ncia per a dir que \u00fanicament apareguen els errors, i no els avisos. Els errors estarien en la categoria de SEVERE LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) Hem d'importar les classes de java.util . Quedaria el mateix exemple Prova3.kt d'aquesta manera: import com.mongodb.MongoClient import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val ordenar = Document() ordenar.put(\"precio\", -1) val llibres = bd.getCollection(\"libro\").find().sort(ordenar) for (llibre in llibres) System.out.println( \"T\u00edtol: \" + llibre.get(\"titulo\").toString() + \". Preu: \" + llibre.get(\"precio\") ) con.close() } I el resultat ara ser\u00e0: Agregaci\u00f3 Per a poder utilitzar la funci\u00f3 d'agregaci\u00f3, que t\u00e9 tanta pot\u00e8ncia, ens ho hem de muntar d'aquesta manera: Sobre la col\u00b7lecci\u00f3 utilitzar el m\u00e8tode aggregate() Com a par\u00e0metres, afegirem un MutableList . Cada element d'ell ser\u00e0 una opci\u00f3 d'aggregate Per a cada opci\u00f3 ($match, $project...), utilitzarem el m\u00e8tode d' Aggregates (una classe del driver de Mongo) amb el mateix nom: Per a $match : Aggregates.match() Per a $project: Aggregates.project() ... Dins de cadascun d'aquestos m\u00e8todes posarem un document BSon amb les especificacions que necessitem En aquest exemple farem la selecci\u00f3 (match) dels llibres de l'editorial Planeta, agafant (project) \u00fanicament el t\u00edtol i l'editorial. La sent\u00e8ncia en la consola la far\u00edem aix\u00ed: > db.libro.aggregate({$match:{editorial:\"Planeta\"}},{$project:{titulo:1, > editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } El programa ens quedaria aix\u00ed. Guardeu-lo en en fitxer Kotlin anomenat Prova_Aggregate_1.kt : import com.mongodb.MongoClient import com.mongodb.client.model.Aggregates import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val seleccionar = Document() seleccionar.put(\"editorial\", \"Planeta\") val projeccio = Document() projeccio.put(\"titulo\",1) projeccio.put(\"editorial\",1) val llibres = bd.getCollection(\"libro\").aggregate(mutableListOf(Aggregates.match(seleccionar),Aggregates.project(projeccio))) for (llibre in llibres) println(\"T\u00edtol: \" + llibre.get(\"titulo\").toString() + \". Editorial: \" + llibre.get(\"editorial\").toString() ) con.close() } Mirem un altre exemple. Traure el llibre m\u00e9s barat de cada any. La consulta en Mongo que far\u00edem en la consola de Mongo seria: > db.libro.aggregate( {$group : {\"_id\" : { \"any\" : { $year : \"$fecha\" } } , \"minim\":{$min: \"$precio\"}}}, {$sort:{\"_id\":1}}) { \"_id\" : { \"any\" : 2009 }, \"minim\" : 9.45 } { \"_id\" : { \"any\" : 2011 }, \"minim\" : 9.5 } { \"_id\" : { \"any\" : 2012 }, \"minim\" : 11 } { \"_id\" : { \"any\" : 2013 }, \"minim\" : 17.23 } { \"_id\" : { \"any\" : 2014 }, \"minim\" : 15.9 } Ara col\u00b7locarem aquesta sent\u00e8ncia en un programa Kotlin. Guardeu el seg\u00fcent codi com el fitxer Kotlin Prova_Aggregate_2.kt : import com.mongodb.MongoClient import com.mongodb.client.model.Aggregates import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val grup = Document() grup.put(\"_id\", Document(\"any\",Document(\"\\$year\",\"\\$fecha\"))) grup.put(\"minim\",Document(\"\\$min\",\"\\$precio\")) val ordenar = Document() ordenar.put(\"_id\",1) val llibres = bd.getCollection(\"libro\").aggregate(mutableListOf(Aggregates.group(grup),Aggregates.sort(ordenar))) for (llibre in llibres){ val d = llibre.get(\"_id\") as Document println(\"Any: \" + (d.get(\"_id\") as Document).getInteger(\"any\")+ \". M\u00ednim: \" + d.getDouble(\"minim\")) } con.close() } Hem tingut la complicaci\u00f3 que el resultat \u00e9s m\u00e9s complicat, t\u00e9 un document dins d'una altre document (com es veu en el resultat de la sent\u00e8ncia executada en la consola). Aquest ser\u00e0 el resultat: 3.6 - Connexi\u00f3 des de Kotlin al servidor de l'Institut La connexi\u00f3 canvia si la fem al servidor de l'Institut, no per ser una direcci\u00f3 externa, sin\u00f3 perqu\u00e8 cal la autenticaci\u00f3. Hem habilitat l'autenticaci\u00f3 per a intentar evitar atacs. Si no tingu\u00e8rem autenticaci\u00f3, la connexi\u00f3 seria com abans: val con = MongoClient(\"89.36.214.106\") val bd = con.getDatabase(\"test\") Per\u00f2 per tenir l'autenticaci\u00f3 activada la connexi\u00f3 haur\u00e0 de ser diferent: val con = MongoClient(MongoClientURI(\"mongodb://ad:Ad_ieselcamina$@89.36.214.106/?authSource=test\")) val bd = con.getDatabase(\"test\") on hem especificat l'adre\u00e7a donant-li un usuari ( ad ), una contrasenya ( Ad_ieselcamina$ ), el servidor ( 89.36.214.106 ) i fins i tot la Base de Dades on connectem, que ja va comentar que nom\u00e9s ten\u00edem la BD test Per a tancar la connexi\u00f3, com sempre: con.close() Mirem un exemple on podem comprovar que l'utilitzem exactament igual que amb la connexi\u00f3 a localhost, per\u00f2 ara ens est\u00e0 contestant el servidor de l'Institut. Guardeu-lo amb el nom ProvaServidor.kt : import com.mongodb.MongoClient import com.mongodb.MongoClientURI import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(MongoClientURI(\"mongodb://ad:Ad_ieselcamina$@89.36.214.106/?authSource=test\")) val bd = con.getDatabase(\"test\") val ordenar = Document() ordenar.put(\"precio\", -1) val llibres = bd.getCollection(\"libro\").find().sort(ordenar) for (llibre in llibres) System.out.println(llibre.get(\"titulo\").toString() + \" --> \" + llibre.get(\"precio\")) con.close() } I ac\u00ed tenim el resultat: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"3 - MongoDB"},{"location":"3__mongodb/#3-mongodb","text":"Segurament MongoDB \u00e9s el m\u00e9s fam\u00f3s dels Sistemes Gestors de Bases de Dades NoSQL . El nom de MongoDB prov\u00e9 de la paraula anglesa hu mongo us , que significa enorme, que \u00e9s el prop\u00f2sit d'aquesta Base de Dades: guardar grans quantitats d'informaci\u00f3. \u00c9s de codi obert i est\u00e0 programada en C++. El va crear l'empresa 10gen (actualment MongoDB Inc. ) \u00c9s un SGBD Documental , \u00e9s a dir, que servir\u00e0 per a guardar documents. La manera interna de guardar-los \u00e9s en format BSON (Binary JSON) que en ess\u00e8ncia \u00e9s una variant del JSON per a poder guardar f\u00edsicament les dades d'una manera m\u00e9s eficient. En un servidor Mongo poden haver m\u00e9s d'una Base de Dades, encara que nosaltres nom\u00e9s en gastarem una: test . En cada Base de Dades la informaci\u00f3 es guardar\u00e0 en col\u00b7leccions . Cada col\u00b7lecci\u00f3 constar\u00e0 d'uns quants documents . I cada document seran una s\u00e8rie de dades guardades en forma de clau-valor , dels tipus suportats per MongoDB, i amb el format JSON (en realitat BSON) Per tant, en Mongo no hi ha taules. Mirem uns exemples de documents JSON per a guardar la informaci\u00f3 de llibres i autors. Depenen de com s'haja d'accedir a la informaci\u00f3 ens podem plantejar guardar els llibres amb els seus autors, o guardar els autors, amb els seus llibres. Fins i tot ens podr\u00edem guardar els dos, per a poder accedir de totes les maneres, encara que \u00e9s a costa de doblar la informaci\u00f3. De la primera manera, guardant els llibres amb el seu autor, podr\u00edem tenir documents amb aquesta estructura, que es podrien guardar en una col\u00b7lecci\u00f3 anomenada Llibres : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observeu com els objectes no tenen per qu\u00e8 tenir la mateixa estructura. La manera d'accedir al nom d'un autor seria aquesta: objecte.autor.nom Una manera alternativa de guardar la informaci\u00f3, com hav\u00edem comentat abans seria organitzar per autors, amb els seus llibres. D'aquesta manera podr\u00edem anar omplint la col\u00b7lecci\u00f3 Autors amb un o m\u00e9s documents d'aquest estil: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observeu com per a un autor, ara tenim un array ( els claud\u00e0tors: [ ] ) amb els seus llibres. Quina de les dues maneres \u00e9s millor per a guardar la informaci\u00f3? Doncs dep\u00e9n de l'acc\u00e9s que s'haja de fer a les dades. La millor ser\u00e0 segurament aquella que depenent dels accessos que s'hagen de fer, torne la informaci\u00f3 de forma m\u00e9s r\u00e0pida.","title":"3 - MongoDB"},{"location":"3__mongodb/#31-estructura-json","text":"Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veja'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes, que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames , que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu","title":"3.1 - Estructura JSON"},{"location":"3__mongodb/#32-installacio-de-mongodb","text":"Podrem instal\u00b7lar MongoDB en qualsevol plataforma. I fins i tot sense tenir permisos d'administrador, com veurem en el cas d'Ubuntu. Tamb\u00e9 est\u00e0 la possibilitat de crear un servidor en el n\u00favol, fins i tot gratu\u00eft. \u00c9s l'opci\u00f3 que ens suggereix Mongo per defecte, per\u00f2 nosaltres no la utilitzarem.","title":"3.2 - Instal\u00b7laci\u00f3 de MongoDB"},{"location":"3__mongodb/#installacio-en-linux","text":"Per a poder fer la instal\u00b7laci\u00f3 m\u00e9s b\u00e0sica, podrem fer-lo sense permisos d'administrador. Si els tenim tot \u00e9s m\u00e9s c\u00f2mode, per\u00f2 si no en tenim tamb\u00e9 ho podem fer, com veurem i remarcarem a continuaci\u00f3. Instal\u00b7laci\u00f3 del servidor (Linux) De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/community ) anem al men\u00fa Products - > Comunity Edition ->Comunity Server i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions. I millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , aquest fitxer \u00e9s: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.0.5.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. Senzillament descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. Per defecte el directori de la Base de Dades \u00e9s /data/db L'\u00fanic problema que podr\u00edem tenir si no som administradors \u00e9s que no tinguem perm\u00eds per crear aquest directori. Aleshores crearem un altre directori i en el moment d'arrancar el servidor, li especificarem aquest lloc. La manera d'arrancar el servidor ser\u00e0: <directori arrel MongoDB>./bin/mongod Opcionalment li podem dir on est\u00e0 la Base de Dades (si no ho especifiquem assumir\u00e0 que est\u00e0 en /data/db ): <directori arrel MongoDB>./bin/mongod --dbpath <directori de la BD> Resumint, i estant situats al directori on hem descomprimit MongoDB: Creem el directori de dades: mkdir /data mkdir /data/db Si no som administradors, arranquem el servidor: ./bin/mongod --dbpath ./data/db Si som administradors, arranquem el servidor: ./bin/mongod La seg\u00fcent imatge il\u00b7lustra aquesta segona opci\u00f3. Est\u00e0 per a una versi\u00f3 anterior de MongoDB, per\u00f2 \u00e9s totalment equivalent: Nota Una vegada en marxa el servidor, no hem de tancar aquesta terminal, ja que parar\u00edem el servidor. Instal\u00b7laci\u00f3 del client MongoShell (Linux) De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/shell ) anem al men\u00fa Products - > Tools ->MongoDB Shell i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions, i millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , triarem l'opi\u00f3 gen\u00e8rica Linux 64 ja que \u00e9s la opci\u00f3 que t\u00e9 el paquet tgz , i aquest fitxer \u00e9s: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. Senzillament descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. Per a connectar un client, obrim una segona terminal i executem el client mongosh : <directori arrel Mongosh>/bin/mongosh ./bin/mongosh","title":"Instal\u00b7laci\u00f3 en Linux"},{"location":"3__mongodb/#installacio-en-windows","text":"Instal\u00b7laci\u00f3 del servidor (Windows) No ofereix cap dificultat. Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows, que resultar\u00e0 ser un .msi directament executable. En el moment de fer aquestos apunts, la versi\u00f3 de 64 bits \u00e9s la 8.0.5: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.0.5-signed.msi Com en el cas de Linux, abans d'executar el servidor haurem de tenir el directori creat. Per defecte el directori ser\u00e0 \\data\\db Aqueste serien les ordres per a crear el directori i despr\u00e9s arrancar el servidor. mkdir \\data\\db C:\\Program Files\\MongoDB\\Server\\8.0\\bin\\mongod.exe Hauria d'apar\u00e8ixer la imatge seg\u00fcent Nota Si vas instal\u00b7lar MongoDB amb el MongoDB MSI Installer, normalment el servei ja estar\u00e0 instal\u00b7lat i no caldr\u00e0 executar-lo. Instal\u00b7laci\u00f3 del client MongoShell (Windows) Per a connectar-nos com a clients, ho haurem de fer des d'una altra terminal, amb mongosh.exe , que \u00e9s la interf\u00edcie de l\u00ednia d'ordres (CLI) oficial de MongoDB, utilitzada per interactuar amb la base de dades mitjan\u00e7ant ordres en JavaScript: Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Mongo Compass Tamb\u00e9 us podeu descarregar la versi\u00f3 MongoDB Compass , que \u00e9s l'eina gr\u00e0fica oficial de MongoDB que permet visualitzar, explorar i administrar bases de dades de MongoDB sense necessitat d'utilitzar la l\u00ednia de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe Probar el funcionament Per a provar el seu funcionament, anem a fer un parell de comandos: un per a guardar un document i un altre per a reculerar-lo. Per a qualsevol operaci\u00f3 s'ha de posar db seguit del nom de la col\u00b7lecci\u00f3, i despr\u00e9s l'operaci\u00f3 que volem fer. Amb el sg\u00fcent: db.exemple.insertOne( {msg:\"Hola, qu\u00e8 tal?\"} ) Ens contestar\u00e0: WriteResult({ \"nInserted\" : 1 }) Indicant que ha inserit un document en la col\u00b7lecci\u00f3 exemple (si no estava creada, la crear\u00e0). I amb el seg\u00fcent comando recuperem la informaci\u00f3: db.exemple.find() Que ens tornar\u00e0: { \"_id\" : ObjectId(\"56cc1acd73b559230de8f71b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } Tot ho fa en la mateixa terminal, i a cadasc\u00fa de nosaltres ens donar\u00e0 un n\u00famero diferent en ObjectId . En la seg\u00fcent imatge es veuen les dues operacions: En realitat estem connectats a una Base de Dades anomenada test . Podem crear i utilitzar m\u00e9s d'una Base de Dades, per\u00f2 en aquest curs tindr\u00e9s m\u00e9s que suficient amb aquesta Base de Dades. Per a comprovar-ho podem executar la seg\u00fcent sent\u00e8ncia, que ens torna el nom de la Base de Dades: db.getName() test","title":"Instal\u00b7laci\u00f3 en Windows"},{"location":"3__mongodb/#33-utilitzacio-de-mongodb","text":"Comen\u00e7arem la utilitzaci\u00f3 de MongoDB des de la consola que hav\u00edem arrancat al final de la instal\u00b7laci\u00f3. Recordeu que tindrem dues teminals: Una amb el servidor en marxa (i que no hem de tancar): mongod Una altra amb el client que es connecta al servidor: mongosh En aquesta \u00faltima consola del client podem utilitzar sent\u00e8ncies del llenguatge Javascipt , per\u00f2 el que m\u00e9s ens interessar\u00e0, evidentment, s\u00f3n les sent\u00e8ncies d'acc\u00e9s a dades. Del llenguatge Javascript pr\u00e0cticament l'\u00fanic que utilitzarem s\u00f3n variables i algunes funcions. Utilitzaci\u00f3 de variables Com coment\u00e0vem el que m\u00e9s utilitzarem del llenguatge Javascript \u00e9s la utilitzaci\u00f3 de variables, que ens pot ser molt \u00fatil en algunes ocasions. Podrem utilitzar-les durant la sessi\u00f3, per\u00f2 evidentment no perduraran d'una sessi\u00f3 a l'altra. Per a definir una variable podem posar opcionalment davant la paraula reservada var , per\u00f2 no \u00e9s necessari. Posarem el nom de la variable, el signe igual, i a continuaci\u00f3 el valor de la variable, que pot ser una constant, o una expressi\u00f3 utilitzant constants, operadors, altres variables, funcions de Javascript, ... Especialment interessant s\u00f3n les variables que poden contenir un document JSON. Per exemple: > a = 30 30 > b = a/4 7.5 > Math.sqrt(b) 2.7386127875258306 > doc = {camp1: \"Hola\", camp2: 45, camp3: new Date()} { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\") } > Una variable de tipus JSON es podr\u00e0 modificar molt f\u00e0cilment, tota ella, o algun dels elements. Per a arribar als elements posarem nom_variable.nom_camp : > doc.camp4 = 3.141592 3.141592 > doc.camp5 = [ 2 , 4 , 6 , 8] [ 2, 4, 6, 8 ] I si ara intentem traure el contingut de la variable: > doc { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\"), \"camp4\" : 3.141592, \"camp5\" : [ 2, 4, 6, 8 ] } > Tamb\u00e9 hem de fer constar que en un document, que ser\u00e0 de tipus JSON (pr\u00e0cticament), ser\u00e0 un conjunt de parelles clau-valor, amb algunes restriccions: El document (que moltes vegades l'associarem a objecte de JSON) va entre claus ( { } ) Els elements d'un objecte van separats per comes, i s\u00f3n parelles clau-valor. La clau no pot ser nula, ni repetir-se en el mateix objecte (s\u00ed en diferents objectes, clar) Els valors s\u00f3n dels tipus que veurem en la pregunta 3.2.1 Un document guardat ha de contenir obligat\u00f2riament un camp anomenat _id , i que contindr\u00e0 un valor \u00fanic en la col\u00b7lecci\u00f3 i servir\u00e0 per a identificar-lo. Si en guardar un document no li hem posat camp _id , el generar\u00e0 autom\u00e0ticament MongoDB.","title":"3.3 - Utilitzaci\u00f3 de MongoDB"},{"location":"3__mongodb/#331-tipus-de-dades","text":"Els valors dels elements, \u00e9s a dir de les parelles clau valor, poden ser d'uns quants tipus. Fem un r\u00e0pid rep\u00e0s. En els exemples que van a continuaci\u00f3 definim senzillament parelles clau-valor dels diferents tipus, o en tot cas ens ho guardem en variables, per\u00f2 no guardarem encara en la Base de Dades (ho farem en la seg\u00fcent pregunta). Quan guardem en una variable es mostrar\u00e0 el prompt, la definici\u00f3 de la variable i despr\u00e9s el resultat d'haver guardat la variable. Utilitzarem requadres blancs. Els requadres grocs s\u00f3n \u00fanicament de la definici\u00f3 d'una clau-valor d'un determinat tipus NULL M\u00e9s que un tipus de dades \u00e9s un valor, millor dit, l'abs\u00e8ncia de valor { \"x\" : null } BOOLEAN El tipus boole\u00e0, que pot agafar els valors true o false. { \"x\" : true } { \"y\" : false } NUMBER Per defecte, el tiups de dades num\u00e8rics ser\u00e0 el de coma flotant ( float ), simple precisi\u00f3. Si volem un altre tiups (enter, doble precisi\u00f3, ...) ho haurem d'indicar expressament. Aix\u00ed els dos seg\u00fcents valors s\u00f3n float: { \"x\" : 3.14 } { \"y\" : 3 } Si volem que siga estrictament enter, per exemple, haurem d'utilitzar una funci\u00f3 de conversi\u00f3: { \"x\" : NumberDouble(\"3.14\") } { \"y\" : NumberInt(\"3\") } STRING Es pot guardar qualsevol cadena amb car\u00e0cters de la codificaci\u00f3 UTF-8 { x : \"Hola, qu\u00e8 tal?\"} DATE Es guarda data i hora, i internament es guarden en milisegons des de l'any inicial. No es guarda el Time zone , \u00e9s a dir, la desviaci\u00f3 respecte a l'hora internacional. { x : ISODate(\"2022-01-16T11:15:27.471Z\") } Normalment utilitzarem funcions de tractament de la data-hora. L'anterior era per a convertir el string en data-hora. La seg\u00fcent \u00e9s per a obtenir la data- hora actual: { x : new Date() } \u00c9s a dir, que si no posem par\u00e0metre, ens d\u00f3na la data-hora actual. Per\u00f2 li podem posar com a par\u00e0metre la data-hora que volem que genere. En aquest exemple, nom\u00e9s posem data, per tant l'hora ser\u00e0 les 00:00: > z = new Date(\"2022-01-16\") ISODate(\"2022-01-16T00:00:00Z\") En aquest s\u00ed que posem una determinada hora, i observeu com hem deposar la T (Time) entre el dia i l'hora: > z = new Date(\"2022-02-16T18:00\") ISODate(\"2022-01-16T18:00:00Z\") \u00c9s molt important que posem sempre New Date() per a generar una data-hora. Si posem \u00fanicament Date() , el que estem generant \u00e9s un string (segurament amb la data i hora actual, per\u00f2 un string): > z = Date(\"2022-01-16\") Sun Jan 16 2022 22:20:09 GMT+0100 (CET) ARRAY \u00c9s un conjunt d'elements, cadascun de qualsevol tipus, encara que el m\u00e9s habitual \u00e9s que siguen del mateix tipus. Van entre claud\u00e0tors ( [ ] ) i els elements separats per comes. { x : [ 2 , 4 , 6 , 8 ] } Com coment\u00e0vem, cada element de l'array pot ser de qualsevol tipus: { y : [ 2 , 3.14 , \"Hola\" , new Date() ] } En MongoDB podrem treballar molt b\u00e9 amb arrays, i tindrem operacions per a poder buscar dins de l'array, modificar un element, crear \u00edndex, ... DOCUMENTS (OBJECTES) Els documents poden contenir com a elements uns altres documents ( objectes en la terminologia JSON, per\u00f2 documents en la terminologia de MongoDB). Van entre claus ( { } ), i els elements que contindran van separats per comes i seran parelles clau-valor de qualsevol tipus (fins i tot altres documents). { x : { a : 1 , b : 2 } } Posar documents dins d'uns altres documents (el que s'anomena embedded document ) ens permet guardar la informaci\u00f3 d'una manera m\u00e9s real, no tan plana. Aix\u00ed per exemple, les dades d'una persona les podr\u00edem definir de la seg\u00fcent manera. Les posarem en una variable, per veure despr\u00e9s com podem accedir als diferents elements, encara que el m\u00e9s normal ser\u00e0 guardar-lo en la Base de Dades (amb insert() ). Si copiem el que va a continuaci\u00f3 al terminal de Mongo, ens apareixer\u00e0 amb un format estrany. \u00c9s perqu\u00e8 la sent\u00e8ncia d'assignaci\u00f3 a la variable ocupa m\u00e9s d'una l\u00ednia, i apareixeran 3 punts al principi per a indicar que continua la sent\u00e8ncia. Per\u00f2 funcionar\u00e0 perfectament : doc = { n om : \"Joan Mart\u00ed\" , adre\u00e7a : { carrer : \"Major\" , n \u00famero : 1 , poblaci\u00f3 : \"Castell\u00f3\" } , tel \u00e8 f o ns : [ 964223344 , 678345123 ] } Observeu com aquesta estructura que ha quedat tan clara, segurament en una Base de Dades Relacional ens hauria tocat guardar en 3 taules: la de persones, la d'adreces i la de tel\u00e8fons. Per a accedir als elements d'un document pos\u00e0vem el punt. Doncs el mateix per als elements d'un document dins d'un document. I tamb\u00e9 podem accedir als elements d'un array, posant l'\u00edndex entre claud\u00e0tors. > doc.nom Joan Mart\u00ed > doc.adre\u00e7a { \"carrer\" : \"Major\", \"n\u00famero\" : 1, \"poblaci\u00f3\" : \"Castell\u00f3\" } > doc.adre\u00e7a.carrer Major > doc.tel\u00e8fons [ 964223344, 678345123 ] > doc.tel\u00e8fons[0] 964223344 OBJECT ID \u00c9s un tipus que defineix MongoDB per a poder obtenir valors \u00fanics. \u00c9s el valor per defecte de l'element _id , necessari en tot document (atenci\u00f3: en un document, no en un element de tipus document que hem dit equivalent a l'objecte de JSON). \u00c9s un n\u00famero long, \u00e9s a dir que utilitza 24 bytes. Farem proves de la seua utilitzaci\u00f3 en la se\u00fcent pregunta, en el moment d'inserir diferents documents.","title":"3.3.1 - Tipus de dades"},{"location":"3__mongodb/#332-operacions-basiques","text":"En aquest punt anem a veure les operacions m\u00e9s b\u00e0siques, per a poder treballar sobre exemples pr\u00e0ctics, i aix\u00ed disposar ja d'unes dades inicials per a practicar.","title":"3.3.2 - Operacions b\u00e0siques"},{"location":"3__mongodb/#insercio-elemental-insert","text":"La funci\u00f3 insert afegir\u00e0 documents a una col\u00b7lecci\u00f3. En el par\u00e0metre posem el document directament, o una variable que continga el document. Si la col\u00b7lecci\u00f3 no existia, la crear\u00e0 i despr\u00e9s afegir\u00e0 el document. En la seg\u00fcent sent\u00e8ncia estem treballant sobre la col\u00b7lecci\u00f3 exemple , que segurament ja existir\u00e0 de quan vam fer la pregunta 3.1 d'instal\u00b7laci\u00f3 de MongoDB, que per a provar vam inserir un document. Per\u00f2 si no existia, la crear\u00e0 sense problemes. > db.exemple.insert({ msg2 : \"Com va la cosa?\"}) WriteResult({ \"nInserted\" : 1 }) Acabem d'inserir un nou document, i aix\u00ed ens ho avisa ( { \"nInserted\" : 1 } , s'ha inserit un document). Autom\u00e0ticament haur\u00e0 creat un element _id de tipus ObjectId , ja que li fa falta per a identificar el document entre tots els altres de la col\u00b7lecci\u00f3. I en aquest exemple ens guardem el document en la variable doc , i despr\u00e9s l'inserim > doc = { msg3 : \"Per ac\u00ed no ens podem queixar ...\"} { \"msg3\" : \"Per ac\u00ed no ens podem queixar ...\" } > db.exemple.insert(doc) WriteResult({ \"nInserted\" : 1 }) Tamb\u00e9 ens indica que ha inserit un document. I haur\u00e0 creat tamb\u00e9 el camp _id com veurem en el seg\u00fcent punt.","title":"Inserci\u00f3 elemental: insert"},{"location":"3__mongodb/#lectura-find","text":"Tenim dues funcions per a recuperar informaci\u00f3: find i findOne . find() : recuperar\u00e0 tots els documents de la col\u00b7lecci\u00f3, encara que podrem posar criteris per a que ens torne tots els documents que acomplesquen aquestos criteris (ho veurem m\u00e9s avant). findOne() : nom\u00e9s tornar\u00e0 un document, en principi el primer. Pot ser sobre tots els documents (i per tant seria el primer document), o posar una condici\u00f3, i tornaria el primer que acomplir\u00e0 la condici\u00f3. Exemple de find() : > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } { \"_id\" : ObjectId(\"56ce3237c61e04ba81def50d\"), \"msg3\" : \"Per ac\u00ed no ens podem queixar ...\" } > Exemple de findOne() : > db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } > En tots els casos podem comprovar que \u00e9s cert el que ven\u00edem afirmant, que ha creat autom\u00e0ticament l'element _id per a cada document guardat. Evidentment, cadasc\u00fa de nosaltres tindr\u00e0 una valors diferents. Inserci\u00f3 especificant el id Ara que ja sabem consultar els document de la col\u00b7lecci\u00f3 amb find() anem a continuar les insercions de documents, per veure les possibilitats que tenim. En els document que hem inserit fins el moment, no hem especificat el camp _id , i Mongo l'ha generat autom\u00e0ticament de tipus ObjectId . Per\u00f2 nosaltres podrem posar aquest camp _id amb el valor que vulguem. Aix\u00f2 s\u00ed, haurem d'estar segurs que aquest valor no l'agafa cap altre document de la col\u00b7lecci\u00f3, o ens donar\u00e0 un error. Aix\u00ed per exemple anem a inserir la informaci\u00f3 d'uns alumnes. Els posarem en una col\u00b7lecci\u00f3 nova anomenada alumnes , i els intentarem posar un _id personal. Per exemple posarem els n\u00fameros 51, 52, 53, ... > db.alumnes.insert ({_id: 51 , nom: \"Rebeca\" , cognoms: \"Mart\u00ed Peral\"}) WriteResult({ \"nInserted\" : 1 }) Ha anat b\u00e9, i si mirem els documents que tenim en la col\u00b7lecci\u00f3, comprovarem que ens ha respectat el _id : > db.alumnes.find() { \"_id\" : 51, \"nom\" : \"Rebeca\", \"cognoms\" : \"Mart\u00ed Peral\" } > Per\u00f2 si intentem inserir un altre document amb el mateix _id (51), ens donar\u00e0 error: > db.alumnes.insert ({_id: 51 , nom: \"Raquel\" , cognoms: \"Gomis Arnau\"}) WriteResult({ \"nInserted\" : 0, \"writeError\" : { \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: test.alumnes index: _id_ dup key: { : 51.0 }\" } }) > Ens avisa que estem duplicant la clau principal , \u00e9s a dir l'identificador.","title":"Lectura: find"},{"location":"3__mongodb/#insercio-multiple","text":"Quan els documents que volem inserir s\u00f3n senzills, podem inserir m\u00e9s d'un a la vegada, posant dis del insert() un array amb tots els elements. En el seg\u00fcent exemple creem uns quants nombres primers en la col\u00b7lecci\u00f3 del mateix nom: > db.nombresprimers.insert( [ {_id:2} , {_id:3} , {_id:5} , {_id:7} , {_id:11} > , {_id:13} , {_id:17} , {_id:19} ] ) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 8, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) > Ens avisa que ha fet 8 insercions, i ac\u00ed els tenim: > db.nombresprimers.find() { \"_id\" : 2 } { \"_id\" : 3 } { \"_id\" : 5 } { \"_id\" : 7 } { \"_id\" : 11 } { \"_id\" : 13 } { \"_id\" : 17 } { \"_id\" : 19 } >","title":"Inserci\u00f3 m\u00faltiple"},{"location":"3__mongodb/#esborrat-remove","text":"Per a esborrar un document d 'una col\u00b7lecci\u00f3 utilitzarem la funci\u00f3 remove , passant-li com a par\u00e0metre la condici\u00f3 del document o documents a esborrar. > db.nombresprimers.remove( {\"_id\" : 19} ) WriteResult({ \"nRemoved\" : 1 }) > Ens avisa que ha esborrat un document. La condici\u00f3 no cal que siga sobre el camp _id . Pot ser sobre qualsevol camp, i esborrar\u00e0 tots els que coincideixen. > db.exemple.remove( {\"msg3\" : \"Per ac\u00ed no ens podem queixar ...\"} ) WriteResult({ \"nRemoved\" : 1 }) > Tamb\u00e9 tenim la possibilitat d'esborrar tota una col\u00b7lecci\u00f3 amb la funci\u00f3 drop() . Pareu atenci\u00f3 perqu\u00e8 \u00e9s molt senzilla d'eliminar, i per tant, potencialment molt perillosa. > db.nombresprimers.drop() true >","title":"Esborrat: remove"},{"location":"3__mongodb/#actualitzacio-update","text":"La funci\u00f3 update servir\u00e0 per a actualitzar un document ja guardat. Tindr\u00e0 dos par\u00e0metres: El primer par\u00e0metre ser\u00e0 la condici\u00f3 per a trobar el document que s'ha d'actualitzar. El segon par\u00e0metre ser\u00e0 el nou document que substituir\u00e0 l'anterior Per exemple, si mirem les dades actuals: > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } Podem comprovar el contingut del segon document, el que te msg2 . Anem a modificar-lo: en el primer par\u00e0metre posem condici\u00f3 de recerca (nom\u00e9s hi haur\u00e0 un) i en el segon posem el nou document que substituir\u00e0 l'anterior > db.exemple.update( {msg2:\"Com va la cosa?\"} , {msg2:\"Qu\u00e8? Com va la cosa?\"}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) Observeu que la contestaci\u00f3 del update () \u00e9s que ha fet match (hi ha hagut coincid\u00e8ncia) amb un document, i que ha modificat un. Si no en troba cap, no donar\u00e0 error, senzillament dir\u00e0 que ha fet match amb 0 documents, i que ha modificat 0 documents. Mirem com efectivament ha canviat el segon document > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Qu\u00e8? Com va la cosa?\" } Ens vindran molt b\u00e9 les variables per a les actualitzacions, ja que en moltes ocasions ser\u00e0 modificar lleugerament el document, canviant o afegint algun element. Ho podrem fer c\u00f2modament amb la variable: primer guardem el document a modificar en una variable; despr\u00e9s modifiquem la variable; i per \u00faltim fem l'operaci\u00f3 d'actualitzaci\u00f3. Evidentment si tenim alguna variable amb el contingut del document ens podr\u00edem estalviar el primer pas. > doc1 = db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } > doc1.titol = \"Missatge 1\" Missatge 1 > db.exemple.update( {msg:\"Hola, qu\u00e8 tal?\"} , doc1) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\", \"titol\" : \"Missatge 1\" } >","title":"Actualitzaci\u00f3 - update"},{"location":"3__mongodb/#333-operacions-dactualitzacio-avancada","text":"Al final de la pregunta anterior hem vist l'actualitzaci\u00f3 de documents ja existents a la Base de Dades. Aquesta actualitzaci\u00f3 la f\u00e9iem modificant tot el document, encara que tenim la variant de guardar el document en una variable, modificar aquesta variable i despr\u00e9s fer l'actualitzaci\u00f3 amb aquesta variable. Per\u00f2 observeu que continua sent una modificaci\u00f3 de tot el document, una substituci\u00f3 del document antic per un document nou. En aquesta pregunta veurem la utilitzaci\u00f3 d'uns modificadors ( modifiers ) de l'operaci\u00f3 update() , que ens permetran modificar documents de forma potent: creant i eliminant claus (elements) d'un document, o canviant-los, i fins i tot afegir o eliminar elements d'un array.","title":"3.3.3 - Operacions d'actualitzaci\u00f3 avan\u00e7ada"},{"location":"3__mongodb/#set","text":"El modificador $set assigna un valor a un camp del document seleccionat de la Base de Dades. Si el camp ja existia, modificar\u00e0 el valor, i si no existia el crear\u00e0. La sintaxi del modificador $set \u00e9s la seg\u00fcent: { $set : { clau : valor} } Per\u00f2 recordeu que \u00e9s un modificador, i l'hem d'utilitzar dins d'una operaci\u00f3 d'actualitzaci\u00f3. Anir\u00e0 en el segon par\u00e0metre del update() , i per tant amb aquestos modificadors ja no posem tot el document en el segon par\u00e0metre, sin\u00f3 \u00fanicament l'operador de modificaci\u00f3. Mirem-ho millor en un exemple: > db.alumnes.insert( {nom:\"Abel\", cognoms:\"Bernat Carrera\"} ) WriteResult({ \"nInserted\" : 1 }) > > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\" } > Suposem ara que li volem afegir l'edat. Abans ho far\u00edem guardant el document en una variable, i afegint el camp, per a guardar despr\u00e9s. Ara ho tenim m\u00e9s f\u00e0cil: > db.alumnes.update( {nom:\"Abel\"} , { $set: {edat:21} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) Ha trobat un, i l'ha modificat. Evidentment, si hi haguera m\u00e9s d'un alumne a mb el nom Abel, els modificaria tots. > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 21 } Es pot especificar m\u00e9s d'un camp amb els valor corresponents. Si no existien es crearan, i si ja existien es modificaran: > db.alumnes.update( {nom:\"Abel\"} , { $set: {nota: 8.5 , edat:22} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : 8.5 } I fins i tot es pot canviar el tipus d'un camp determinat, i utilitzar arrays, i objectes, ... > db.alumnes.update( {nom:\"Abel\"} , { $set: {nota: [8.5,7.5,9] , > adre\u00e7a:{carrer:\"Major\",numero:7,cp:\"12001\"} } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12001\" } } Podem fins i tot modificar ara nom\u00e9s el valor d'un camp d'un objecte del document. Per exemple, anem a modificar el codi postal de l'anterior alumne. La manera d'arribar al codi postal ser\u00e0 adre\u00e7a.cp , per\u00f2 haurem d'anar amb compte que vaja entre cometes per a que el trobe: > db.alumnes.update( {nom:\"Abel\"} , { $set: {adre\u00e7a.cp:\"12502\"} } ) uncaught exception: SyntaxError: missing : after property id : @(shell):1:49 > db.alumnes.update( {nom:\"Abel\"} , { $set: {\"adre\u00e7a.cp\":\"12502\"} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } }","title":"$set"},{"location":"3__mongodb/#unset","text":"El modificador $unset servir\u00e0 per a eliminar elements (camps) d'un o uns documents. Si el camp existia, l'eliminar\u00e0, i si no existia, no donar\u00e0 error (avisar\u00e0 que s'han modificat 0 documents). La sintaxi \u00e9s: { $unset : {camp : 1 } } Haurem de posar un valor al camp que anem a esborrar per a mantenir la sintaxi correcta, i posem 1 que equival a true. Tamb\u00e9 podr\u00edem posar -1, que equival a false, per\u00f2 aleshores no l'esborraria, i per tant no far\u00edem res. Sempre posarem 1. Mirem el seg\u00fcent exemple. Afegim un camp, que ser\u00e0 el n\u00famero d'ordre, i despr\u00e9s el llevarem. > db.alumnes.update( {nom:\"Abel\"} , { $set: {num_ordre:10} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"num_ordre\" : 10 } > db.alumnes.update( {nom:\"Abel\"} , { $unset: {num_ordre:1} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.update( {nom:\"Abel\"} , { $unset: {puntuacio:1} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 0 }) Hem afegit primer el camp num_ordre , i hem mostrat el document per comprovar que existeix. Despr\u00e9s esborrem el camp num_ordre (i ens confirma que ha modificat un document). Despr\u00e9s intentem esborrar un camp que no existeix, puntuacio . No d\u00f3na error, per\u00f2 ens avisa que ha modificat 0 documents. Podem comprovar al final com el document ha quedat com esper\u00e0vem. > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } }","title":"$unset"},{"location":"3__mongodb/#rename","text":"El modificador $rename canviar\u00e0 el nom d'un camp. Si no existia, no donar\u00e0 error i senzillament no el modificar\u00e0. Hem de cuidar de posar el nou nom del camp entre cometes, per a que no done error. La sintaxi \u00e9s: { $rename : { camp1 : \"nou_nom1\" , camp2 : \"nou_nom2\" , ... } } Per exemple, canviem el nom del camp nota a notes : > db.alumnes.update( {nom:\"Abel\"} , { $rename: {nota:\"notes\"} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"notes\" : [ 8.5, 7.5, 9 ] } Observeu que l'ha canviat de lloc, cosa que ens fa pensar que en canviar de nom un camp, el que fa \u00e9s tornar a crear-lo amb el nou nom, i esborrar el camp antic. En aquest exemple tornem a canviar el nom a nota , i intentem canviar el nom a un camp inexistent, camp1 . No donar\u00e0 error. > db.alumnes.update( {nom:\"Abel\"} , { $rename: {camp1: \"camp2\" , notes:\"nota\"} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 8.5, 7.5, 9 ] }","title":"$rename"},{"location":"3__mongodb/#inc","text":"Com cabria esperar, el modificador $inc servir\u00e0 per a incrementar un camp num\u00e8ric. Si el camp existia, l'incrementar\u00e0 en la quantitat indicada. Si no existia, crear\u00e0 el camp amb un valor inicial de 0, i incrementar\u00e0 el valor amb la quantitat indicada. La quantitat pot ser positiva, negativa o fins i tot amb part fraccion\u00e0ria. Sempre funcionar\u00e0 b\u00e9, excepte quan el camp a incrementar no siga num\u00e8ric, que donar\u00e0 error. La sintaxi \u00e9s aquesta: { $inc : {camp : quantitat } } En els seg\u00fcents exemples, incrementem un camp nou (per tant el crear\u00e0 amb el valor especificat), i despr\u00e9s l'incrementem en quantitats positives, negatives i fraccion\u00e0ries, concretament l'inicialitzem amb un 2 , i desp\u00e9s l'incrementem en 5 , en -4 i en 2.25 , per tant el resultat final ser\u00e0 5.25 : > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:2} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 2 } > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:5} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:-4} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.update( {nom:\"Abel\"} , { $inc: {puntuacio:2.25} } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 5.25 }","title":"$inc"},{"location":"3__mongodb/#elements-dun-array","text":"Per a accedir directament a un element d'un array d'un determinat document es pot utilitzar la seg\u00fcent sintaxi: \"array.index\" Hem de tenir present que el primer element de l'array \u00e9s el de sub\u00edndex 0. I no us oblideu de tancar-ho tot entre comentes per a que ho puga trobar. Si no existeix l'element amb el sub\u00edndex indicat, donar\u00e0 error. Per exemple, anem a pujar un punt la primera nota de l'alumne que estem utilitzant en tots els exemples : >db.alumnes.update( {nom:\"Abel\"} , { $inc : { \"nota.0\" : 1 } } ) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] }","title":"Elements d'un array"},{"location":"3__mongodb/#insercio-en-arrays-push","text":"La manera m\u00e9s senzilla d'introduir un element en un array \u00e9s utilitzar $push sense m\u00e9s. Si existia l'array, introduir\u00e0 el o els nous elements al final. Si no existia l'array, el crear\u00e0 amb aquest o aquestos elements. La sintaxi \u00e9s: { $push : { clau : element } } Per exemple anem a afegir una nota a l'alumne de sempre, i posem-la diferent per veure que s'introdueix al final: > db.alumnes.update( {nom:\"Abel\"} , { $push : { nota : 7 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7 ] } Tamb\u00e9 hi ha manera d'introduir un element en una determinada posici\u00f3 que no siga al final, per\u00f2 es complica prou la cosa, ja que hem d'utilitzar per una banda el modificador $position per a dir on s'ha d'inserir, i per una altra banda el modificador $each per a poder especificar el o els valors que es volen inserir. Es posa a continuaci\u00f3 \u00fanicament de forma il\u00b7lustrativa. Per a inserir en una determinada posici\u00f3 hem d'utilitzar obligat\u00f2riament 2 modificadors m\u00e9s: $position indicar\u00e0 a partir de quina posici\u00f3 es far\u00e0 l'acci\u00f3 (normalment d'inserir en l'array, \u00e9s a dir, $push ) $each ens permet especificar una s\u00e8rie de valors com un array, i vol dir que es far\u00e0 l'operaci\u00f3 per a cada valor de l'array Els dos modificadors seguiran la sintaxi de sempre, de clau valor, per tant el conjunt de la sintaxi \u00e9s: { $ push : { clau_del_array : { $position : _posici\u00f3_ , $each : [ _valors_ ] } } } Ac\u00ed tenim un exemple on introdu\u00efm una nota en la primera posici\u00f3: > db.alumnes.update( {nom:\"Abel\"} , { $push : { nota : { $position : 0 , $each > : [5] } } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] }","title":"Inserci\u00f3 en Arrays: $push"},{"location":"3__mongodb/#eliminacio-en-arrays-pop-i-pull","text":"Hi ha m\u00e9s d'una manera d'eliminar elements d'un array. $pop Si volem eliminar el primer element o l'\u00faltim, el modificador adequat \u00e9s $pop . La sintaxi \u00e9s { $pop : { clau : posicio } } On en posici\u00f3 podrem posar: -1 , i esborrar\u00e0 el primer element 1 , i esborrar\u00e0 l'\u00faltim En els seg\u00fcents exemples s'esborren primer l'\u00faltim element i despr\u00e9s el primer. > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] } > db.alumnes.update( {nom:\"Abel\"} , { $pop : { nota : 1 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9 ] } > db.alumnes.update( {nom:\"Abel\"} , { $pop : { nota : -1 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] } $pull Amb aquest modificador esborrarem els elements de l'array que coincidesquen amb una condici\u00f3, estiguen en la posici\u00f3 que estiguem. Observeu com es pot eliminar m\u00e9s d'un element. Per a poder comprovar-lo b\u00e9, primer inserim un altre element al final de l'array, amb el valor 7.5 (si heu seguit els mateixos exemples que en aquestos apunts, aquest valor ja es troba en la segona posici\u00f3). > db.alumnes.update( {nom:\"Abel\"} , { $push : { nota : 7.5 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7.5 ] } Ara anem a esborrar amb $pull l'element de valor 7.5 > db.alumnes.update( {nom:\"Abel\"} , { $pull : { nota : 7.5 } } ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.alumnes.findOne() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] }","title":"Eliminaci\u00f3 en arrays: $pop i $pull"},{"location":"3__mongodb/#upsert","text":"Aquesta paraula ja l'hav\u00edem comentada en un punt anterior. En el update() normal, si la condici\u00f3 de b\u00fasqueda no donava cap resultat (parlant r\u00e0pid, si no feis matching amb cap document), doncs no actualitzava cap document i punt. El Upsert \u00e9s una variant de l'update, que quan no coincidesca cap document amb la condici\u00f3, crear\u00e0 un document nou que ser\u00e0 el resultat de combinar el criteri que s'ha utilitzat en la condici\u00f3 amb les operacions d'actualitzaci\u00f3 fetes en el segon par\u00e0metre Per a que un Update actue d'aquesta manera, li hem de posar un tercer par\u00e0metre amb el valor true : update ( {...} , {...} , true ) Recordeu que el primer par\u00e0metre era la condici\u00f3, i el segon l'actualitzaci\u00f3. Mirem-ho en l'exemple dels alumnes. Si anem a actualitzar els cognoms, i es troba el document, s'actualitzar\u00e0: > db.alumnes.update( { nom:\"Abel\" } , { $set : { cognoms : \"Bernat Cantera\" }} , true ) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) Efectivament, ens diu que ha modificat un document. Per\u00f2 si no es troba el document (per exemple perqu\u00e8 li hem posat el nom Berta ): > db.alumnes.update( { nom:\"Berta\" } , { $set : { cognoms : \"Bernat Cantero\" }} , true ) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\") }) Ja ens avisa que no ha fet cap matching , i ha fet un Upsert . Ho podem comprovar mirant tots els document de la col\u00b7lecci\u00f3: > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } > El nou document tindr\u00e0 els camps: _id , amb el que ens havia avisat que generaria Els camps de la condici\u00f3, que en el nostre exemple \u00e9s { nom:\"Berta\" } Els camps de l'actualitzaci\u00f3, que en el nostre exemple eren els cognoms","title":"Upsert"},{"location":"3__mongodb/#34-consulta-de-documents","text":"En la pregunta anterior hem vist com introduir, eliminar i modificar documents. Les consultes de documents han segut molt senzilles, per a comprovar \u00fanicament els resultats. En aquesta pregunta veurem en profunditat la consulta de documents. Funcions find() i findOne() , que s\u00f3n les que hem utilitzat fina ara. Veurem en profunditat la seua sintaxi i pot\u00e8ncia. Limitarem i ordenarem tamb\u00e9 els resultats Fins i tot podrem elaborar m\u00e9s els resultats, agrupant els resultats, utilitzant funcions d'agregaci\u00f3 (o millor dir operadors d'agregaci\u00f3) i donant-los un aspecte diferent","title":"3.4 - Consulta de documents"},{"location":"3__mongodb/#341-parametres-de-les-funcions-find-i-findone","text":"Les funcions find() i findOne() s\u00f3n absolutament equivalents, amb l'\u00fanica difer\u00e8ncia que la primera torna tots els documents trobats, mentre que la segona nom\u00e9s torna el primer document trobat. Per una millor comprensi\u00f3, utilitzarem \u00fanicament find() , per veure tots els resultats obtinguts. La funci\u00f3 find() s'ha comparat tradicionalment amb la sent\u00e8ncia SELECT de SQL. Sempre tornar\u00e0 un conjunt de documents, que poden variar des de no tornar cap document, a tornar-los tots els de la col\u00b7lecci\u00f3. La funci\u00f3 find() pot tenir uns quants par\u00e0metres. El primer indica una condici\u00f3 o criteri, i tornar\u00e0 aquells documents de la col\u00b7lecci\u00f3 que acomplesquen la condici\u00f3 o criteri. Aquesta condici\u00f3 ve donada en forma de document (o objecte) JSON, i \u00e9s com l'hav\u00edem vist en la funci\u00f3 update() : db.col_leccio1.find( { clau1 : valor1 } ) Tornar\u00e0 tots els documents de la col\u00b7lecci\u00f3 col_leccio1 que tinguen el camp clau1 i que en ell tinguen el valor valor1 . Aquest criteri pot ser el complicat que fa\u00e7a falta, formant-lo en JSON. Pot tenir m\u00e9s d'un membre. En definitiva, tornar\u00e0 aquells documents que facen matching amb el document del criteri, \u00e9s a dir, funcionaria com un and en cas que tinga m\u00e9s d'un membre en la condici\u00f3 db.col_leccio1.find( { clau1 : valor1 , clau2 : valor2 } ) que tornaria aquells documents de la col_lecci\u00f31 que tenen el camp clau1 amb el valor valor1 i que tenen el camp clau2 amb el valor valor2 Si no volem posar cap criteri, per a que els torne tots, no posem res com a par\u00e0metre, o encara millor, li passem un document (objecte) buit, de manera que tots els documents de la col\u00b7lecci\u00f3 faran matching amb ell. db.col_leccio1.find( { } ) Tindrem a\u00e7\u00f2 present, sobretot quan ens toque utilitzar el segon par\u00e0metre de find . Si no volem cap criteri, posarem el document buit com l'exemple anterior. El segon par\u00e0metre ens servir\u00e0 per a delimitar els camps dels documents que es tornaran. Tamb\u00e9 tindr\u00e0 el format JSON d'un objecte al qual li posarem com a claus els diferents camps que volem que apareguen o no, i com a valor 1 per a que s\u00ed que apareguen i 0 per a que no apareguen. Si posem algun camp a que s\u00ed que aparega (\u00e9s a dir, amb el valor 1), els \u00fanics que apareixeran seran aquestos, a m\u00e9s del _id que per defecte sempre apareix. > db.alumnes.find({},{nom:1}) { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\" } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\" } Per tant si no volem que aparega _id posarem: > db.alumnes.find({},{_id:0}) { \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } I si volem traure \u00fanicament el nom: > db.alumnes.find({},{nom:1,_id:0}) { \"nom\" : \"Abel\" } { \"nom\" : \"Berta\" } Per \u00faltim, com que a partir d'ara utilitzarem documents m\u00e9s complicats, si volem que ens apareguen els camps que retornem d'una forma un poc m\u00e9s elegant o bonica ( pretty ), posarem aquesta funci\u00f3 al final: find().pretty() > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" }","title":"3.4.1 - Par\u00e0metres de les funcions find() i findOne()"},{"location":"3__mongodb/#342-operadors-de-les-condicions","text":"Abans de comen\u00e7ar aquesta pregunta, anem a agafar unes dades de prova, que estan en el fitxer libros_ejemplo.json Nom\u00e9s heu de copiar el contingut del fitxer en la terminal del client de Mongo. Posem ac\u00ed el contingut per a que pugueu pegar-li una miradeta sense necessitat d'obrir-lo. Anir\u00e0 b\u00e9 per als exemples posteriors. db.libro.insert({ \"_id\":\"9788408117117\", \"titulo\":\"Circo M\u00e1ximo\", \"autor\":\"Santiago Posteguillo\", \"editorial\":\"Planeta\", \"enstock\":true, \"paginas\":1100, \"precio\":21.75, \"fecha\":new ISODate(\"2013-08-29T00:00:00Z\"), \"resumen\":\"Circo M\u00e1ximo, de Santiago Posteguillo, que ha escrito otras obras de narrativa hist\u00f3rica como Las Legiones Malditas o La traici\u00f3n de Roma, es la segunda parte de la trilog\u00eda de Trajano, que comenz\u00f3 con Los asesinos del emperador, un relato impactante, descomunal, descrito con un trepidante pulso narrativo destinado a trasla dar al lector a la Roma imperial de los c\u00e9sares. Santiago posteguillo se ha convertido en el autor espa\u00f1ol de referencia de la novela hist\u00f3rica sobre Roma y el mundo antiguo. Bienvenidos al mundo de Marco Ulpio Trajano. Circo M\u00e1ximo es la historia de Trajano y su gobierno, guerras y traiciones, lealtades insobornables e historias de amor imposibles. Hay una vestal, un juicio, inocentes acusados, un abogado especial, mensajes cifrados, c\u00f3digos secretos, batallas campales, fortalezas inexpugnables, asedios sin fin, dos aurigas rivales, el Anfiteatro, los gladiadores y tres carreras de cuadrigas. Hay tambi\u00e9n un caballo especial, diferente a todos, leyes antiguas olvidadas, sacrificios humanos, amargura y terror, pero tambi\u00e9n destellos de nobleza y esperanza, como la llama de Vesta, que mientras arde preserva a Roma. S\u00f3lo que hay noches en las que la llama del Templo de Vesta tiembla. La rueda de la Fortuna comienza entonces a girar. En esos momentos, todo puede pasar y hasta la vida del propio Trajano, aunque \u00e9l no lo sepa, corre peligro. Y, esto es lo mejor de todo, ocurri\u00f3: hubo un complot para asesinar a Marco Ulpio Trajano.\" }) db.libro.insert({ \"_id\":\"9788401342158\", \"titulo\":\"El juego de Ripper\", \"autor\":\"Isabel Allende\", \"editorial\":\"Plaza & Janes\", \"enstock\":true, \"paginas\":480, \"precio\":21.75, \"fecha\":new ISODate(\"2014-03-01T00:00:00Z\"), \"resumen\":\"Tal como predijo la astr\u00f3loga m\u00e1s reputada de San Francisco, una oleada de cr\u00edmenes comienza a sacudir la ciudad. En la investigaci\u00f3n sobre los asesinatos, el inspector Bob Mart\u00edn recibir\u00e1 la ayuda inesperada de un grupo de internautas especializados en juegos de rol, Ripper. 'Mi madre todav\u00eda est\u00e1 viva, pero la matar\u00e1 el Viernes Santo a medianoche', le advirti\u00f3 Amanda Mart\u00edn al inspector jefe y \u00e9ste no lo puso en duda, porque la chica hab\u00eda dado pruebas de saber m\u00e1s que \u00e9l y todos sus colegas del Departamento de Homicidios. La mujer estaba cautiva en alg\u00fan punto de los dieciocho mil kil\u00f3metros cuadrados de la bah\u00eda de San Francisco, ten\u00edan pocas horas para encontrarla con vida y \u00e9l no sab\u00eda por d\u00f3nde empezar a buscarla\", }) db.libro.insert({ \"_id\":\"9788496208919\", \"titulo\":\"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"autor\":\"George R.R. Martin\", \"editorial\":\"Gigamesh\", \"enstock\":true, \"paginas\":793, \"precio\":9.5, \"fecha\":new ISODate(\"2011-11-24T00:00:00Z\"), \"resumen\":\"Tras el largo verano, el invierno se acerca a los Siete Reinos. Lord Eddars Stark, se\u00f1or de Invernalia, deja sus dominios para unirse a la corte del rey Robert Baratheon el Usurpador, hombre d\u00edscolo y otrora guerrero audaz cuyas mayores aficiones son comer, beber y engendrar bastardos. Eddard Stark desempe\u00f1ar\u00e1 el cargo de M ano del Rey e intentar\u00e1 desentra\u00f1ar una mara\u00f1a de intrigas que pondr\u00e1 en peligro su vida... y la de los suyos. En un mundo cuyas estaciones duran d\u00e9cadas y en el que retazos de una magia inmemorial y olvidada surgen en los rincones m\u00e1s sombrios y maravillosos, la traici\u00f3n y la lealtad, la compasi\u00f3n y la sed de venganza, el amor y el poder hacen del juego de tronos una poderosa trampa que atrapa en sus fauces a los personajes... y al lector. 'El regreso triunfal de Martin a la fantas\u00eda de m\u00e1s alta calidad... con personajes desarrollados con maestr\u00eda, prosa h\u00e1bil y pura obstinaci\u00f3n.'\" }) db.libro.insert({ \"_id\":\"9788499088075\", \"titulo\":\"La ladrona de libros\", \"autor\":\"Markus Zusak\", \"editorial\":\"Debolsillo\", \"enstock\":false, \"paginas\":544, \"precio\":9.45, \"fecha\":new ISODate(\"2009-01-09T00:00:00Z\"), \"resumen\":\"En plena II Guerra Mundial, la peque\u00f1a Liesel hallar\u00e1 su salvaci\u00f3n en la lectura. Una novela preciosa, tremendamente humana y emocionante, que describe las peripecias de una ni\u00f1a alemana de nueve a\u00f1os desde que es dada en adopci\u00f3n por su madre hasta el final de la guerra. Su nueva familia, gente sencilla y nada afecta al na zismo, le ense\u00f1a a leer y a trav\u00e9s de los libros Rudy logra distraerse durante los bombardeos y combatir la tristeza. Pero es el libro que ella misma est\u00e1 escribiendo el que finalmente le salvar\u00e1 la vida.\", }) db.libro.insert({ \"_id\":\"9788415140054\", \"titulo\":\"La princesa de hielo\", \"autor\":\"Camilla Lackberg\", \"editorial\":\"Embolsillo\", \"enstock\":true, \"precio\":11, \"fecha\":new ISODate(\"2012-10-30T00:00:00Z\"), \"resumen\":\"Misterio y secretos familiares en una emocionante novela de suspense Erica vuelve a su pueblo natal tras el fallecimiento de sus padres, pero se va a encontrar con un nuevo drama. Aparentemente su amiga de la infancia, Alex, se ha suicidado. Pronto se descubre que no solamente fue asesinada sino que estaba embarazada. El primer sospechoso es Anders, un artista fracasado con quien Alex manten\u00eda una relaci\u00f3n especial. Pero poco despu\u00e9s de ser liberado por falta de pruebas, Anders aparece muerto en su domicilio. Con la ayuda del comisario Patrik, Erica investigar\u00e1 el pasado de su amiga Alex.\" }) db.libro.insert({ \"_id\":\"9788408113331\", \"titulo\":\"Las carreras de Escorpio\", \"autor\":\"Maggie Stiefvater\", \"editorial\":\"Planeta\", \"enstock\":false, \"paginas\":290, \"precio\":17.23, \"fecha\":new ISODate(\"2013-06-04T00:00:00Z\"), \"resumen\":\"En la peque\u00f1a isla de Thisby, cada noviembre los caballos de agua de la mitolog\u00eda celta emergen del mar. Y cada noviembre, los hombres los capturan para participar en una emocionante carrera mortal. En las carreras de Escorpio, algunos compiten para ganar. Otros para sobrevivir. Los jinetes intentan dominar a sus caballos de agua el tiempo suficiente para acabar la carrera. Algunos lo consiguen. El resto, muere en el intento. Sean Kendrick es el favorito, y necesita ganar la carrera para ganar, tambi\u00e9n, su libertad. Pero Puck Connolly est\u00e1 dispuesta a ser su m\u00e1s dura adversaria. Ella nunca quiso participar en las carreras. Pero no tiene elecci\u00f3n: o compite y gana o\u2026 lo pierde todo.\", }) db.libro.insert({ \"_id\":\"9788468738895\", \"titulo\":\"Las reglas del juego\", \"autor\":\"Anna Casanovas\", \"enstock\":true, \"paginas\":null, \"precio\":15.90, \"fecha\":new ISODate(\"2014-02-06T00:00:00Z\"), \"resumen\":\"Susana Lobato tiene la vida perfectamente planeada y est\u00e1 a punto de conseguir todo lo que quiere: va a tener su propio programa de noticias econ\u00f3micas y en dos meses va a casarse con un hombre maravilloso. Pero una noche Tim anula la boda y la abandona para perseguir un sue\u00f1o que no la incluye a ella.Kev MacMurray acaba de cumplir treinta y cinco a\u00f1os y siente que ha llegado el momento de dar un cambio a su vida. No sabe por qu\u00e9, pero \u00faltimamente se est\u00e1 asfixiando y est\u00e1 convencido de que no puede seguir donde est\u00e1. Lo \u00fanico que lo retiene es la boda de Tim, su mejor amigo.Pero Tim anula la boda y una noche Kev coincide con Susana y respira por primera vez en mucho tiempo.\u00bfPor qu\u00e9 no le hab\u00eda sucedido antes? Se supon\u00eda que \u00e9l y Susana no se soportaban \u00bfDesde cu\u00e1ndo siente que si no besa a la prometida de su mejor amigo no podr\u00e1 seguir respirando?Susana nunca hab\u00eda reaccionado as\u00ed con nadie. \u00bfPuede correr el riesgo de averiguar qu\u00e9 pasar\u00e1 si se entrega a Kev?Y qu\u00e9 pasar\u00e1 si vuelve Tim, \u00bfpodr\u00e1n dar un paso atr\u00e1s?.\", }) Podeu comprovar que hi ha 7 documents en la nova col\u00b7lecci\u00f3 libro : > db.libro.count() 7 I tamb\u00e9 podem consultar els t\u00edtols de forma c\u00f2moda: > db.libro.find( {} , {titulo:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I un altre exemple, on consultem els llibres que estan en stock (hi ha un camp boole\u00e0 que ho diu: enstock ), mostrant t\u00edtol, editorial i preu > db.libro.find( {enstock: true} , {titulo:1 , editorial:1 , precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } I un \u00faltim exemple, on consultem els llibres que estan en stock i tenen un preu de 21.75 \u20ac, mostrant tot excepte el _id i el resum > db.libro.find( {enstock: true , precio: 21.75} , {titulo:1 , editorial:1 , > precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Anem a mirar ara operadors que ens serviran per fer millor les consultes.","title":"3.4.2 - Operadors de les condicions"},{"location":"3__mongodb/#operadors-de-comparacio","text":"Fins ara en totes les condicions hem utilitzat la igualtat, si un determinat camp era igual a un determinat valor. Per\u00f2 hi ha infinitat de consultes en les quals voldrem altres operacions de comparaci\u00f3: major, major o igual, menor, ... Aquestos s\u00f3n els operadors de comparaci\u00f3: $lt ( less than ) menor $lte ( less than or equal ) menor o igual $gt ( gretaer than ) major $gte ( gretaer than or equal ) major o igual $ne ( not equal ) distint $eq ( equal ) igual (per\u00f2 aquest quasi que no caldria, perqu\u00e8 en no posar res es refereix a la igualtat com fins ara) La sintaxi per a la seua utilitzaci\u00f3 \u00e9s, com sempre, acoplar-se a la sintaxi JSON: clau : { $operador : valor [, ... ] } Aix\u00ed per exemple, per a buscar els llibres de m\u00e9s de 10 \u20ac: > db.libro.find( { precio : { $gt : 10 } } , { titulo:1 , precio:1 } ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } I per a buscar els llibres entre 10 i 20 \u20ac: > db.libro.find( { precio : { $gt : 10 , $lt:20 } } , { titulo:1 , precio:1 } > ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } \u00c9s especialment \u00fatil per a les dates, ja que dif\u00edcilment trobarem una data (i hora) exacta, i voldrem quasi sempre els documents anteriors a una data, o posteriors, o entre dues dates. Haurem d'anar amb compte pel tractament especial de les dates: hem de comparar coses del mateix tipus, i per tant la data amb la qual volem comparar l'haurem de tenir en forma de data: > var d = new ISODate(\"2013-01-01T00:00:00Z\") > db.libro.find( {fecha:{$gte:d} } , {fecha:1} ) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\") } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\") } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\") } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\") } $in Servir\u00e0 per a comprovar si el valor d'un camp est\u00e0 entre els d'una llista, proporcionada com un array. La sitaxi \u00e9s: clau : { $in : [valor1 , valor2 , ... , valorN] } I ac\u00ed tenim un exemple, els llibre de les editorials Planeta i Debolsillo: > db.libro.find( { editorial: {$in : [\"Planeta\" , \"Debolsillo\"]} } , {titulo:1 > , editorial:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } $nin \u00c9s el contrari, traura els que no estan en la llista. > db.libro.find( { editorial: {$nin : [\"Planeta\" , \"Debolsillo\"]} } , > {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Observeu com tamb\u00e9 trau els llibres que no tenen editorial, com \u00e9s el cas de l'\u00faltim llibre, Las reglas del juego $or L'operador anterior, $in , ja feia una esp\u00e8cie de OR, per\u00f2 sempre sobre el mateix camp. Si l'operaci\u00f3 OR la volem fer sobre camps distints, haurem d'utilitzar l'operador $or . La seua sintaxi ha de jugar amb la possibilitat de posar molts elements, i per tant conv\u00e9 l'array: $or : [ {clau1:valor1} , {clau2:valor2} , ... , {clauN:valorN} ] Ser\u00e0 cert si s'acompleix alguna de les condicions. Per exemple, traure els llibres que no estan en stock o que no tenen editorial: > db.libro.find( { $or : [ {enstock:false} , {editorial:null} ] } , {titulo:1 > , enstock:1 , editorial:1} ) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"enstock\" : false } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"enstock\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"enstock\" : true} $not Serveix per a negar una altra condici\u00f3. $not : { condici\u00f3 } Per exemple els llibres que no s\u00f3n de l'editorial Planeta (observeu que seria m\u00e9s senzill utilitzar l'operador $ne , per\u00f2 \u00e9s per a mostrar el seu funcionament: > db.libro.find( { editorial: {$not : {$eq:\"Planeta\"} } } , {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } $exists Servir\u00e0 per a saber els documents que tenen un determinat camp clau : { $exists : _boolean_ } Depenet del valor boolean , el funcionament ser\u00e0: true : torna els documents en els quals existeix el camp, encara que el seu valor siga nul false : torna els documents que no tenen el camp. Anem a traure els llibres que tenen el camp paginas : > db.libro.find( { paginas: {$exists:true} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null } Observeu com ens apareix tamb\u00e9 l'ultim llibre, que t\u00e9 el camp paginas amb el valor nul . En canvi si hagu\u00e9rem fet la consulta preguntant pels que s\u00f3n diferents de nul, no apareixeria aquest \u00faltim llibre: > db.libro.find( { paginas: {$ne:null} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } I si posem false al valor en el $exists , \u00fanicament ens apareixer\u00e0 el llibre que no t\u00e9 el camp: > db.libro.find( { paginas: {$exists:false} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } I per la mateixa ra\u00f3 que abans, si traiem els que tenen paginas a null, ens eixir\u00e0 tant qui no t\u00e9 el camp, com qui el t\u00e9 per\u00f2 amb valor nul: > db.libro.find( { paginas: null } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null} Per tant, per a segons quines coses, ens interessa l'operador $exists , en compte de jugar amb el nul.","title":"Operadors de comparaci\u00f3"},{"location":"3__mongodb/#expressions-regulars","text":"Mongo accepta les expressions regulars de forma nativa, cosa que d\u00f3na molta pot\u00e8ncia per a poder buscar informaci\u00f3 diversa. Les expressions regulars en Mongo tenen la mateixa sintaxi que en Perl, i que \u00e9s molt molt pareguda a la major part de llenguatges de programaci\u00f3. Mirem alguns exemples. Els llibres dins dels quals est\u00e0 la paraula juego : > db.libro.find( { titulo: /juego/ } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Ara que tenen la paraula juego sense importar maj\u00fascules o min\u00fascules: > db.libro.find( { titulo: /juego/i } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I ara que tenen la paraula juego nom\u00e9s al principi. > db.libro.find( { titulo: /^juego/i } , {titulo:1} ) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } I ara els llibres que en el resum ( resumen ) tenen la paraula amiga o amigo , \u00e9s a dir amig seguit d'una a o una o : > db.libro.find( { resumen: /amig[ao]/i } , {titulo:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Arrays Les consultes dins d'arrays de Mongo s\u00f3n molt senzilles. La m\u00e9s senzilla \u00e9s quan busquem un valor d'un tipus senzill, i en aquest cas el que far\u00e0 Mongo \u00e9s buscar en tot l'array per si est\u00e0 aquest valor. \u00c9s a dir, exactament igual que el que hem fet fins ara. db.col_leccio1.find ( { clau_array : valor } ) Mirem-ho en un exemple. Anem a crear dos documents que tinguen un array cadascun, per exemple de colors. El creem en una col\u00b7lecci\u00f3 nova, anomenada colorins , en dos documents amb el mateix camp de tipus array, color , per\u00f2 amb dades diferents * *: > db.colorins.insert({color: [\"roig\",\"blau\",\"groc\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.insert({color: [\"negre\",\"blanc\",\"roig\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.find(); { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Com es veu en la sintaxi, triar els documents que tenen un camp (en aquest cas d'array) que continga un valor, \u00e9s igual de senzill que quan es tracta d'un camp de tipus string, per exemple: > db.colorins.find({color:\"roig\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 podem utilitzar qualsevol dels operadors vistos fins el moment, com per exemple l'operador $in , que mirar\u00e0 els documents que tenen algun dels colors que s'especifica a continuaci\u00f3: > db.colorins.find({color: {$in : [\"groc\",\"lila\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } O per exemple tamb\u00e9 utilitzar expressions regulars : > db.colorins.find({color: /bl/ }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $ all L'operador $all el podem utilitzar quan vulguem seleccionar els documents que en l'array tiguen tots els elements especificats. Per exemple, anem a buscar els document que tenen el color roig i blau. > db.colorins.find({color : { $all : [\"roig\",\"blau\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Sub\u00edndex Si volem mirar exactament una determinada posici\u00f3 de l'array, podem especificar la posici\u00f3 immediatament despr\u00e9s de la clau, separada per un punt . Recordeu que la primera posici\u00f3 \u00e9s la 0 . Hem de posar entre cometes la clau i la posici\u00f3, sin\u00f3 no sabr\u00e0 trobar-la. Per exemple, busquem els documents que tenen el roig en la primera posici\u00f3. > db.colorins.find({\"color.0\" : \"roig\"} ) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Nota Accedir a una determinada posici\u00f3 \u00e9s f\u00e0cil, per\u00f2 no \u00e9s tan f\u00e0cil accedir a una posici\u00f3 calculada, per exemple a l'\u00faltima posici\u00f3. Ja fa falta coneixements un poc m\u00e9s avan\u00e7ats de JavaScript, per a posar dins del find() una funci\u00f3 en JavaScript, i actuar dins d'aquesta. \u00danicament de manera il\u00b7lustrativa, posem ac\u00ed la manera de traure els documents, l'\u00faltim color dels quals \u00e9s el roig. En ella ens creem una variable amb l'\u00faltim element de l'array (amb pop() ), i el comparem amb el color roig, tornant true en cas de que s\u00ed que siguen iguals: > db.colorins.find(function() { var a =this.color.pop(); return (a ==\"roig\")}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 hi ha una forma alternativa de fer-ho, que \u00e9s utilitzant l'operador $where , que ens permet crear condicions amb sintaxi JavaScript: > db.colorins.find({$where:\"this.color[this.color.length - 1]=='roig'\"}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $size L'operador $size ens servir\u00e0 per a fer condicions sobre el n\u00famero d'elements d'un array. Incorporem 2 documents nous, amb 2 i 4 elements respectivament, per a poder comprovar-lo: > db.colorins.insert({color: [\"negre\",\"blanc\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.insert({color: [\"taronja\",\"gris\",\"lila\",\"verd\"]}) WriteResult({ \"nInserted\" : 1 }) > db.colorins.find() { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Ara anem a seleccionar els documents que tenen 4 colors > db.colorins.find({color:{$size:4}}) { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Nota L'operador $size nom\u00e9s admet un valor num\u00e8ric, i no es poden concatenar expressions amb altres operadors, com per exemple intentar la condici\u00f3 que la grand\u00e0ria de l'array siga menor o igual a un determinat valor. Es pot tornar a esquivar la q\u00fcesti\u00f3 amb l'operador $where , i posar la condici\u00f3 en JavaScript. Aix\u00ed la consulta dels documents que tenen 3 o menys colors la podr\u00edem traure d'aquesta manera: > db.colorins.find({$where:\"this.color.length<=3\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ]} $slice L'operador $slice no \u00e9s un operador que es puga posar en les condicions (criteris), sin\u00f3 que servir\u00e0 per a extraure determinats elements de l'array, pel n\u00famero d'ordre d'aquestos elements en l'array. Nom\u00e9s el podrem posar, per tant, en el segon par\u00e0metre del find() . La sintaxi \u00e9s: clau : {$slice : x } Els valors que pot agafar x s\u00f3n: N\u00fameros positius: ser\u00e0 el n\u00famero d'elements del principi (per l'esquerra) N\u00fameros negatius: ser\u00e0 el n\u00famero d'elements del final (per la dreta) Un array de 2 elements ( [x,y] ): traur\u00e0 a partir de la posici\u00f3 x (0 \u00e9s el primer), tants elements com indique y Per exemple, anem a traure els dos primers colors de cada document: > db.colorins.find({} , {color:{$slice:2} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\" ] } O traure l'\u00faltim color: > db.colorins.find({} , {color:{$slice:-1 }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"verd\" ] } O traure el tercer element, tinguen els que tinguen. Recordeu que el segon element, \u00e9s el de la posici\u00f3 2, i en volem traure 1. > db.colorins.find({} , {color:{$slice:[2,1] }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"lila\" ] } Recerques en objectes Per a fer recerques en camps que a la seua vegada s\u00f3n objectes (o documents dins de documents, en la terminologia de Mongo), nom\u00e9s hem de posar la ruta de les claus separant per mig de punts, i cuidar de posar-la entre cometes. Aix\u00ed, per exemple, anem a fer una consulta sobre la col\u00b7lecci\u00f3 d'alumnes, que eren uns documents en els quals hi havia algun camp de tipus objecte. > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } Es podrien traure els documents (els alumnes) que viuen en el codi postal 12502. Ens ha d'eixir l'\u00fanic alumne del qual tenim l'adre\u00e7a, que justament t\u00e9 aquest codi postal. Recordeu que en la clau (realment clau.subclau), ha d'anar entre cometes. Hem posat al final pretty() per a una millor lectura, per\u00f2 evidentment no \u00e9s necessari. > db.alumnes.find({\"adre\u00e7a.cp\": \"12502\"}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } I funcionaria igual amb qualsevol n\u00famero de subnivells, \u00e9s a dir, documents que tenen objectes, els quals tenen objectes, ... I tamb\u00e9 amb altres tipus d'operadors, o expressions regulars, ... Per exemple, tots els alumnes de Castell\u00f3 (el codi postal ha de comen\u00e7ar per 12 i contenir 3 xifres m\u00e9s, \u00e9s a dir, car\u00e0cter del 0 al 9, i 3 vegades. > db.alumnes.find({\"adre\u00e7a.cp\": /^12[0-9]{3}/}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } Limit, Skip i Sort Una vegada tenim feta una consulta, podem limitar el nombre de documents que ens ha de tornar, o ordenar-los. Per a aix\u00f2 hi ha uns m\u00e8todes que apliqiuem al final del find() , \u00e9s a dir, a continuaci\u00f3 del find() , separats per un punt. Ho aplicarem als llibres, que \u00e9s on tenim m\u00e9s documents. I no mostrem tots els camps, per a una millor lectura: > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } limit( n ) Limita el n\u00famero de documents tornats a n documents. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } Si el n\u00famero de documents que fa la consulta \u00e9s menor que n , doncs se'n tornaran menys. Aix\u00ed per exemple, de l'editorial Planeta nom\u00e9s hi ha dos llibres. Encara que posem limit(3), se'n tornaran 2. > db.libro.find({editorial:\"Planeta\"} , {titulo:1 , precio:1 , > editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\", \"precio\" : 17.23 } skip( n ) Se saltaran els primers n documents. Si hi haguera menys documents dels que se salten, doncs no se'n mostraria cap. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).skip(2) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } sort() Serveix per a ordenar. Com a par\u00e0metre se li passar\u00e0 un objecte JSON amb les claus per a ordenar, i els valors seran: 1: ordre ascendent -1: ordre descendent Si posem m\u00e9s d'una clau, s'ordenar\u00e0 pel primer, en cas d'empat pel segon, ... En aquest exemple ordenem pel preu > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({precio:1}) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } I com d\u00e9iem, es pot posar m\u00e9s d'un camp d'ordenaci\u00f3. Per exemple, per editorial en ordre ascendent, i per preu en ordre descendent > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({editorial:1 , > precio:-1}) { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Observeu com el primer \u00e9s el que no t\u00e9 editorial (equivalent a null). I com que hi ha dos de l'editorial Planeta, apareix primer el m\u00e9s car, i despr\u00e9s el m\u00e9s barat. I evidentment, es poden combinar els m\u00e8todes limit, skip i sort. En aquest exemple traurem el segon i tercer llibre m\u00e9s car. Per a aix\u00f2 ordenem per preu de forma descendent, saltem un i limitem a 2. No importa l'ordre com col\u00b7locar skip, limit i sort. > db.libro.find({} , {titulo:1 , precio:1 , > editorial:1}).sort({precio:-1}).skip(1).limit(2) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 }","title":"Expressions regulars"},{"location":"3__mongodb/#343-agregacio","text":"L'agregaci\u00f3 ens permetr\u00e0 fer consultes molt avan\u00e7ades. \u00c9s un proc\u00e9s un poc complicat per\u00f2 molt potent. Ens donar\u00e0 una pot\u00e8ncia quasi com la del SQL quan comencem a utilitzar el GROUP BY i HAVING. La t\u00e8cnica que s'utilitza \u00e9s la del pipeline , \u00e9s a dir fer una s\u00e8rie de comandos, cadascun agafa les dades que proporciona l'anterior i a la seua vegada proporciona les dades al seg\u00fcent comando. D'aquesta manera es tractar\u00e0 un conjunt de documents i es faran \"operacions\" sobre ells seq\u00fcencialment en blocs: filtrat, projecci\u00f3, agrupacions, ordenaci\u00f3, limitaci\u00f3 i skipping (saltar alguns). La sintaxi ser\u00e0: db.col_leccio1.aggregate ( _operador $matc_ h , _operador $projec_ t , _operador $group_ , _operador $sort_ , _operador $limit_ , _operador $skip_ ) L'ordre dels operadors pot canviar, per\u00f2 hem de tenir en compte que els comandos s'executen en el ordre en qu\u00e8 els posem (d'esquerra a dreta). Aix\u00ed, per exemple, pot ser molt convenient posar el primer operador el $match, que \u00e9s el de seleccionar documents, aix\u00ed les altres operacions es faran sobre menys documents i aniran m\u00e9s r\u00e0pides. Cada par\u00e0metre del aggregate, \u00e9s a dir, cada operador tindr\u00e0 format JSON, i per tant sempre ser\u00e0 de l'estil: { $operador : { clau:valor , ... } }","title":"3.4.3 - Agregaci\u00f3"},{"location":"3__mongodb/#match","text":"Servir\u00e0 per a filtrar els documents. Aleshores, l'agregaci\u00f3 nom\u00e9s afectar\u00e0 als documents seleccionats. Es poden utilitzar tots els operadors que hem anat estudiant. El seg\u00fcent exemple selecciona els documents de l'editorial Planeta. Ho fa per mig de aggregate , per\u00f2 com no fem res m\u00e9s, senzillament selecciona els documents. > db.libro.aggregate({$match:{editorial:\"Planeta\"}}) En el seg\u00fcent exemple, a m\u00e9s de seleccionar els de l'editorial Planeta despr\u00e9s apliquem una projecci\u00f3 sobre els camps t\u00edtol i editorial, per a poder visualitzar millor el resultat. > > db.libro.aggregate({$match:{editorial:\"Planeta\"}},{$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\" }","title":"$match"},{"location":"3__mongodb/#project","text":"Ens permet projectar sobre determinats camps del document, per\u00f2 \u00e9s molt m\u00e9s complet que en la projecci\u00f3 \"normal\" que hav\u00edem fet fins ara, ja que permet tamb\u00e9 renomenar camps, fer c\u00e0lculs, etc. Projeccci\u00f3 La manera m\u00e9s senzilla, evidentment \u00e9s projectar sobre alguns camps dels existents, i el funcionament \u00e9s id\u00e8ntic al de l'altra vegada (valors 1 per a que apareguen, 0 per a que no apareguen; per defecte _id sempre apareix): > db.libro.aggregate({$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Renomenar $project tamb\u00e9 ens permet renomenar camps existents (despr\u00e9s veurem que tamb\u00e9 c\u00e0lculs). La manera ser\u00e0 posar d'aquest manera: { $projec t : { \"nom_nou\" : \"$camp_vell\" }} El secret est\u00e0 en el d\u00f2lar que va davant del camp vell, ja que d'aquesta manera ens referim al valor d'aquest camp. Aix\u00ed per exemple renomenem el camp enstock a disponible , a banda de traure el t\u00edtol: > db.libro.aggregate({$project:{titulo:1 , disponible:\"$enstock\"}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"disponible\" : true } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"disponible\" : true } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" disponible\" : true } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"disponible\" : false } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"disponible\" : true } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"disponible\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"disponible\" : true } Camps calculats Amb aquest nom gen\u00e8ric ens referirem a tots els c\u00e0lculs, expressions i m\u00e9s coses que podrem posar per a trasnsformar el que ja tenim. Com veiem, a\u00e7\u00f2 \u00e9s molt m\u00e9s potent que la projecci\u00f3 normal. Expressions matem\u00e0tiques : Podrem aplicar f\u00f3rmules per a sumar ( $add ), restar ( $subtract ), multiplicar ( $multiply ), dividir ( $divide ) i m\u00e9s coses (pot\u00e8ncia, arrel quadrada, valor absolut, m\u00f2dul, ...). Cada operaci\u00f3 t\u00e9 el seu operador que ser\u00e0 una paraula precedida pel d\u00f2lar, i amb la sintaxi de JSON, on posarem els operands en un array. Per exemple, traurem t\u00edtol del llibre, preu i preu en pessetes (multiplicant per 166.386) > db.libro.aggregate({$project:{titulo:1 , precio:1 , > preu_pessetes:{$multiply:[\"$precio\" , 166.386]}}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"precio\" : 9.5, \"preu_pessetes\" : 1580.667 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"precio\" : 9.45, \"preu_pessetes\" : 1572.3476999999998 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11, \"preu_pessetes\" : 1830.2459999999999 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23, \"preu_pessetes\" : 2866.83078 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9, \"preu_pessetes\" : 2645.5374 } Expressions de dates : Ja veurem i ja podem anar intuint que moltes agregacions estaran basades en el temps, per a poder fer consultes de documents de la setmana passada, o el mes passat, ... Per a poder fer aquestes agregacions, hi ha un conjunt d'expressions que permeten extraure f\u00e0cilment d'una data el seu dia, mes, any, ... en forma de n\u00famero S\u00f3n les expressions: $year, $month, $week, $dayOfMonth, $DayOfWeek, $dayOfYear, $hour, $minute i $second . En el seg\u00fcent exemple traurem tots els documents, projectant per la data, any i mes: > db.libro.aggregate({$project : {fecha:1 , a\u00f1o:{$year:\"$fecha\"} , > mes:{$month:\"$fecha\"}}}) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 8 } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 3 } { \"_id\" : \"9788496208919\", \"fecha\" : ISODate(\"2011-11-24T00:00:00Z\"), \"a\u00f1o\" : 2011, \"mes\" : 11 } { \"_id\" : \"9788499088075\", \"fecha\" : ISODate(\"2009-01-09T00:00:00Z\"), \"a\u00f1o\" : 2009, \"mes\" : 1 } { \"_id\" : \"9788415140054\", \"fecha\" : ISODate(\"2012-10-30T00:00:00Z\"), \"a\u00f1o\" : 2012, \"mes\" : 10 } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 6 } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 2 } Expressions de strings : Ens permeten manipular els strings per a extraure subcadenes, concatenar, passar a maj\u00fascules o min\u00fascules. Aquestes s\u00f3n algunes de les funcions: $substr : [exp , inici , llarg\u00e0ria] : extrau una subcadena del string del primer par\u00e0metre, des de la posici\u00f3 que indica el segon par\u00e0metre (o primer car\u00e0cter) i tants car\u00e0cters com el tercer par\u00e0metre $concat : [ exp1 , exp2 , ...] : concatena les expressions que hi ha en l'array $toLower : exp i $toUpper : exp : converteixen l'expressi\u00f3 a maj\u00fascules i min\u00fascules respectivament Per exemple, anem a traure el t\u00edtol dels llibres amb l'autor entre par\u00e8ntesis: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : [\"$titulo\" , \" (\" , > \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"Circo M\u00e1ximo (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"El juego de Ripper (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"La ladrona de libros (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"La princesa de hielo (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"Las carreras de Escorpio (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"Las reglas del juego (Anna Casanovas)\"} I ara el mateix, per\u00f2 amb el t\u00edtol en maj\u00fascules: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : > [{$toUpper:\"$titulo\"}, \" (\" , \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"CIRCO M\u00e1XIMO (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"EL JUEGO DE RIPPER (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"JUEGO DE TRONOS: CANCI\u00f3N DE HIELO Y FUEGO 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"LA LADRONA DE LIBROS (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"LA PRINCESA DE HIELO (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"LAS CARRERAS DE ESCORPIO (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"LAS REGLAS DEL JUEGO (Anna Casanovas)\" }","title":"$project"},{"location":"3__mongodb/#group","text":"Realitza grups sobre els documents seleccionats pr\u00e8viament, per a valors iguals del camp o expressions que determinem. Posteriorment, amb els grups, podrem realitzar operacions, com sumar o traure la mitjana d'alguna quantitat dels documents del grup, o el m\u00e0xim o m\u00ednim, ... Per a poder agrupar, haurem de definir com a _id del grup el camp o camps pels valors dels quals volem agrupar. Per exemple, si volem agrupar els llibres per l'editorial, haurem de definir el _id del grup el camp editorial $group : { \"_id\" : _camp o camps_ } Si agrupem per un \u00fanic camp, senzillament el posem amb un d\u00f2lar davant i entre cometes. Si \u00e9s m\u00e9s d'un camp, els posem com un objecte. Per exemple, agrupem per editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" } } ) { \"_id\" : \"Debolsillo\" } { \"_id\" : null } { \"_id\" : \"Gigamesh\" } { \"_id\" : \"Embolsillo\" } { \"_id\" : \"Plaza & Janes\" } { \"_id\" : \"Planeta\" } Podem observar com hi ha algun llibre que no t\u00e9 editorial. Ara agrupem per any de publicaci\u00f3 (l'extraurem del camp fecha ): > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } }} ) { \"_id\" : { \"any\" : 2012 } } { \"_id\" : { \"any\" : 2009 } } { \"_id\" : { \"any\" : 2011 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"any\" : 2013 } } I ara agrupem per editorial i any de publicaci\u00f3 (els dos llibres de Planeta s\u00f3n del 2013) > db.libro.aggregate( { $group : { \"_id\" : { \"Editorial\" : \"$editorial\" , > \"any\" : { $year : \"$fecha\" } } } } ) { \"_id\" : { \"Editorial\" : \"Embolsillo\", \"any\" : 2012 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Debolsillo\", \"any\" : 2009 } } { \"_id\" : { \"Editorial\" : \"Gigamesh\", \"any\" : 2011 } } { \"_id\" : { \"Editorial\" : \"Plaza & Janes\", \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Planeta\", \"any\" : 2013 } } Operadors d'agrupaci\u00f3 Ens permetran fer alguna operaci\u00f3 sobre els documents del grup. Es posen com a segon par\u00e0metre del grup (despr\u00e9s de la definici\u00f3 del _id ). $sum : valor : sumar\u00e0 el valor de tots els documents del grup. El valor pot ser un camp num\u00e8ric, o alguna altra cosa m\u00e9s complicada. $avg : valor : calcular\u00e0 la mitjana dels valors per als documents del grup $max : valor : m\u00e0xim $min : valor : m\u00ednim $first : exp : agafar\u00e0 el primer valor de l'expressi\u00f3 del grup, ignorant les altres del grup $last : exp : agafar\u00e0 l'\u00faltim La documentaci\u00f3 diu que tamb\u00e9 existeix l'operador $count , per\u00f2 a partir d'una determinada versi\u00f3. Es pot substituir la seua utilitzaci\u00f3 per l'operador $sum , sumant la quantitat 1. Per exemple, la suma dels preus dels llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : { > $sum : \"$precio\"} } } ) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } O la mitjana dels preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } , > \"mitjana preus\" : { $avg : \"$precio\" } } } ) { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } I ara intentem comptar la quantitat de llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"quants\" : { $sum : > 1} } } ) { \"_id\" : \"Debolsillo\", \"quants\" : 1 } { \"_id\" : null, \"quants\" : 1 } { \"_id\" : \"Gigamesh\", \"quants\" : 1 } { \"_id\" : \"Embolsillo\", \"quants\" : 1 } { \"_id\" : \"Plaza & Janes\", \"quants\" : 1 } { \"_id\" : \"Planeta\", \"quants\" : 2 }","title":"$group"},{"location":"3__mongodb/#sort","text":"Serveix per a ordenar i segueix la mateixa sint\u00e0xi que en les consultes normal (1: ordre ascendent; -1: ordre descendent). Podrem ordenar pels camps normals o per camps clalculats. Per exemple ordenem per la suma de preus de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : { > $sum : \"$precio\"} } } , { $sort : { suma_preus : 1 } }) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } I ara ordenem de forma descendent per la mitjana de preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : {\"any\":{$year:\"$fecha\"}} , \"mitjana > preus\":{$avg:\"$precio\"} } } , {$sort:{\"mitjana preus\":-1}}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 }","title":"$sort"},{"location":"3__mongodb/#limit","text":"Limita el resultat del aggregate al n\u00famero indicat. Per exemple, els tres anys de mitjana de preus m\u00e9s cara. \u00c9s com l'\u00faltim exemple, afegint el l\u00edmit: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana > preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$limit:3}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 }","title":"$limit"},{"location":"3__mongodb/#skip","text":"Salta el n\u00famero indicat En l'exemple anterior, ara saltem els 3 primers: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana > preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$skip:3}) { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 }","title":"$skip"},{"location":"3__mongodb/#35-connexio-des-de-kotlin-i-exemples","text":"Per a poder connectar des de Java o Kotlin ens sera suficient amb un driver, que haurem d'incorporar al projecte. En la seg\u00fcent p\u00e0gina podem trobar-lo, en diferents versions: https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/ En el moment de fer aquestos apunts, l'\u00faltim driver disponible \u00e9s el seg\u00fcent: https://repo1.maven.org/maven2/org/mongodb/mongo-java-driver/3.9.1/mongo- java-driver-3.9.1.jar Per a separar les proves i exercicis de la part de Redis , creem un nou paquet anomenat ExemplesMongo . Connexi\u00f3 La connexi\u00f3 \u00e9s tan senzilla com el seg\u00fcent: val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") \u00c9s a dir, obtenim un objecte MongoClient passant-li al constructor l'adre\u00e7a del servidor i el port de connexi\u00f3 (que per defecte \u00e9s 27017). Posteriorment hem de connectar amb la Base de Dades. Ja hav\u00edem comentat en la instal\u00b7laci\u00f3 de Mongo que nosaltres nom\u00e9s utilitzar\u00edem una Base de Dades ja creada anomenada test . Obtenim un objecte MongoDatabase que far\u00e0 refer\u00e8ncia a la Base de Dades, i \u00e9s l'objecte que utilitzarem a partir d'ara. Evidentment ho podr\u00edem haver fet en una \u00fanica l\u00ednia. Si el servidor no el tenim en la mateixa m\u00e0quina, nom\u00e9s haurem de substituir localhost per l'adre\u00e7a on estiga el servidor. Per a tancar la connexi\u00f3: con.close() Inserci\u00f3 de documents Des de Kotlin podrem inserir documents amb la mateixa facilitat que des de la consola. Nom\u00e9s haurem de crear un objecte Document de BSON (recordeu que \u00e9s el format intern de Mongo, absolutament similar a JSON ). La manera d'anar posant parelles calu valor en aquest document \u00e9s per mig del m\u00e8tode put . Fem un exemple molt senzill on senzillament guardem un document amb una parella clau-valor d'un missatge. Guardeu-lo amb el nom Prova1.kt : import com.mongodb.MongoClient import org.bson.Document fun main(args: Array<String>) { val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val doc = Document() doc.put(\"msg4\", \"Missatge inserit des de Kotlin\") bd.getCollection(\"exemple\").insertOne(doc) con.close() } Segurament traur\u00e0 avisos en la consola, per\u00f2 nom\u00e9s s\u00f3n avisos. Podem comprovar en la terminal com s'ha inserit el document: Consultes Tenim el m\u00e8tode find() per a fer consultes, i li podem posar un document com a par\u00e0metre per a seleccionar determinats documents o traure determinada informaci\u00f3. Guardeu el seg\u00fcent exemple amb el nom Prova2.kt : import com.mongodb.MongoClient fun main(){ val con = MongoClient(\"localhost\" , 27017) val bd = con.getDatabase(\"test\") val llibres = bd.getCollection(\"libro\").find() for (llibre in llibres) println(llibre.get(\"titulo\")) con.close(); } I com coment\u00e0vem podem posar com a par\u00e0metres en el find() per a seleccionar determinats documents, ordenar, etc. Nom\u00e9s hem de cuidar que ho hem de posar en JSON (millor dit BSON ), i per tant haurem de crear un document per a aix\u00f2. Copieu el seg\u00fcent exemple amb el nom Prova3.kt : import com.mongodb.MongoClient import org.bson.Document fun main(){ val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val ordenar = Document() ordenar.put(\"precio\", -1) val llibres = bd.getCollection(\"libro\").find().sort(ordenar) for (llibre in llibres) System.out.println( \"T\u00edtol: \" + llibre.get(\"titulo\").toString() + \". Preu: \" + llibre.get(\"precio\") ) con.close() } El resultat ser\u00e0 aquest: Hem pogut observar en l'execuci\u00f3 dels exemples anteriors que ens trau una gran quantitat d'avisos. No s\u00f3n errors, sin\u00f3 senzillament informaci\u00f3 de com van les connexions, que mongo torna, i apareixen en l'eixida est\u00e0ndar. Si no volem que apareguen podem posar al principi del programa una sent\u00e8ncia per a dir que \u00fanicament apareguen els errors, i no els avisos. Els errors estarien en la categoria de SEVERE LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) Hem d'importar les classes de java.util . Quedaria el mateix exemple Prova3.kt d'aquesta manera: import com.mongodb.MongoClient import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val ordenar = Document() ordenar.put(\"precio\", -1) val llibres = bd.getCollection(\"libro\").find().sort(ordenar) for (llibre in llibres) System.out.println( \"T\u00edtol: \" + llibre.get(\"titulo\").toString() + \". Preu: \" + llibre.get(\"precio\") ) con.close() } I el resultat ara ser\u00e0: Agregaci\u00f3 Per a poder utilitzar la funci\u00f3 d'agregaci\u00f3, que t\u00e9 tanta pot\u00e8ncia, ens ho hem de muntar d'aquesta manera: Sobre la col\u00b7lecci\u00f3 utilitzar el m\u00e8tode aggregate() Com a par\u00e0metres, afegirem un MutableList . Cada element d'ell ser\u00e0 una opci\u00f3 d'aggregate Per a cada opci\u00f3 ($match, $project...), utilitzarem el m\u00e8tode d' Aggregates (una classe del driver de Mongo) amb el mateix nom: Per a $match : Aggregates.match() Per a $project: Aggregates.project() ... Dins de cadascun d'aquestos m\u00e8todes posarem un document BSon amb les especificacions que necessitem En aquest exemple farem la selecci\u00f3 (match) dels llibres de l'editorial Planeta, agafant (project) \u00fanicament el t\u00edtol i l'editorial. La sent\u00e8ncia en la consola la far\u00edem aix\u00ed: > db.libro.aggregate({$match:{editorial:\"Planeta\"}},{$project:{titulo:1, > editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } El programa ens quedaria aix\u00ed. Guardeu-lo en en fitxer Kotlin anomenat Prova_Aggregate_1.kt : import com.mongodb.MongoClient import com.mongodb.client.model.Aggregates import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val seleccionar = Document() seleccionar.put(\"editorial\", \"Planeta\") val projeccio = Document() projeccio.put(\"titulo\",1) projeccio.put(\"editorial\",1) val llibres = bd.getCollection(\"libro\").aggregate(mutableListOf(Aggregates.match(seleccionar),Aggregates.project(projeccio))) for (llibre in llibres) println(\"T\u00edtol: \" + llibre.get(\"titulo\").toString() + \". Editorial: \" + llibre.get(\"editorial\").toString() ) con.close() } Mirem un altre exemple. Traure el llibre m\u00e9s barat de cada any. La consulta en Mongo que far\u00edem en la consola de Mongo seria: > db.libro.aggregate( {$group : {\"_id\" : { \"any\" : { $year : \"$fecha\" } } , \"minim\":{$min: \"$precio\"}}}, {$sort:{\"_id\":1}}) { \"_id\" : { \"any\" : 2009 }, \"minim\" : 9.45 } { \"_id\" : { \"any\" : 2011 }, \"minim\" : 9.5 } { \"_id\" : { \"any\" : 2012 }, \"minim\" : 11 } { \"_id\" : { \"any\" : 2013 }, \"minim\" : 17.23 } { \"_id\" : { \"any\" : 2014 }, \"minim\" : 15.9 } Ara col\u00b7locarem aquesta sent\u00e8ncia en un programa Kotlin. Guardeu el seg\u00fcent codi com el fitxer Kotlin Prova_Aggregate_2.kt : import com.mongodb.MongoClient import com.mongodb.client.model.Aggregates import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(\"localhost\", 27017) val bd = con.getDatabase(\"test\") val grup = Document() grup.put(\"_id\", Document(\"any\",Document(\"\\$year\",\"\\$fecha\"))) grup.put(\"minim\",Document(\"\\$min\",\"\\$precio\")) val ordenar = Document() ordenar.put(\"_id\",1) val llibres = bd.getCollection(\"libro\").aggregate(mutableListOf(Aggregates.group(grup),Aggregates.sort(ordenar))) for (llibre in llibres){ val d = llibre.get(\"_id\") as Document println(\"Any: \" + (d.get(\"_id\") as Document).getInteger(\"any\")+ \". M\u00ednim: \" + d.getDouble(\"minim\")) } con.close() } Hem tingut la complicaci\u00f3 que el resultat \u00e9s m\u00e9s complicat, t\u00e9 un document dins d'una altre document (com es veu en el resultat de la sent\u00e8ncia executada en la consola). Aquest ser\u00e0 el resultat:","title":"3.5 - Connexi\u00f3 des de Kotlin i Exemples"},{"location":"3__mongodb/#36-connexio-des-de-kotlin-al-servidor-de-linstitut","text":"La connexi\u00f3 canvia si la fem al servidor de l'Institut, no per ser una direcci\u00f3 externa, sin\u00f3 perqu\u00e8 cal la autenticaci\u00f3. Hem habilitat l'autenticaci\u00f3 per a intentar evitar atacs. Si no tingu\u00e8rem autenticaci\u00f3, la connexi\u00f3 seria com abans: val con = MongoClient(\"89.36.214.106\") val bd = con.getDatabase(\"test\") Per\u00f2 per tenir l'autenticaci\u00f3 activada la connexi\u00f3 haur\u00e0 de ser diferent: val con = MongoClient(MongoClientURI(\"mongodb://ad:Ad_ieselcamina$@89.36.214.106/?authSource=test\")) val bd = con.getDatabase(\"test\") on hem especificat l'adre\u00e7a donant-li un usuari ( ad ), una contrasenya ( Ad_ieselcamina$ ), el servidor ( 89.36.214.106 ) i fins i tot la Base de Dades on connectem, que ja va comentar que nom\u00e9s ten\u00edem la BD test Per a tancar la connexi\u00f3, com sempre: con.close() Mirem un exemple on podem comprovar que l'utilitzem exactament igual que amb la connexi\u00f3 a localhost, per\u00f2 ara ens est\u00e0 contestant el servidor de l'Institut. Guardeu-lo amb el nom ProvaServidor.kt : import com.mongodb.MongoClient import com.mongodb.MongoClientURI import org.bson.Document import java.util.logging.Level import java.util.logging.LogManager fun main(){ LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val con = MongoClient(MongoClientURI(\"mongodb://ad:Ad_ieselcamina$@89.36.214.106/?authSource=test\")) val bd = con.getDatabase(\"test\") val ordenar = Document() ordenar.put(\"precio\", -1) val llibres = bd.getCollection(\"libro\").find().sort(ordenar) for (llibre in llibres) System.out.println(llibre.get(\"titulo\").toString() + \" --> \" + llibre.get(\"precio\")) con.close() } I ac\u00ed tenim el resultat: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"3.6 - Connexi\u00f3 des de Kotlin al servidor de l'Institut"},{"location":"exercicis_mongo/","text":"Exercicis Exercici 3 Agafa l'estat actual de Bicicas de la seg\u00fcent adre\u00e7a: http://gestiona.bicicas.es/apps/apps.php En compte de copiar aquestes dades actuals en un fitxer i despr\u00e9s analitzar el fitxer, analitzarem directament fent la petici\u00f3 a la p\u00e0gina del servidor d'aquesta manera: val url = URL(\"http://gestiona.bicicas.es/apps/apps.php\") val rd = url.openConnection().getInputStream().reader() L'objecte rd \u00e9s un Reader que directament el podem passar com a par\u00e0metre del JSONTokener , vist en el Tema 3. Estudia el format JSON, per a poder agafar b\u00e9 la informaci\u00f3 de cada estaci\u00f3, tal i com vam veure en el Tema 3. En un paquet nou anomenat ExercicisMongo dins del projecte Tema7 : Fes un programa anomenat T7Ex3_IntroduirBicicas (amb main ) que introduesca en MongoDB cada estaci\u00f3 com un document en una col\u00b7lecci\u00f3 anomenada bicicas . Fes un altre programa anomenat T7Ex3_ MostrarBicicas que agafe tots els documents de la col\u00b7lecci\u00f3 bicicas de la Base de Dades de MongoDb, que s\u00f3n totes les estacions, i traga la seua informaci\u00f3 amb aquest aspecte (en la imatge nom\u00e9s es mostren les 10 primeres, per\u00f2 han d'eixir totes) 01.- UJI - FCHS (5/27) 02.- ESTACI\u00c3\u00b3N DE FERROCARRIL Y AUTOBUSES (11/28) 03.- COL\u00c3\u00b3N (9/16) 04.- PASEO BUENAVISTA-GRAO (4/13) 05.- HOSPITAL GENERAL (5/18) 06.- PLAZA DE LA LIBERTAD (0/12) 07.- PLAZA TEODORO IZQUIERDO (4/13) 08.- PLAZA PRIMER MOL\u00c3\u00ad (6/13) 09.- PATRONAT DESPORTS (7/14) 10.- PLAZA DOCTOR MARA\u00c3\u00b1\u00c3\u00b3N (0/23) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercicis"},{"location":"exercicis_mongo/#exercicis","text":"","title":"Exercicis"},{"location":"exercicis_mongo/#exercici-3","text":"Agafa l'estat actual de Bicicas de la seg\u00fcent adre\u00e7a: http://gestiona.bicicas.es/apps/apps.php En compte de copiar aquestes dades actuals en un fitxer i despr\u00e9s analitzar el fitxer, analitzarem directament fent la petici\u00f3 a la p\u00e0gina del servidor d'aquesta manera: val url = URL(\"http://gestiona.bicicas.es/apps/apps.php\") val rd = url.openConnection().getInputStream().reader() L'objecte rd \u00e9s un Reader que directament el podem passar com a par\u00e0metre del JSONTokener , vist en el Tema 3. Estudia el format JSON, per a poder agafar b\u00e9 la informaci\u00f3 de cada estaci\u00f3, tal i com vam veure en el Tema 3. En un paquet nou anomenat ExercicisMongo dins del projecte Tema7 : Fes un programa anomenat T7Ex3_IntroduirBicicas (amb main ) que introduesca en MongoDB cada estaci\u00f3 com un document en una col\u00b7lecci\u00f3 anomenada bicicas . Fes un altre programa anomenat T7Ex3_ MostrarBicicas que agafe tots els documents de la col\u00b7lecci\u00f3 bicicas de la Base de Dades de MongoDb, que s\u00f3n totes les estacions, i traga la seua informaci\u00f3 amb aquest aspecte (en la imatge nom\u00e9s es mostren les 10 primeres, per\u00f2 han d'eixir totes) 01.- UJI - FCHS (5/27) 02.- ESTACI\u00c3\u00b3N DE FERROCARRIL Y AUTOBUSES (11/28) 03.- COL\u00c3\u00b3N (9/16) 04.- PASEO BUENAVISTA-GRAO (4/13) 05.- HOSPITAL GENERAL (5/18) 06.- PLAZA DE LA LIBERTAD (0/12) 07.- PLAZA TEODORO IZQUIERDO (4/13) 08.- PLAZA PRIMER MOL\u00c3\u00ad (6/13) 09.- PATRONAT DESPORTS (7/14) 10.- PLAZA DOCTOR MARA\u00c3\u00b1\u00c3\u00b3N (0/23) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercici 3"},{"location":"exercicis_redis/","text":"Exercicis Exercici 1 En un nou paquet anomenat ExercicisRedis dins del projecte Tema7 , crea el fitxer Kotlin T7Ex1_ConsultarClaus.kt , que permeta consultar totes les claus guardades en el nostre servidor Redis . Ha de presentar totes les claus actuals en Redis i el seu tipus, per\u00f2 amb un n\u00famero davant. Posteriorment ha de demanar un n\u00famero per teclat, i presentar la clau i el valor corresponent al n\u00famero introdu\u00eft, fins introduir el 0. Observa que depenent del tipus de la clau s'haur\u00e0 de fer d'una manera o una altra. En la imatge teniu un exemple de cada: 1.- clau_1 (string) 2.- mes2 (string) 3.- empleat_1 (hash) 4.- mes1 (string) 5.- saludar (string) 6.- empleat_2 (hash) 7.- mes6 (string) 8.- mes5 (string) 9.- mes4 (string) 10.- mes3 (string) 11.- colors (set) 12.- mes7 (string) 13.- llista1 (list) 14.- clau_Java (string) 15.- lista111 (list) 16.- colors1 (set) 17.- colors2 (set) 18.- colors3 (set) 19.- text (string) 20.- colors4 (set) 21.- clau_4 (string) 22.- clau_2 (string) 23.- puntuacions (zset) 24.- compt3 (string) 25.- compt2 (string) 26.- compt1 (string) 27.- quatre (string) 28.- pi (string) Introdueix un n\u00famero (0 per a eixir) 4 mes1: gener Introdueix un n\u00famero (0 per a eixir) 6 empleat_2 sou --> 1500.0 nom --> Berta Introdueix un n\u00famero (0 per a eixir) 13 llista1 primera sisena cinquena Introdueix un n\u00famero (0 per a eixir) 11 colors roig verd blau Introdueix un n\u00famero (0 per a eixir) 23 puntuacions Nom5 --> 2.75 Nom2 --> 3.5 Nom3 --> 5.0 Introdueix un n\u00famero (0 per a eixir) 0 Exercici 2 Realitzar en el mateix paquet un altre programa, aquesta vegada gr\u00e0fic, que ens diga el mateix, per\u00f2 d'una forma m\u00e9s atractiva. El programa s'ha de dir T7Ex2_ConsultaClausGrafica . Contindr\u00e0 un JList on han d'apar\u00e9ixer totes les claus, millor si estan ordenades alfab\u00e8ticament. Recordeu que el JList \u00e9s un poc complicat, que es basa en un DefaultListModel , i \u00e9s a aquest a qui heu d'afegir els elements. Al costat ha d'haver un JTextField que diga de quin tipus \u00e9s quan se seleccione un element del JList I tamb\u00e9 un JTextArea amb el seu valor (siga del tipus que siga) Aquest seria l'esquelet. import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JTextArea import javax.swing.DefaultListModel import javax.swing.JList import javax.swing.JScrollPane import java.awt.FlowLayout import java.awt.Color import redis.clients.jedis.Jedis import java.awt.EventQueue class EstadisticaRD : JFrame() { val etTipClau= JLabel(\"Tipus:\") val tipClau= JTextField(8) val contClau = JTextArea(8,15) val con = Jedis(\"localhost\") val listModel = DefaultListModel<String>() val llClaus = JList(listModel) init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 450) setLayout(FlowLayout()) llClaus.setForeground(Color.blue) val scroll = JScrollPane(llClaus) llClaus.setVisibleRowCount(20) val scroll2 = JScrollPane(contClau) add(scroll) add(etTipClau) add(tipClau) add(scroll2) setSize(600, 400) setVisible(true) inicialitzar() llClaus.addListSelectionListener{valorCanviat()} } fun inicialitzar(){ } fun valorCanviat() { } } fun main(args: Array<String>) { EventQueue.invokeLater { EstadisticaRD().isVisible = true } } I aquest el seu aspecte Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercicis"},{"location":"exercicis_redis/#exercicis","text":"","title":"Exercicis"},{"location":"exercicis_redis/#exercici-1","text":"En un nou paquet anomenat ExercicisRedis dins del projecte Tema7 , crea el fitxer Kotlin T7Ex1_ConsultarClaus.kt , que permeta consultar totes les claus guardades en el nostre servidor Redis . Ha de presentar totes les claus actuals en Redis i el seu tipus, per\u00f2 amb un n\u00famero davant. Posteriorment ha de demanar un n\u00famero per teclat, i presentar la clau i el valor corresponent al n\u00famero introdu\u00eft, fins introduir el 0. Observa que depenent del tipus de la clau s'haur\u00e0 de fer d'una manera o una altra. En la imatge teniu un exemple de cada: 1.- clau_1 (string) 2.- mes2 (string) 3.- empleat_1 (hash) 4.- mes1 (string) 5.- saludar (string) 6.- empleat_2 (hash) 7.- mes6 (string) 8.- mes5 (string) 9.- mes4 (string) 10.- mes3 (string) 11.- colors (set) 12.- mes7 (string) 13.- llista1 (list) 14.- clau_Java (string) 15.- lista111 (list) 16.- colors1 (set) 17.- colors2 (set) 18.- colors3 (set) 19.- text (string) 20.- colors4 (set) 21.- clau_4 (string) 22.- clau_2 (string) 23.- puntuacions (zset) 24.- compt3 (string) 25.- compt2 (string) 26.- compt1 (string) 27.- quatre (string) 28.- pi (string) Introdueix un n\u00famero (0 per a eixir) 4 mes1: gener Introdueix un n\u00famero (0 per a eixir) 6 empleat_2 sou --> 1500.0 nom --> Berta Introdueix un n\u00famero (0 per a eixir) 13 llista1 primera sisena cinquena Introdueix un n\u00famero (0 per a eixir) 11 colors roig verd blau Introdueix un n\u00famero (0 per a eixir) 23 puntuacions Nom5 --> 2.75 Nom2 --> 3.5 Nom3 --> 5.0 Introdueix un n\u00famero (0 per a eixir) 0","title":"Exercici 1"},{"location":"exercicis_redis/#exercici-2","text":"Realitzar en el mateix paquet un altre programa, aquesta vegada gr\u00e0fic, que ens diga el mateix, per\u00f2 d'una forma m\u00e9s atractiva. El programa s'ha de dir T7Ex2_ConsultaClausGrafica . Contindr\u00e0 un JList on han d'apar\u00e9ixer totes les claus, millor si estan ordenades alfab\u00e8ticament. Recordeu que el JList \u00e9s un poc complicat, que es basa en un DefaultListModel , i \u00e9s a aquest a qui heu d'afegir els elements. Al costat ha d'haver un JTextField que diga de quin tipus \u00e9s quan se seleccione un element del JList I tamb\u00e9 un JTextArea amb el seu valor (siga del tipus que siga) Aquest seria l'esquelet. import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JTextArea import javax.swing.DefaultListModel import javax.swing.JList import javax.swing.JScrollPane import java.awt.FlowLayout import java.awt.Color import redis.clients.jedis.Jedis import java.awt.EventQueue class EstadisticaRD : JFrame() { val etTipClau= JLabel(\"Tipus:\") val tipClau= JTextField(8) val contClau = JTextArea(8,15) val con = Jedis(\"localhost\") val listModel = DefaultListModel<String>() val llClaus = JList(listModel) init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 450) setLayout(FlowLayout()) llClaus.setForeground(Color.blue) val scroll = JScrollPane(llClaus) llClaus.setVisibleRowCount(20) val scroll2 = JScrollPane(contClau) add(scroll) add(etTipClau) add(tipClau) add(scroll2) setSize(600, 400) setVisible(true) inicialitzar() llClaus.addListSelectionListener{valorCanviat()} } fun inicialitzar(){ } fun valorCanviat() { } } fun main(args: Array<String>) { EventQueue.invokeLater { EstadisticaRD().isVisible = true } } I aquest el seu aspecte Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercici 2"},{"location":"AD_Firebase/1__introducci_firebase/","text":"4.1 - Introducci\u00f3: Firebase Firebase \u00e9s un servei de backend, \u00e9s a dir del costat del servidor, que ofereix la possibilitat de guardar les dades d'aplicacions web i de dispositius m\u00f2bils, amb la particularitat que en temps real es poden actualitzar les dades modificades des d'un dels clients connectats a tots els altres que estiguen connectats. Ofereix una s\u00e8rie de serveis, entre els quals podem destacar: Firebase Auth - Autenticaci\u00f3 d'usuaris : permet gestionar la validaci\u00f3 d'usuaris c\u00f2modament. Inclou l'autenticaci\u00f3 per mig de Facebook, GitHub, Twitter i Google, i tamb\u00e9 la validaci\u00f3 utilitzant compte de correu, guardant-se la contrasenya en Firebase, amb la qual cosa ens allibera d'haver de guardar-les al nostre dispositiu. Realtime Database - Base de Dades en Temps Real : permet guardar unes dades en el n\u00favol, que estaran sincronitzades en totes les aplicacions (clients) connectats. No \u00e9s realment una Base de Dades, tan sols un document JSON. Cloud Firestore : \u00e9s una evoluci\u00f3 de l'anterior que ja s\u00ed que permet guardar col\u00b7leccions de documents JSON, i per tant ja es pot considerar una Base de Dades. Firebase Storage : permet guardar arxius per a les nostres aplicacions, com poden ser audios, v\u00eddeos, imatges, ... En aquest tema ens fixarem sobretot en el segon i tercer servei, els de Bases de Dades. Hem de recordar, que la Realtime Database no \u00e9s una Base de Dades completa. Tan sols \u00e9s un document JSON el que podrem guardar, aix\u00f2 s\u00ed, tan llarg com vulguem. Es tracta per tant d'una Base de Dades NoSQL, o millor dit una mini Base de Dades NoSQL. Aix\u00f2 s\u00ed, que permet sincronitzar les dades en temps real en tots els dispositius connectats. En canvi el Cloud Firestore s\u00ed que \u00e9s una Base de Dades completa. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.1 - Introducci\u00f3"},{"location":"AD_Firebase/1__introducci_firebase/#41-introduccio-firebase","text":"Firebase \u00e9s un servei de backend, \u00e9s a dir del costat del servidor, que ofereix la possibilitat de guardar les dades d'aplicacions web i de dispositius m\u00f2bils, amb la particularitat que en temps real es poden actualitzar les dades modificades des d'un dels clients connectats a tots els altres que estiguen connectats. Ofereix una s\u00e8rie de serveis, entre els quals podem destacar: Firebase Auth - Autenticaci\u00f3 d'usuaris : permet gestionar la validaci\u00f3 d'usuaris c\u00f2modament. Inclou l'autenticaci\u00f3 per mig de Facebook, GitHub, Twitter i Google, i tamb\u00e9 la validaci\u00f3 utilitzant compte de correu, guardant-se la contrasenya en Firebase, amb la qual cosa ens allibera d'haver de guardar-les al nostre dispositiu. Realtime Database - Base de Dades en Temps Real : permet guardar unes dades en el n\u00favol, que estaran sincronitzades en totes les aplicacions (clients) connectats. No \u00e9s realment una Base de Dades, tan sols un document JSON. Cloud Firestore : \u00e9s una evoluci\u00f3 de l'anterior que ja s\u00ed que permet guardar col\u00b7leccions de documents JSON, i per tant ja es pot considerar una Base de Dades. Firebase Storage : permet guardar arxius per a les nostres aplicacions, com poden ser audios, v\u00eddeos, imatges, ... En aquest tema ens fixarem sobretot en el segon i tercer servei, els de Bases de Dades. Hem de recordar, que la Realtime Database no \u00e9s una Base de Dades completa. Tan sols \u00e9s un document JSON el que podrem guardar, aix\u00f2 s\u00ed, tan llarg com vulguem. Es tracta per tant d'una Base de Dades NoSQL, o millor dit una mini Base de Dades NoSQL. Aix\u00f2 s\u00ed, que permet sincronitzar les dades en temps real en tots els dispositius connectats. En canvi el Cloud Firestore s\u00ed que \u00e9s una Base de Dades completa. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.1 - Introducci\u00f3: Firebase"},{"location":"AD_Firebase/2__creaci_duna_aplicaci/","text":"4.2 - Creaci\u00f3 d'una aplicaci\u00f3 La Base de Dades, que hem quedat que poden ser un document \u00fanic JSON en el cas de Realtime Database, i tot un conjunt en el cas de Cloud Firestore, est\u00e0 associada a una aplicaci\u00f3. Crearem des de l'entorn de Firebase una nova aplicaci\u00f3, la refer\u00e8ncia de la qual \u00e9s la que utilitzarem en l'aplicaci\u00f3 web o aplicaci\u00f3 m\u00f2bil. Aix\u00ed doncs, podem crear-nos unes quantes aplicacions Firebase, i en cadascuna guardarem una Base de Dades. Ens far\u00e0 falta autenticar-nos amb un compte de Google. El proc\u00e9s de creaci\u00f3 el farem des de l'entorn de firebase: www.firebase.com . El seg\u00fcent v\u00eddeo mostra el proc\u00e9s de creaci\u00f3 d'una aplicaci\u00f3: Regles de seguretat Inicialment triarem l'opci\u00f3 modo de prueba , en el qual tot el m\u00f3n pot accedir a les dades. Evidentment no es poden deixar aquestes regles de forma definitiva, per\u00f2 per a comen\u00e7ar a provar, est\u00e0 b\u00e9. De fet, en l'\u00faltima versi\u00f3 ho deixar\u00e0 en mode de prova durant un mes. De tota manera, si ho vulgu\u00e9rem allargar, anir\u00edem a la configuraci\u00f3 dels rules 4.2.1 Utilitzaci\u00f3 des de IntelliJ Mirarem l'acc\u00e9s des de IntelliJ, que \u00e9s l'entorn que utilitzem en el present m\u00f2dul. Per desenvolupar una aplicaci\u00f3 a IntelliJ amb Kotlin que acceda a Firebase, una manera prou f\u00e0cil \u00e9s utilitzar Maven per gestionar les depend\u00e8ncies necess\u00e0ries. Els passos i les depend\u00e8ncies necess\u00e0ries que s'han d'afegir al pom.xml : a) Repositori Maven de Google : Algunes depend\u00e8ncies del Firebase poden no estar disponibles al repositori Maven Central. Assegureu-vos d'afegir el repositori de Google <repositories> <repository> <id>google</id> <url>https://maven.google.com/</url> </repository> </repositories> b) Afegeix Firebase Admin SDK . L'Admin SDK \u00e9s la biblioteca principal que us permet interactuar amb els serveis de Firebase, com Realtime Database, Cloud Firestore, Authentication, entre d'altres. <dependency> <groupId>com.google.firebase</groupId> <artifactId>firebase-admin</artifactId> <version>9.1.1</version> </dependency> c) Serveis Adicionals Si necessites interactuar amb serveis espec\u00edfics, com Firestore o Realtime Database, aqu\u00ed tens les depend\u00e8ncies corresponents: Cloud Firestore <dependency> <groupId>com.google.cloud</groupId> <artifactId>google-cloud-firestore</artifactId> <version>3.15.0</version> </dependency> <dependency> <groupId>com.google.auth</groupId> <artifactId>google-auth-library-oauth2-http</artifactId> <version>1.27.0</version> </dependency> Realtime Database La funcionalitat del Realtime Database est\u00e0 inclosa a l'Admin SDK, per la qual cosa no necessiteu afegir depend\u00e8ncies addicionals. Simplement utilitza les classes proporcionades per firebase-admin. Nota Feu clic a Reload Maven Project per assegurar-vos que totes les depend\u00e8ncies es descarguen correctament. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.2 - Creaci\u00f3 d'una aplicaci\u00f3"},{"location":"AD_Firebase/2__creaci_duna_aplicaci/#42-creacio-duna-aplicacio","text":"La Base de Dades, que hem quedat que poden ser un document \u00fanic JSON en el cas de Realtime Database, i tot un conjunt en el cas de Cloud Firestore, est\u00e0 associada a una aplicaci\u00f3. Crearem des de l'entorn de Firebase una nova aplicaci\u00f3, la refer\u00e8ncia de la qual \u00e9s la que utilitzarem en l'aplicaci\u00f3 web o aplicaci\u00f3 m\u00f2bil. Aix\u00ed doncs, podem crear-nos unes quantes aplicacions Firebase, i en cadascuna guardarem una Base de Dades. Ens far\u00e0 falta autenticar-nos amb un compte de Google. El proc\u00e9s de creaci\u00f3 el farem des de l'entorn de firebase: www.firebase.com . El seg\u00fcent v\u00eddeo mostra el proc\u00e9s de creaci\u00f3 d'una aplicaci\u00f3: Regles de seguretat Inicialment triarem l'opci\u00f3 modo de prueba , en el qual tot el m\u00f3n pot accedir a les dades. Evidentment no es poden deixar aquestes regles de forma definitiva, per\u00f2 per a comen\u00e7ar a provar, est\u00e0 b\u00e9. De fet, en l'\u00faltima versi\u00f3 ho deixar\u00e0 en mode de prova durant un mes. De tota manera, si ho vulgu\u00e9rem allargar, anir\u00edem a la configuraci\u00f3 dels rules","title":"4.2 - Creaci\u00f3 d'una aplicaci\u00f3"},{"location":"AD_Firebase/2__creaci_duna_aplicaci/#421-utilitzacio-des-de-intellij","text":"Mirarem l'acc\u00e9s des de IntelliJ, que \u00e9s l'entorn que utilitzem en el present m\u00f2dul. Per desenvolupar una aplicaci\u00f3 a IntelliJ amb Kotlin que acceda a Firebase, una manera prou f\u00e0cil \u00e9s utilitzar Maven per gestionar les depend\u00e8ncies necess\u00e0ries. Els passos i les depend\u00e8ncies necess\u00e0ries que s'han d'afegir al pom.xml : a) Repositori Maven de Google : Algunes depend\u00e8ncies del Firebase poden no estar disponibles al repositori Maven Central. Assegureu-vos d'afegir el repositori de Google <repositories> <repository> <id>google</id> <url>https://maven.google.com/</url> </repository> </repositories> b) Afegeix Firebase Admin SDK . L'Admin SDK \u00e9s la biblioteca principal que us permet interactuar amb els serveis de Firebase, com Realtime Database, Cloud Firestore, Authentication, entre d'altres. <dependency> <groupId>com.google.firebase</groupId> <artifactId>firebase-admin</artifactId> <version>9.1.1</version> </dependency> c) Serveis Adicionals Si necessites interactuar amb serveis espec\u00edfics, com Firestore o Realtime Database, aqu\u00ed tens les depend\u00e8ncies corresponents: Cloud Firestore <dependency> <groupId>com.google.cloud</groupId> <artifactId>google-cloud-firestore</artifactId> <version>3.15.0</version> </dependency> <dependency> <groupId>com.google.auth</groupId> <artifactId>google-auth-library-oauth2-http</artifactId> <version>1.27.0</version> </dependency> Realtime Database La funcionalitat del Realtime Database est\u00e0 inclosa a l'Admin SDK, per la qual cosa no necessiteu afegir depend\u00e8ncies addicionals. Simplement utilitza les classes proporcionades per firebase-admin. Nota Feu clic a Reload Maven Project per assegurar-vos que totes les depend\u00e8ncies es descarguen correctament. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.2.1 Utilitzaci\u00f3 des de IntelliJ"},{"location":"AD_Firebase/3__realtime_database_rd/","text":"4.3 - Realtime Database (RD) Encara que la finalitat \u00e9s utilitzar-lo des del nostre entorn de programaci\u00f3, sempre ens anir\u00e0 b\u00e9 \"tocar\" les dades directament des d'un entorn propi. El seguent v\u00eddeo correspon a una versi\u00f3 anterior de Firebase per\u00f2, es igualment v\u00e0lid. L'entorn que ens ofereix Firebase ser\u00e0 suficient. Podrem visualitzar les dades que tenim introdu\u00efdes en totes les nostres aplicacions, i tamb\u00e9 editar- les: introduir, modificar i esborrar. Recordem que podrem utilitzar 2 versions: Realtime Database Cloud Firestore Comencem per Realtime Database 4.3.1 RD: Utilitzaci\u00f3 des de l'entorn de Firebase Farem especial menci\u00f3 al fet que el que guardem \u00e9s un document JSON . Fins i tot ens el podrem baixar (exportar) o pujar com un document (importar). Aix\u00f2 s\u00ed, l'operaci\u00f3 d'importaci\u00f3 destrueix les dades anteriors, mostra de que nom\u00e9s podem guardar un document JSON . Aques \u00e9s el contingut del fitxer Empleats.json que s'introdueix en el v\u00eddeo. Est\u00e0 formatat per a una f\u00e0cil lectura, per\u00f2 en realitat no importaria que estiguera tot seguit. Ho teniu disponible a l'aula virtual perqu\u00e8 us ho importeu. { \"empresa\": { \"empleat\": [ { \"num\": 1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000 }, { \"num\": 2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200 }, { \"num\": 3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100 }, { \"num\": 4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500 } ] } } Ja heu vist que en importar Empleats.json s'han perdut les altres dades. Poseu una altra vegada la parella clau-valor a1 (per exemple amb el valor Hola ) ja que per ser molt senzilla l'estructura la utilitzarem en alguns exemples. Aix\u00ed ens queda l'estructura per als posteriors exemples: 4.3.2 RD: Utilitzaci\u00f3 des de IntelliJ Per als exemples i exercicis d'aquesta part, ens crearem un projecte anomenat Tema8 , amb els paquets exemples_realtimedatabase , exemples_cloudfirestore , exemples_cloudstorage i exercicis . 4.3.2.1 RD-IntelliJ: Connexi\u00f3 des de Kotlin Configuraci\u00f3 El primer que hem de fer \u00e9s preparar el nostre projecte per a que puga accedir a l'aplicaci\u00f3 que hem creat en Firebase. En l'entron de IntelliJ ens baixarem un fitxer json on estar\u00e0 la clau per a accedir a la nostra aplicaci\u00f3. Hem d'anar a la configuraci\u00f3 del projecte i dins de la configuraci\u00f3 anar a la pestanya Cuentas de servicio ( Service Accounts ). Ah\u00ed veurem uns exemples d'utilitzaci\u00f3 (a nosaltres ens interessa Java ), i baix de tot un bot\u00f3 per a Generar una nova clau privada : Ens baixar\u00e0 un fitxer json que haurem de guardar a l'arrel del projecte. Despr\u00e9s, com deia l'exemple, col\u00b7loquem el seg\u00fcent per a un acc\u00e9s correcte: val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Av\u00eds No us oblideu de substituir el nom del fitxer json . Tamb\u00e9 heu de tenir en compte que la URL de la base de dades ser\u00e0 diferent per a cadasc\u00fa de nosaltres . Ho tenim escrit en Java , i per tant haurem de fer la transformaci\u00f3 a Kotlin . i quedar\u00e0 aix\u00ed (ho he particularitzat al meu projecte, per\u00f2 recordeu que heu de canviar el nom del fitxer json i la URL pels vostres): val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Refer\u00e8ncia a la Base de Dades i a les dades concretes a les quals volem accedir Ens haurem de crear un objecte FirebaseDatabase , que ser\u00e0 una refer\u00e8ncia a tota la Base de Dades: val database = FirebaseDatabase.getInstance() A partir d'ella podr\u00edem fer refer\u00e8ncia a una parella clau-valor que estiga a l'arrel, com quan hav\u00edem creat a1 ( per\u00f2 recordeu que ara no existeix): val refA1 = database.getReference(\"a1\") Tamb\u00e9 podr\u00edem fer refer\u00e8ncia a una parella clau-valor que no estiga en l'arrel de la Base de Dades. Senzillament posar\u00edem la ruta des de l'arrel. Per exemple, per a accedir al nom del primer empleat de l'empresa que tenim guardat, ho far\u00edem aix\u00ed: val empleat1 = database.getReference(\"empresa/empleat/0/nom\") En els casos anteriors hem optat per agafar parelles clau-valor, b\u00e9 a l'arrel o m\u00e9s cap a dins de l'estructura JSON. Per\u00f2 en definitiva \u00e9s una parella clau- valor. Tamb\u00e9 podem optar per agafar l'estructura JSON i treballar amb ella, com vam fer en el Tema 3, quan vam treballar amb l'estructura JSON. val empresa = database.getReference(\"empresa\") D'aquesta manera, en la qual agafem tota l'estructura, tindrem dues maneres de treballar posteriorment per a accedir m\u00e9s avall en l'estructura: Passar-lo a objectes i arrays de JSON, i treballar com vam fer en el Tema 3. Molt c\u00f2mode, sobretot quan es tracta d'operacions de lectura Treballar directament amb m\u00e8todes de Firebase que ens permeten accedir b\u00e9 a tots els fills d'una estructura, b\u00e9 a un fill en concret Ho mostrarem en els exemples posteriors. 4.3.2.2 RD-IntelliJ: Acc\u00e9s a les dades Guardar dades Disposem del m\u00e8tode setValue() de la refer\u00e8ncia a la dada a la que volem accedir. Accepta 2 par\u00e0metres: El primer \u00e9s el valor que volem introduir. El segon \u00e9s un listener per a poder sincronitzar. Ens far\u00e0 falta sincronitzar \u00fanicament en els programes mode text senzills que fem. Quan fem els gr\u00e0fics no ens far\u00e0 falta, i posarem null Si per exemple vulgu\u00e9rem guardar en la variable a1 , de forma senzilla ho far\u00edem aix\u00ed (ens funcionaria en els gr\u00e0fics): refA1.setValue(\"Valor per a a1\", null); En l'operaci\u00f3 de guardar si la parella clau-valor on es va a guardar existia, doncs modificar\u00e0 el valor. I si no existia, la crear\u00e0. En el cas que vulguem guardar no en l'arrel, sin\u00f3 m\u00e9s avall en l'estructura JSON, disposem del m\u00e8tode child() , que ens permet anar a un determinat fill, a l'estil de la segona manera descrita en el subpunt anterior. Per exemple si vulgu\u00e9rem canviar l'edat del primer empleat, l'estructura per a arribar seria: empresa -- > empleat --> 0 --> edat empresa.child(\"empleat\").child(\"0\").child(\"edat\").setValue(\"33\", null); Si no existia abans qualsevol dels nodes de l'estructura, el crear\u00e0. Fins i tot, si no existira abans de la sent\u00e8ncia anterior empresa , doncs crearia empresa , i dins d'ell empleat , i dins d'ell 0 , i dins d'ell edat , amb el valor 33. Tamb\u00e9 podr\u00edem guardar tot un objecte, i es convertir\u00e0 en estructura JSON, per\u00f2 ens ho deixem per a m\u00e9s avant. Per\u00f2 com hav\u00edem dit abans, s'ha de sincronitzar amb Firebase, des del programa Java ens hem d'esperar a aquesta sincronitzaci\u00f3, si no no ens funcionar\u00e0. En el segon par\u00e0metre ens posem un listener . Aquest exemple ja est\u00e0 complet. Guardeu-lo amb el nom Exemple_8_3_1_FirebaseRD_Guardar.kt import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.FirebaseDatabase import java.util.concurrent.CountDownLatch import com.google.firebase.database.DatabaseReference import com.google.firebase.database.DatabaseError fun main() { val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) val empresa = FirebaseDatabase.getInstance().getReference(\"empresa\") val done = CountDownLatch (1) empresa.child(\"empleat\").child(\"0\").child(\"edat\").setValue(\"33\", object : DatabaseReference.CompletionListener { override fun onComplete(p0: DatabaseError?, p1: DatabaseReference) { done.countDown() } }) done.await() } Recordeu que heu de canviar el nom del fitxer json i la URL per les vostres. I aquest \u00e9s el resultat d'executar-lo. A la dreta podem veure com s'est\u00e0 modificant la dada que preten\u00edem: Per\u00f2 com coment\u00e0vem, en el cas de les aplicacions gr\u00e0fiques resulta m\u00e9s senzill, ja que no haurem d'esperar expressament a la sincronitzaci\u00f3, sin\u00f3 que l'aplicaci\u00f3 es queda en marxa, i per tant no hi haur\u00e0 problema. Ho practicarem en un exemple nou, on arribarem a construir un Xat, i ens servir\u00e0 per a practicar totes les coses que us volem mostrar en Realtme Database de Firebase. Aquest \u00e9s l'esquelet del programa. Guardeu-lo amb el nom Exemple_8_3_2_FirebaseRD_CrearXat.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.* class CrearXat : JFrame() { val etUltimMissatge= JLabel(\"\u00daltim missatge: \") val ultimMissatge= JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell1 = JPanel(FlowLayout()) panell1.add(etUltimMissatge) panell1.add(ultimMissatge) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEnabled(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener{enviar()} val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) // Exemple de listener de lectura \u00fanica addListenerForSingleValue() // Per a posar el t\u00edtol. Sobre nomXat // Exemple de listener de lectura cont\u00ednua addValueEventListener() // Per a posar l'\u00faltim missatge registrat. Sobre a1 // Exemple de listener d'una llista addChildEventListener() // Per a posar tota la llista de missatges. Sobre xat } // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar(){ } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXat().isVisible = true } } Recordeu que heu de canviar el nom del fitxer json i la URL per les vostres. Ho podeu copiar de l'exemple anterior. Observeu que ja tenim col\u00b7locades en l'anterior programa les dades de connexi\u00f3: val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Per a guardar les dades, en aquest exemple de moment guardarem en la clau de Firebase a1 en el moment de apretar el bot\u00f3 de baix d' Enviar . No far\u00e0 falta muntar cap listener per veure si ja hem acabat, ja que el programa continua en marxa. // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar(){ val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) } Observeu que ara queda molt senzilla la sent\u00e8ncia de guardar, i no ha fet falta ficar cap listener en el segon par\u00e0metre, sin\u00f3 null , per estar en una aplicaci\u00f3 gr\u00e0fica: refA1.setValue(missatge.getText(), null) El resultat seria aquest, on es veu la modificaci\u00f3 de la dada que vol\u00edem: Recuperar dades La lectura de dades \u00e9s m\u00e9s complicada que l'escriptura. \u00c9s en bona part per culpa de la \"sincronitzaci\u00f3\" de les dades que obtenim. Per aix\u00f2 no existeix un m\u00e8tode tan senzill com el getValue() . La lectura s'ha de muntar sempre amb Listeners , que es queden escoltant si hi ha alguna actualitzaci\u00f3 de la dada registrada. Recordeu que \u00e9s de la dada registrada, no de tota la Base de Dades. Podem muntar dos tipus de Listeners, per\u00f2 el seu funcionament ser\u00e0 similar Els que nom\u00e9s escolten per a llegir les dades al principi, i no esperaran per a posteriors canvis en les dades (i per tant no consumiran tants recursos): addListenerForSingleValueEvent() Els que es queden escoltant tota l'estona: addValueEventListener() En ambdos casos obtenim com a par\u00e0metre un Data Snapshot (c\u00f2pia) de la dada registrada. I d'aquest tipus, DataSnapshot , s\u00ed que tenim el m\u00e8tode getValue() per a accedir a la dada. Ambd\u00f3s tipus de Listeners tenen un tractament absolutament similar, \u00fanicament amb la difer\u00e8ncia abans esmentada que el segon est\u00e0 sempre escoltant, i el primer nom\u00e9s escolta una vegada al principi. El m\u00e8tode getValue() admet un par\u00e0metre que ser\u00e0 la classe del tipus que volem obtenir. Podem posar les seg\u00fcents: String.class , i aleshores el que obtenim s'interpretar\u00e0 com un String Double.class , i s'interpretar\u00e0 com un n\u00famero real de doble precisi\u00f3 Boolean.class , i s'interptretar\u00e0com un valor boole\u00e0 Tamb\u00e9 es poden posar classes per a obtenir tot un objecte (Map) i per a una llista (List). Fins i tot es podria arribar a posar una classe definida per nosaltres. Per\u00f2 amb els anteriors nosaltres en tindrem prou. addListenerForSingleValue() En aquest primer exemple anem a agafar una \u00fanica vegada la dada que ens interessa, i per tant utilitzarem addListenerForSingleValueEvent() . Ens servir\u00e0 per a posar el t\u00edtol de l'aplicaci\u00f3, i ho farem consultant la clau nomXat que haur\u00e0 d'estar creada pr\u00e8viament des del mateix entorn de Firebase. Modificarem el fragment de programa marcat pel comentari, i el que fem \u00e9s esperar per a llegir nom\u00e9s una vegada. // Exemple de listener de lectura \u00fanica addListenerForSingleValue() // Per a posar el t\u00edtol. Sobre nomXat val nomXat = FirebaseDatabase.getInstance().getReference(\"nomXat\") nomXat.addListenerForSingleValueEvent(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { setTitle(dataSnapshot.getValue().toString()) } override fun onCancelled(error: DatabaseError) { } }) Aquest \u00e9s el resultat, i quan l'executeu observareu que tarda un poc en mostrar el t\u00edtol. \u00c9s perqu\u00e8 ho est\u00e0 llegint de Firebase. addValueEventListener() Anem a veure ara un exemple per a l'altre m\u00e8tode, el addValueEventListener() , que \u00e9s el que es queda escoltant tota la estona Concretarem el que farem \u00e9s escoltar tota la estona per si es produeix algun canvi en la clau a1 . Si es produeix aquest canvi, modificar\u00e0 el valor del JLabel ultimMissatge que est\u00e0 dalt. Tamb\u00e9 afegirem el missatge al JTextArea, per a que tinga apari\u00e8ncia de xat, encara que despr\u00e9s ho modificarem per a millorar-ho. Ho hem de col\u00b7locar on est\u00e0 marcat pel comentari // Exemple de listener de lectura cont\u00ednua addValueEventListener() // Per a posar l'\u00faltim missatge registrat. Sobre a1 val ultim = FirebaseDatabase.getInstance().getReference(\"a1\") ultim.addValueEventListener(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { ultimMissatge.setText(dataSnapshot.getValue().toString()) area.append(dataSnapshot.getValue().toString() + \"\\n\") // aquesta l\u00ednia despr\u00e9s la llevarem } override fun onCancelled(error: DatabaseError ) { } }) L'execuci\u00f3 ser\u00e0 com la de la pantalla de dalt a l'esquerra. Per\u00f2 si es produeix algun canvi (com es mostra en la pantalla de la dreta), aquest canvi es reflectir\u00e0 autom\u00e0ticament tant en el JLabel de dalt com en el TextArea, tal i com es mostra en la imatge de baix a l'esquerra: En canvi, una vegada est\u00e0 en marxa el programeta del xat, per m\u00e9s que canviem nomXat , que es traslladava al t\u00edtol de la finestra, aquest t\u00edtol ja no canviar\u00e0 perqu\u00e8 recordem que es feia una \u00fanica lectura Com veieu ha estat molt f\u00e0cil construir una esp\u00e8cie de xat. Ara millorarem aquest xat. Tractament de llistes Per a explicar millor el tractament de llistes, crearem una altra refer\u00e8ncia a una clau que representar\u00e0 una llista de missatges. Cada missatge constar\u00e0 d'un nom i un contingut, i aix\u00ed vuerem tamb\u00e9 el tractament d'objectes. El primer que ens haurem de definir \u00e9s la refer\u00e8ncia a aquesta nova clau, que l'anomenarem xat (no est\u00e0 creada encara en la Base de Dades). val xat = FirebaseDatabase.getInstance().getReference(\"xat\") Anar afegint elements a la llista, ho podem fer a m\u00e0, posant nosaltres l'\u00edndex, ja que hem vist que la manera de representar en Firebase una llista s\u00f3n fills \u00fanicament amb clau, que seria el sub\u00edndex. Per tant una manera d'afegir el primer missatge del xat, seria amb l'\u00edndex 0. Posem aquest codi quan apretem el bot\u00f3 (no hem llevat de moment el fet de guardar en a1 , per a que mentre fem les proves es veja tot el xat): // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") xat.child(\"0\").child(\"nom\").setValue(\"Usuari1\", null) xat.child(\"0\").child(\"contingut\").setValue(missatge.getText(), null) } Quan apretem s'actualitzar\u00e0 la Base de Dades d'aquesta manera: Per\u00f2 aquesta manera d'introduir en la llista acaba per ser molt poc pr\u00e0ctica. Si ara an\u00e0rem a introduir un segon missatge (nom i contingut) li haur\u00edem de posar com a \u00edndex 1. No \u00e9s viable. Podr\u00edem dur 2 pol\u00edtiques per a gestionar els \u00edndex: Podr\u00edem portar un comptador per a saber quin \u00edndex toca inserir en cada moment, cosa tamb\u00e9 molt poc pr\u00e0ctica perqu\u00e8 si l'aplicaci\u00f3 est\u00e0 instal\u00b7lada en m\u00e9s d'un dispositiu, podria haver col\u00b7lisi\u00f3 en el n\u00famero d'\u00edndex. Podr\u00edem mirar quin \u00e9s l'\u00faltim \u00edndex introdu\u00eft, per a incrementar-lo en una unitat. Per\u00f2 a\u00e7\u00f2 suposa llegir de la Base de Dades, i com hem vist abans suposar\u00e0 muntar un Listener, segurament dels d'un \u00fanic \u00fas. Per tant se'ns complic la cosa. Es pot fer, per\u00f2 no \u00e9s c\u00f2mode. Per a estalviar-nos aquesta feina, Firebase ens proporciona un m\u00e9tode per a afegir un nou element a una llista, el m\u00e8tode push() . Introdueix un nou element a la llista, i li posa com a \u00edndex un numero generat de manera que no es repetir\u00e0 mai. L'\u00fanica preocupaci\u00f3 que hem de tenir \u00e9s guardar aquest \u00edndex (amb getKey() ), per a poder posar-lo com a clau. // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") val clau = xat.push().getKey() xat.child(clau).child(\"nom\").setValue(\"Usuari1\", null) xat.child(clau).child(\"contingut\").setValue(missatge.getText(), null) } I el resultat \u00e9s aquest: Com veiem \u00e9s una cadena molt llarga que no \u00e9s repetir\u00e0 mai. Anem a fer una tercera inserci\u00f3 d'un missatge, per\u00f2 ara ho completarem m\u00e9s, i solucionarem de pas algun problemeta que pod\u00edem haver tingut. Crearem una classe anomenada Missatge , que inclour\u00e0 les propietats nom i contingut . Crearem un objecte Missatge amb uns nous valors, i veurem que el podem guardar perfectament. Per a aquest exemple segurament no valdria la pena l'esfor\u00e7, per\u00f2 es pot veure la utilitat per a objectes m\u00e9s complexos. Primer definim la classe. El millor \u00e9s que el guardem com una classe nova, \u00e9s a dir com a Missatge.kt ****: class Missatge(var nom: String, var contingut: String) Per a guardar, col\u00b7locar\u00edem aquestes sent\u00e8ncies entre les accions del clic del bot\u00f3, com en les altres ocasions. Observeu com ara ni tan sols ens fa falta guardar en una variable el getKey() , ja que es fa tot nom\u00e9s en una operaci\u00f3: // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") val m = Missatge(\"Usuari1\", missatge.getText()) xat.push().setValue(m, null) } El resultat seria el mateix que en l'ocasi\u00f3 anterior: Ara nom\u00e9s ens falta el tractament de lectura de les llistes. addChildEventListener() Podr\u00edem muntar un Listener com en les altres ocasions, per\u00f2 ara disposarem d'uns altres Listeners que se'ns acoplen millor ja que s'activen quan hi ha modificacions en algun element de la llista. En l'exemple nom\u00e9s utilitzarem el de creaci\u00f3 d'un nou element, per\u00f2 com veurem tamb\u00e9 podr\u00edem utilitzar els moments de supressi\u00f3 o modificaci\u00f3 d'elements. Es tracta del Listener ChildEventListener , i hem d'utilitzar el m\u00e8tode addChildEventListener() sobre la llista. Voldr\u00e0 la implementaci\u00f3 dels m\u00e8todes: onChildAdded() , onChildChanged() , onChildRemoved() i onChildMoved() , a banda de onCancelled() . Per\u00f2 com coment\u00e0vem ara nom\u00e9s utilitzarem la de creaci\u00f3 d'un nou element, i senzillament el mostrarem en el TextView. Al dataSnapshot arriba \u00fanicament l'element introdu\u00eft, modificat o esborrat, no tota la llista. Per tant \u00e9s molt c\u00f2mode. Tamb\u00e9 arriba el nom de l'element anterior com a segon par\u00e0metre, per si hem de fer algun tractament. \u00c9s important fixar-nos en que aquest segon par\u00e0metre l'hem de definir com a String? (amb la interrogant per a contemplar el null). Si no posem la interrogant, no es comportar\u00e0 b\u00e9 la primera vegada. A\u00e7\u00f2 ens substituir\u00e0 l'escriptura que f\u00e9iem abans del TextArea (a mi m'havia quedat en la l\u00ednia 95, vosaltres la tindreu aproximadament per ah\u00ed). Per tant llevem aquesta l\u00ednia: area.append(dataSnapshot.getValue().toString() + \"\\n\"); // aquesta l\u00ednia despr\u00e9s la llevarem I posem el seg\u00fcent on queda marcat pel comentari. Aix\u00ed ens quedar\u00e0 un xat m\u00e9s \"professional\" // Exemple de listener d'una llista addChildEventListener() // Per a posar tota la llista de missatges. Sobre xat val xat = FirebaseDatabase.getInstance().getReference(\"xat\") xat.addChildEventListener(object : ChildEventListener { override fun onChildAdded(dataSnapshot: DataSnapshot, s: String?) { area.append(dataSnapshot.child(\"nom\").getValue().toString() + \": \" + dataSnapshot.child(\"contingut\").getValue().toString() + \"\\n\" ) } override fun onChildChanged(dataSnapshot: DataSnapshot, s: String?) { } override fun onChildRemoved(dataSnapshot: DataSnapshot) { } override fun onChildMoved(dataSnapshot: DataSnapshot, s: String?) { } override fun onCancelled(databaseError: DatabaseError) { } } ) Si executem aquest programa, tenint nom\u00e9s en el clic del bot\u00f3 l'addici\u00f3 d'un element a la llista i aquest Listener anterior, veurem que inicialment ens apareixeran tots els elements de la llista. Aix\u00f2 \u00e9s perqu\u00e8 considera que inicialment s'afegeix cadascun dels elements de la llista, i en el mateix ordre en que estan definits. En aquest imatge hem aprofitat per afegir un quart missatge: 4.3.2.3 RD-IntelliJ: Tot l'exemple Tot l'exemple Anem a posar tot l'exemple que arreplega tot l'anterior. Primer la classe Missatge.java : class Missatge(var nom: String, var contingut: String) Ara el programa, que hav\u00edem quedat de guardar-lo en el fitxer Exemple_8_3_2_2_FirebaseRD_CrearXat.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.* class CrearXat : JFrame() { val etUltimMissatge= JLabel(\"\u00daltim missatge: \") val ultimMissatge= JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell1 = JPanel(FlowLayout()) panell1.add(etUltimMissatge) panell1.add(ultimMissatge) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEnabled(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener{enviar()} val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) // Exemple de listener de lectura \u00fanica addListenerForSingleValue() // Per a posar el t\u00edtol. Sobre nomXat val nomXat = FirebaseDatabase.getInstance().getReference(\"nomXat\") nomXat.addListenerForSingleValueEvent(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { setTitle(dataSnapshot.getValue().toString()) } override fun onCancelled(error: DatabaseError) { } }) // Exemple de listener de lectura cont\u00ednua addValueEventListener() // Per a posar l'\u00faltim missatge registrat. Sobre a1 val ultim = FirebaseDatabase.getInstance().getReference(\"a1\") ultim.addValueEventListener(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { ultimMissatge.setText(dataSnapshot.getValue().toString()) } override fun onCancelled(error: DatabaseError ) { } }) // Exemple de listener d'una llista addChildEventListener() // Per a posar tota la llista de missatges. Sobre xat val xat = FirebaseDatabase.getInstance().getReference(\"xat\") xat.addChildEventListener(object : ChildEventListener { override fun onChildAdded(dataSnapshot: DataSnapshot, s: String?) { area.append(dataSnapshot.child(\"nom\").getValue().toString() + \": \" + dataSnapshot.child(\"contingut\").getValue().toString() + \"\\n\" ) } override fun onChildChanged(dataSnapshot: DataSnapshot, s: String?) { } override fun onChildRemoved(dataSnapshot: DataSnapshot) { } override fun onChildMoved(dataSnapshot: DataSnapshot, s: String?) { } override fun onCancelled(databaseError: DatabaseError) { } } ) } // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") val m = Missatge(\"Usuari1\", missatge.getText()) xat.push().setValue(m, null) } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXat().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.3 - Realtime Database"},{"location":"AD_Firebase/3__realtime_database_rd/#43-realtime-database-rd","text":"Encara que la finalitat \u00e9s utilitzar-lo des del nostre entorn de programaci\u00f3, sempre ens anir\u00e0 b\u00e9 \"tocar\" les dades directament des d'un entorn propi. El seguent v\u00eddeo correspon a una versi\u00f3 anterior de Firebase per\u00f2, es igualment v\u00e0lid. L'entorn que ens ofereix Firebase ser\u00e0 suficient. Podrem visualitzar les dades que tenim introdu\u00efdes en totes les nostres aplicacions, i tamb\u00e9 editar- les: introduir, modificar i esborrar. Recordem que podrem utilitzar 2 versions: Realtime Database Cloud Firestore Comencem per Realtime Database","title":"4.3 - Realtime Database (RD)"},{"location":"AD_Firebase/3__realtime_database_rd/#431-rd-utilitzacio-des-de-lentorn-de-firebase","text":"Farem especial menci\u00f3 al fet que el que guardem \u00e9s un document JSON . Fins i tot ens el podrem baixar (exportar) o pujar com un document (importar). Aix\u00f2 s\u00ed, l'operaci\u00f3 d'importaci\u00f3 destrueix les dades anteriors, mostra de que nom\u00e9s podem guardar un document JSON . Aques \u00e9s el contingut del fitxer Empleats.json que s'introdueix en el v\u00eddeo. Est\u00e0 formatat per a una f\u00e0cil lectura, per\u00f2 en realitat no importaria que estiguera tot seguit. Ho teniu disponible a l'aula virtual perqu\u00e8 us ho importeu. { \"empresa\": { \"empleat\": [ { \"num\": 1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000 }, { \"num\": 2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200 }, { \"num\": 3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100 }, { \"num\": 4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500 } ] } } Ja heu vist que en importar Empleats.json s'han perdut les altres dades. Poseu una altra vegada la parella clau-valor a1 (per exemple amb el valor Hola ) ja que per ser molt senzilla l'estructura la utilitzarem en alguns exemples. Aix\u00ed ens queda l'estructura per als posteriors exemples:","title":"4.3.1 RD: Utilitzaci\u00f3 des de l'entorn de Firebase"},{"location":"AD_Firebase/3__realtime_database_rd/#432-rd-utilitzacio-des-de-intellij","text":"Per als exemples i exercicis d'aquesta part, ens crearem un projecte anomenat Tema8 , amb els paquets exemples_realtimedatabase , exemples_cloudfirestore , exemples_cloudstorage i exercicis .","title":"4.3.2 RD: Utilitzaci\u00f3 des de IntelliJ"},{"location":"AD_Firebase/3__realtime_database_rd/#4321-rd-intellij-connexio-des-de-kotlin","text":"Configuraci\u00f3 El primer que hem de fer \u00e9s preparar el nostre projecte per a que puga accedir a l'aplicaci\u00f3 que hem creat en Firebase. En l'entron de IntelliJ ens baixarem un fitxer json on estar\u00e0 la clau per a accedir a la nostra aplicaci\u00f3. Hem d'anar a la configuraci\u00f3 del projecte i dins de la configuraci\u00f3 anar a la pestanya Cuentas de servicio ( Service Accounts ). Ah\u00ed veurem uns exemples d'utilitzaci\u00f3 (a nosaltres ens interessa Java ), i baix de tot un bot\u00f3 per a Generar una nova clau privada : Ens baixar\u00e0 un fitxer json que haurem de guardar a l'arrel del projecte. Despr\u00e9s, com deia l'exemple, col\u00b7loquem el seg\u00fcent per a un acc\u00e9s correcte: val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Av\u00eds No us oblideu de substituir el nom del fitxer json . Tamb\u00e9 heu de tenir en compte que la URL de la base de dades ser\u00e0 diferent per a cadasc\u00fa de nosaltres . Ho tenim escrit en Java , i per tant haurem de fer la transformaci\u00f3 a Kotlin . i quedar\u00e0 aix\u00ed (ho he particularitzat al meu projecte, per\u00f2 recordeu que heu de canviar el nom del fitxer json i la URL pels vostres): val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Refer\u00e8ncia a la Base de Dades i a les dades concretes a les quals volem accedir Ens haurem de crear un objecte FirebaseDatabase , que ser\u00e0 una refer\u00e8ncia a tota la Base de Dades: val database = FirebaseDatabase.getInstance() A partir d'ella podr\u00edem fer refer\u00e8ncia a una parella clau-valor que estiga a l'arrel, com quan hav\u00edem creat a1 ( per\u00f2 recordeu que ara no existeix): val refA1 = database.getReference(\"a1\") Tamb\u00e9 podr\u00edem fer refer\u00e8ncia a una parella clau-valor que no estiga en l'arrel de la Base de Dades. Senzillament posar\u00edem la ruta des de l'arrel. Per exemple, per a accedir al nom del primer empleat de l'empresa que tenim guardat, ho far\u00edem aix\u00ed: val empleat1 = database.getReference(\"empresa/empleat/0/nom\") En els casos anteriors hem optat per agafar parelles clau-valor, b\u00e9 a l'arrel o m\u00e9s cap a dins de l'estructura JSON. Per\u00f2 en definitiva \u00e9s una parella clau- valor. Tamb\u00e9 podem optar per agafar l'estructura JSON i treballar amb ella, com vam fer en el Tema 3, quan vam treballar amb l'estructura JSON. val empresa = database.getReference(\"empresa\") D'aquesta manera, en la qual agafem tota l'estructura, tindrem dues maneres de treballar posteriorment per a accedir m\u00e9s avall en l'estructura: Passar-lo a objectes i arrays de JSON, i treballar com vam fer en el Tema 3. Molt c\u00f2mode, sobretot quan es tracta d'operacions de lectura Treballar directament amb m\u00e8todes de Firebase que ens permeten accedir b\u00e9 a tots els fills d'una estructura, b\u00e9 a un fill en concret Ho mostrarem en els exemples posteriors.","title":"4.3.2.1 RD-IntelliJ: Connexi\u00f3 des de Kotlin"},{"location":"AD_Firebase/3__realtime_database_rd/#4322-rd-intellij-acces-a-les-dades","text":"Guardar dades Disposem del m\u00e8tode setValue() de la refer\u00e8ncia a la dada a la que volem accedir. Accepta 2 par\u00e0metres: El primer \u00e9s el valor que volem introduir. El segon \u00e9s un listener per a poder sincronitzar. Ens far\u00e0 falta sincronitzar \u00fanicament en els programes mode text senzills que fem. Quan fem els gr\u00e0fics no ens far\u00e0 falta, i posarem null Si per exemple vulgu\u00e9rem guardar en la variable a1 , de forma senzilla ho far\u00edem aix\u00ed (ens funcionaria en els gr\u00e0fics): refA1.setValue(\"Valor per a a1\", null); En l'operaci\u00f3 de guardar si la parella clau-valor on es va a guardar existia, doncs modificar\u00e0 el valor. I si no existia, la crear\u00e0. En el cas que vulguem guardar no en l'arrel, sin\u00f3 m\u00e9s avall en l'estructura JSON, disposem del m\u00e8tode child() , que ens permet anar a un determinat fill, a l'estil de la segona manera descrita en el subpunt anterior. Per exemple si vulgu\u00e9rem canviar l'edat del primer empleat, l'estructura per a arribar seria: empresa -- > empleat --> 0 --> edat empresa.child(\"empleat\").child(\"0\").child(\"edat\").setValue(\"33\", null); Si no existia abans qualsevol dels nodes de l'estructura, el crear\u00e0. Fins i tot, si no existira abans de la sent\u00e8ncia anterior empresa , doncs crearia empresa , i dins d'ell empleat , i dins d'ell 0 , i dins d'ell edat , amb el valor 33. Tamb\u00e9 podr\u00edem guardar tot un objecte, i es convertir\u00e0 en estructura JSON, per\u00f2 ens ho deixem per a m\u00e9s avant. Per\u00f2 com hav\u00edem dit abans, s'ha de sincronitzar amb Firebase, des del programa Java ens hem d'esperar a aquesta sincronitzaci\u00f3, si no no ens funcionar\u00e0. En el segon par\u00e0metre ens posem un listener . Aquest exemple ja est\u00e0 complet. Guardeu-lo amb el nom Exemple_8_3_1_FirebaseRD_Guardar.kt import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.FirebaseDatabase import java.util.concurrent.CountDownLatch import com.google.firebase.database.DatabaseReference import com.google.firebase.database.DatabaseError fun main() { val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) val empresa = FirebaseDatabase.getInstance().getReference(\"empresa\") val done = CountDownLatch (1) empresa.child(\"empleat\").child(\"0\").child(\"edat\").setValue(\"33\", object : DatabaseReference.CompletionListener { override fun onComplete(p0: DatabaseError?, p1: DatabaseReference) { done.countDown() } }) done.await() } Recordeu que heu de canviar el nom del fitxer json i la URL per les vostres. I aquest \u00e9s el resultat d'executar-lo. A la dreta podem veure com s'est\u00e0 modificant la dada que preten\u00edem: Per\u00f2 com coment\u00e0vem, en el cas de les aplicacions gr\u00e0fiques resulta m\u00e9s senzill, ja que no haurem d'esperar expressament a la sincronitzaci\u00f3, sin\u00f3 que l'aplicaci\u00f3 es queda en marxa, i per tant no hi haur\u00e0 problema. Ho practicarem en un exemple nou, on arribarem a construir un Xat, i ens servir\u00e0 per a practicar totes les coses que us volem mostrar en Realtme Database de Firebase. Aquest \u00e9s l'esquelet del programa. Guardeu-lo amb el nom Exemple_8_3_2_FirebaseRD_CrearXat.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.* class CrearXat : JFrame() { val etUltimMissatge= JLabel(\"\u00daltim missatge: \") val ultimMissatge= JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell1 = JPanel(FlowLayout()) panell1.add(etUltimMissatge) panell1.add(ultimMissatge) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEnabled(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener{enviar()} val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) // Exemple de listener de lectura \u00fanica addListenerForSingleValue() // Per a posar el t\u00edtol. Sobre nomXat // Exemple de listener de lectura cont\u00ednua addValueEventListener() // Per a posar l'\u00faltim missatge registrat. Sobre a1 // Exemple de listener d'una llista addChildEventListener() // Per a posar tota la llista de missatges. Sobre xat } // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar(){ } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXat().isVisible = true } } Recordeu que heu de canviar el nom del fitxer json i la URL per les vostres. Ho podeu copiar de l'exemple anterior. Observeu que ja tenim col\u00b7locades en l'anterior programa les dades de connexi\u00f3: val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Per a guardar les dades, en aquest exemple de moment guardarem en la clau de Firebase a1 en el moment de apretar el bot\u00f3 de baix d' Enviar . No far\u00e0 falta muntar cap listener per veure si ja hem acabat, ja que el programa continua en marxa. // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar(){ val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) } Observeu que ara queda molt senzilla la sent\u00e8ncia de guardar, i no ha fet falta ficar cap listener en el segon par\u00e0metre, sin\u00f3 null , per estar en una aplicaci\u00f3 gr\u00e0fica: refA1.setValue(missatge.getText(), null) El resultat seria aquest, on es veu la modificaci\u00f3 de la dada que vol\u00edem: Recuperar dades La lectura de dades \u00e9s m\u00e9s complicada que l'escriptura. \u00c9s en bona part per culpa de la \"sincronitzaci\u00f3\" de les dades que obtenim. Per aix\u00f2 no existeix un m\u00e8tode tan senzill com el getValue() . La lectura s'ha de muntar sempre amb Listeners , que es queden escoltant si hi ha alguna actualitzaci\u00f3 de la dada registrada. Recordeu que \u00e9s de la dada registrada, no de tota la Base de Dades. Podem muntar dos tipus de Listeners, per\u00f2 el seu funcionament ser\u00e0 similar Els que nom\u00e9s escolten per a llegir les dades al principi, i no esperaran per a posteriors canvis en les dades (i per tant no consumiran tants recursos): addListenerForSingleValueEvent() Els que es queden escoltant tota l'estona: addValueEventListener() En ambdos casos obtenim com a par\u00e0metre un Data Snapshot (c\u00f2pia) de la dada registrada. I d'aquest tipus, DataSnapshot , s\u00ed que tenim el m\u00e8tode getValue() per a accedir a la dada. Ambd\u00f3s tipus de Listeners tenen un tractament absolutament similar, \u00fanicament amb la difer\u00e8ncia abans esmentada que el segon est\u00e0 sempre escoltant, i el primer nom\u00e9s escolta una vegada al principi. El m\u00e8tode getValue() admet un par\u00e0metre que ser\u00e0 la classe del tipus que volem obtenir. Podem posar les seg\u00fcents: String.class , i aleshores el que obtenim s'interpretar\u00e0 com un String Double.class , i s'interpretar\u00e0 com un n\u00famero real de doble precisi\u00f3 Boolean.class , i s'interptretar\u00e0com un valor boole\u00e0 Tamb\u00e9 es poden posar classes per a obtenir tot un objecte (Map) i per a una llista (List). Fins i tot es podria arribar a posar una classe definida per nosaltres. Per\u00f2 amb els anteriors nosaltres en tindrem prou. addListenerForSingleValue() En aquest primer exemple anem a agafar una \u00fanica vegada la dada que ens interessa, i per tant utilitzarem addListenerForSingleValueEvent() . Ens servir\u00e0 per a posar el t\u00edtol de l'aplicaci\u00f3, i ho farem consultant la clau nomXat que haur\u00e0 d'estar creada pr\u00e8viament des del mateix entorn de Firebase. Modificarem el fragment de programa marcat pel comentari, i el que fem \u00e9s esperar per a llegir nom\u00e9s una vegada. // Exemple de listener de lectura \u00fanica addListenerForSingleValue() // Per a posar el t\u00edtol. Sobre nomXat val nomXat = FirebaseDatabase.getInstance().getReference(\"nomXat\") nomXat.addListenerForSingleValueEvent(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { setTitle(dataSnapshot.getValue().toString()) } override fun onCancelled(error: DatabaseError) { } }) Aquest \u00e9s el resultat, i quan l'executeu observareu que tarda un poc en mostrar el t\u00edtol. \u00c9s perqu\u00e8 ho est\u00e0 llegint de Firebase. addValueEventListener() Anem a veure ara un exemple per a l'altre m\u00e8tode, el addValueEventListener() , que \u00e9s el que es queda escoltant tota la estona Concretarem el que farem \u00e9s escoltar tota la estona per si es produeix algun canvi en la clau a1 . Si es produeix aquest canvi, modificar\u00e0 el valor del JLabel ultimMissatge que est\u00e0 dalt. Tamb\u00e9 afegirem el missatge al JTextArea, per a que tinga apari\u00e8ncia de xat, encara que despr\u00e9s ho modificarem per a millorar-ho. Ho hem de col\u00b7locar on est\u00e0 marcat pel comentari // Exemple de listener de lectura cont\u00ednua addValueEventListener() // Per a posar l'\u00faltim missatge registrat. Sobre a1 val ultim = FirebaseDatabase.getInstance().getReference(\"a1\") ultim.addValueEventListener(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { ultimMissatge.setText(dataSnapshot.getValue().toString()) area.append(dataSnapshot.getValue().toString() + \"\\n\") // aquesta l\u00ednia despr\u00e9s la llevarem } override fun onCancelled(error: DatabaseError ) { } }) L'execuci\u00f3 ser\u00e0 com la de la pantalla de dalt a l'esquerra. Per\u00f2 si es produeix algun canvi (com es mostra en la pantalla de la dreta), aquest canvi es reflectir\u00e0 autom\u00e0ticament tant en el JLabel de dalt com en el TextArea, tal i com es mostra en la imatge de baix a l'esquerra: En canvi, una vegada est\u00e0 en marxa el programeta del xat, per m\u00e9s que canviem nomXat , que es traslladava al t\u00edtol de la finestra, aquest t\u00edtol ja no canviar\u00e0 perqu\u00e8 recordem que es feia una \u00fanica lectura Com veieu ha estat molt f\u00e0cil construir una esp\u00e8cie de xat. Ara millorarem aquest xat. Tractament de llistes Per a explicar millor el tractament de llistes, crearem una altra refer\u00e8ncia a una clau que representar\u00e0 una llista de missatges. Cada missatge constar\u00e0 d'un nom i un contingut, i aix\u00ed vuerem tamb\u00e9 el tractament d'objectes. El primer que ens haurem de definir \u00e9s la refer\u00e8ncia a aquesta nova clau, que l'anomenarem xat (no est\u00e0 creada encara en la Base de Dades). val xat = FirebaseDatabase.getInstance().getReference(\"xat\") Anar afegint elements a la llista, ho podem fer a m\u00e0, posant nosaltres l'\u00edndex, ja que hem vist que la manera de representar en Firebase una llista s\u00f3n fills \u00fanicament amb clau, que seria el sub\u00edndex. Per tant una manera d'afegir el primer missatge del xat, seria amb l'\u00edndex 0. Posem aquest codi quan apretem el bot\u00f3 (no hem llevat de moment el fet de guardar en a1 , per a que mentre fem les proves es veja tot el xat): // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") xat.child(\"0\").child(\"nom\").setValue(\"Usuari1\", null) xat.child(\"0\").child(\"contingut\").setValue(missatge.getText(), null) } Quan apretem s'actualitzar\u00e0 la Base de Dades d'aquesta manera: Per\u00f2 aquesta manera d'introduir en la llista acaba per ser molt poc pr\u00e0ctica. Si ara an\u00e0rem a introduir un segon missatge (nom i contingut) li haur\u00edem de posar com a \u00edndex 1. No \u00e9s viable. Podr\u00edem dur 2 pol\u00edtiques per a gestionar els \u00edndex: Podr\u00edem portar un comptador per a saber quin \u00edndex toca inserir en cada moment, cosa tamb\u00e9 molt poc pr\u00e0ctica perqu\u00e8 si l'aplicaci\u00f3 est\u00e0 instal\u00b7lada en m\u00e9s d'un dispositiu, podria haver col\u00b7lisi\u00f3 en el n\u00famero d'\u00edndex. Podr\u00edem mirar quin \u00e9s l'\u00faltim \u00edndex introdu\u00eft, per a incrementar-lo en una unitat. Per\u00f2 a\u00e7\u00f2 suposa llegir de la Base de Dades, i com hem vist abans suposar\u00e0 muntar un Listener, segurament dels d'un \u00fanic \u00fas. Per tant se'ns complic la cosa. Es pot fer, per\u00f2 no \u00e9s c\u00f2mode. Per a estalviar-nos aquesta feina, Firebase ens proporciona un m\u00e9tode per a afegir un nou element a una llista, el m\u00e8tode push() . Introdueix un nou element a la llista, i li posa com a \u00edndex un numero generat de manera que no es repetir\u00e0 mai. L'\u00fanica preocupaci\u00f3 que hem de tenir \u00e9s guardar aquest \u00edndex (amb getKey() ), per a poder posar-lo com a clau. // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") val clau = xat.push().getKey() xat.child(clau).child(\"nom\").setValue(\"Usuari1\", null) xat.child(clau).child(\"contingut\").setValue(missatge.getText(), null) } I el resultat \u00e9s aquest: Com veiem \u00e9s una cadena molt llarga que no \u00e9s repetir\u00e0 mai. Anem a fer una tercera inserci\u00f3 d'un missatge, per\u00f2 ara ho completarem m\u00e9s, i solucionarem de pas algun problemeta que pod\u00edem haver tingut. Crearem una classe anomenada Missatge , que inclour\u00e0 les propietats nom i contingut . Crearem un objecte Missatge amb uns nous valors, i veurem que el podem guardar perfectament. Per a aquest exemple segurament no valdria la pena l'esfor\u00e7, per\u00f2 es pot veure la utilitat per a objectes m\u00e9s complexos. Primer definim la classe. El millor \u00e9s que el guardem com una classe nova, \u00e9s a dir com a Missatge.kt ****: class Missatge(var nom: String, var contingut: String) Per a guardar, col\u00b7locar\u00edem aquestes sent\u00e8ncies entre les accions del clic del bot\u00f3, com en les altres ocasions. Observeu com ara ni tan sols ens fa falta guardar en una variable el getKey() , ja que es fa tot nom\u00e9s en una operaci\u00f3: // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") val m = Missatge(\"Usuari1\", missatge.getText()) xat.push().setValue(m, null) } El resultat seria el mateix que en l'ocasi\u00f3 anterior: Ara nom\u00e9s ens falta el tractament de lectura de les llistes. addChildEventListener() Podr\u00edem muntar un Listener com en les altres ocasions, per\u00f2 ara disposarem d'uns altres Listeners que se'ns acoplen millor ja que s'activen quan hi ha modificacions en algun element de la llista. En l'exemple nom\u00e9s utilitzarem el de creaci\u00f3 d'un nou element, per\u00f2 com veurem tamb\u00e9 podr\u00edem utilitzar els moments de supressi\u00f3 o modificaci\u00f3 d'elements. Es tracta del Listener ChildEventListener , i hem d'utilitzar el m\u00e8tode addChildEventListener() sobre la llista. Voldr\u00e0 la implementaci\u00f3 dels m\u00e8todes: onChildAdded() , onChildChanged() , onChildRemoved() i onChildMoved() , a banda de onCancelled() . Per\u00f2 com coment\u00e0vem ara nom\u00e9s utilitzarem la de creaci\u00f3 d'un nou element, i senzillament el mostrarem en el TextView. Al dataSnapshot arriba \u00fanicament l'element introdu\u00eft, modificat o esborrat, no tota la llista. Per tant \u00e9s molt c\u00f2mode. Tamb\u00e9 arriba el nom de l'element anterior com a segon par\u00e0metre, per si hem de fer algun tractament. \u00c9s important fixar-nos en que aquest segon par\u00e0metre l'hem de definir com a String? (amb la interrogant per a contemplar el null). Si no posem la interrogant, no es comportar\u00e0 b\u00e9 la primera vegada. A\u00e7\u00f2 ens substituir\u00e0 l'escriptura que f\u00e9iem abans del TextArea (a mi m'havia quedat en la l\u00ednia 95, vosaltres la tindreu aproximadament per ah\u00ed). Per tant llevem aquesta l\u00ednia: area.append(dataSnapshot.getValue().toString() + \"\\n\"); // aquesta l\u00ednia despr\u00e9s la llevarem I posem el seg\u00fcent on queda marcat pel comentari. Aix\u00ed ens quedar\u00e0 un xat m\u00e9s \"professional\" // Exemple de listener d'una llista addChildEventListener() // Per a posar tota la llista de missatges. Sobre xat val xat = FirebaseDatabase.getInstance().getReference(\"xat\") xat.addChildEventListener(object : ChildEventListener { override fun onChildAdded(dataSnapshot: DataSnapshot, s: String?) { area.append(dataSnapshot.child(\"nom\").getValue().toString() + \": \" + dataSnapshot.child(\"contingut\").getValue().toString() + \"\\n\" ) } override fun onChildChanged(dataSnapshot: DataSnapshot, s: String?) { } override fun onChildRemoved(dataSnapshot: DataSnapshot) { } override fun onChildMoved(dataSnapshot: DataSnapshot, s: String?) { } override fun onCancelled(databaseError: DatabaseError) { } } ) Si executem aquest programa, tenint nom\u00e9s en el clic del bot\u00f3 l'addici\u00f3 d'un element a la llista i aquest Listener anterior, veurem que inicialment ens apareixeran tots els elements de la llista. Aix\u00f2 \u00e9s perqu\u00e8 considera que inicialment s'afegeix cadascun dels elements de la llista, i en el mateix ordre en que estan definits. En aquest imatge hem aprofitat per afegir un quart missatge:","title":"4.3.2.2 RD-IntelliJ: Acc\u00e9s a les dades"},{"location":"AD_Firebase/3__realtime_database_rd/#4323-rd-intellij-tot-lexemple","text":"Tot l'exemple Anem a posar tot l'exemple que arreplega tot l'anterior. Primer la classe Missatge.java : class Missatge(var nom: String, var contingut: String) Ara el programa, que hav\u00edem quedat de guardar-lo en el fitxer Exemple_8_3_2_2_FirebaseRD_CrearXat.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.* class CrearXat : JFrame() { val etUltimMissatge= JLabel(\"\u00daltim missatge: \") val ultimMissatge= JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell1 = JPanel(FlowLayout()) panell1.add(etUltimMissatge) panell1.add(ultimMissatge) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEnabled(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener{enviar()} val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) // Exemple de listener de lectura \u00fanica addListenerForSingleValue() // Per a posar el t\u00edtol. Sobre nomXat val nomXat = FirebaseDatabase.getInstance().getReference(\"nomXat\") nomXat.addListenerForSingleValueEvent(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { setTitle(dataSnapshot.getValue().toString()) } override fun onCancelled(error: DatabaseError) { } }) // Exemple de listener de lectura cont\u00ednua addValueEventListener() // Per a posar l'\u00faltim missatge registrat. Sobre a1 val ultim = FirebaseDatabase.getInstance().getReference(\"a1\") ultim.addValueEventListener(object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { ultimMissatge.setText(dataSnapshot.getValue().toString()) } override fun onCancelled(error: DatabaseError ) { } }) // Exemple de listener d'una llista addChildEventListener() // Per a posar tota la llista de missatges. Sobre xat val xat = FirebaseDatabase.getInstance().getReference(\"xat\") xat.addChildEventListener(object : ChildEventListener { override fun onChildAdded(dataSnapshot: DataSnapshot, s: String?) { area.append(dataSnapshot.child(\"nom\").getValue().toString() + \": \" + dataSnapshot.child(\"contingut\").getValue().toString() + \"\\n\" ) } override fun onChildChanged(dataSnapshot: DataSnapshot, s: String?) { } override fun onChildRemoved(dataSnapshot: DataSnapshot) { } override fun onChildMoved(dataSnapshot: DataSnapshot, s: String?) { } override fun onCancelled(databaseError: DatabaseError) { } } ) } // Exemple de guardar dades sense haver d'esperar per ser una aplicaci\u00f3 gr\u00e0fica // Per a guardar dades. Sobre a1, i desp\u0155es sobre la llista xat fun enviar() { val refA1 = FirebaseDatabase.getInstance().getReference(\"a1\") refA1.setValue(missatge.getText(), null) val xat = FirebaseDatabase.getInstance().getReference(\"xat\") val m = Missatge(\"Usuari1\", missatge.getText()) xat.push().setValue(m, null) } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXat().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.3.2.3 RD-IntelliJ: Tot l'exemple"},{"location":"AD_Firebase/4__cloud_firestore_cf/","text":"4.4 - Cloud Firestore (CF) Cloud Firestore \u00e9s l'evoluci\u00f3 de Realtime Database, on podrem guardar m\u00e9s d'un document. Els documents aniran organitzats en col\u00b7leccions. Ja podem parlar d'una vertadera Base de Dades documental. Google recomana la utilitzaci\u00f3 de Cloud Firestore en compte de Realtime Database. Potser fins i tot en un futur deixen de proveir aquesta \u00faltima. Per\u00f2 no seria cap problema perqu\u00e8 tot el que podem guardar en Realtime Database ho podrem guardar en Cloud Firestore, sense que se'ns complique l'organitzaci\u00f3 de les dades. I l'acc\u00e9s \u00e9s igual de f\u00e0cil. De vegades Firebase l'anomena Firestore Database o Cloud Firestore 4.4.1 CF: Utilitzaci\u00f3 des de l'entorn de Firebase Amb el Cloud Firestore ja podrem guardar m\u00e9s d'un document, i aniran agrupats en col\u00b7leccions de documents. En el seg\u00fcent v\u00eddeo anem a insistir en aquest aspecte dels documents, ja que \u00e9s el m\u00e9s noved\u00f3s. Hem de fer la consideraci\u00f3 de que encara que treballem sobre la mateixa Base de Dades de Firebase, des de Cloud Firestore no podrem accedir a les dades de Realtime Database, i a l'inrev\u00e9s . Aquesta \u00e9s l'estructura de dades que ens hem guardat en l'exemple: Observeu tamb\u00e9 que dins d'un document d'una col\u00b7lecci\u00f3 es pot comen\u00e7ar una col\u00b7lecci\u00f3 i dins d'ella crear documents, etc. De manera que ho podem fer recursiu, i s'enriqueixen molt les possibilitats de disseny de la nostra Base de Dades. Anem a aprofundir en aquesta possibilitat de les subcol\u00b7leccions per a redissenyar les dades del nostre exemple del xat. Subcol\u00b7leccions Com es veia en l'\u00faltima imatge, es poden crear subcol\u00b7leccions en un document, i aquestes col\u00b7leccions contenir a la seua vegada tots els documents que calga. Aleshores ens redissenyarem el xat constru\u00eft en la part de Realtime Database . En aquell moment vam posar tots els missatges del xat en un llista. Ens anava molt b\u00e9, perqu\u00e8 despr\u00e9s pos\u00e0vem un listener sobre la clau del xat que detectava tots els elements nous: el addChildEventListener() . Tanmateix en el Cloud Firestore no tindrem el listener anterior. El que s\u00ed que disposarem \u00e9s d'un listener que detecte els nous documents sobre una col\u00b7lecci\u00f3. Aleshores anem a muntar cada missatge del xat com un nou document, que de moment nom\u00e9s tindr\u00e0 nom d'usuari i contingut de missatge. Per tant, despr\u00e9s de l'anterior tenim una col\u00b7lecci\u00f3 anomenada Xats , dins de la qual hi ha un document anomenat XatProva , dins del qual hi ha un camp anomenat nomXat i una col\u00b7lecci\u00f3 anomenada missatges , dins del qual hi ha dos documents, un d'ells amb nom 0 i un altre amb nom generat per Cloud Firestore 4.4.2 CF: Utilitzaci\u00f3 des de IntelliJ Exemple Practicarem tot el que ve a continuaci\u00f3 sobre un programa gr\u00e0fic. Aquest \u00e9s el seu esquelet. Guardeu-lo en un fitxer anomenat Exemple_8_4_1_FirebaseCF_CrearXatCloud .kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import javax.swing.JPanel import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.auth.oauth2.GoogleCredentials import com.google.cloud.firestore.DocumentChange import com.google.firebase.FirebaseApp import com.google.firebase.FirebaseOptions import com.google.firebase.cloud.FirestoreClient class CrearXat : JFrame() { val etUsuari = JLabel(\"Nom Usuari:\") val usuari = JTextField(25) val etUltimMissatge = JLabel(\"\u00daltim missatge: \") val ultimMissatge = JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell11 = JPanel(FlowLayout()) panell11.add(etUsuari) panell11.add(usuari) val panell12 = JPanel(FlowLayout()) panell12.add(etUltimMissatge) panell12.add(ultimMissatge) val panell1 = JPanel(GridLayout(2, 1)) panell1.add(panell11) panell1.add(panell12) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener { enviar() } val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge DocumentSnapshot FirestoreException // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges } // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXat().isVisible = true } } I aquest \u00e9s el seu aspecte: 4.4.2.1 CF-IntelliJ: Connexi\u00f3 des de Kotlin Configuraci\u00f3 Ara ser\u00e0 lleugerament m\u00e9s que en el cas de Realtime Database vist en el punt 4.3.2.1 ., ja que no caldr\u00e0 especificar la URL de la Base de Dades, amb la refer\u00e8ncia al fitxer json ser\u00e0 suficient. Recordeu que ens vam baixar un fitxer json amb la clau privada que vam guardar a l'arrel del projecte (i del qual \u00e9s molt convenient guardar c\u00f2pia). Despr\u00e9s, com deia l'exemple, col\u00b7loquem el seg\u00fcent per a un acc\u00e9s correcte, on no posem el .setDatebaseURL() : val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.Builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) No us oblideu de substituir el nom del fitxer json . Refer\u00e8ncia a la Base de Dades i a les dades concretes a les quals volem accedir Ara la refer\u00e8ncia a la Base de Dades de Cloud Firestore canviar\u00e0: val database = FirestoreClient.getFirestore() Com que la informaci\u00f3 est\u00e0 organitzada en col\u00b7leccions i dins d'ella en documents, podrem accedir primer a les col\u00b7leccions i dins d'elles a documents. A continuaci\u00f3 teniu la refer\u00e8ncia pas a pas: val col = database.collection(\"Xats\") val docXatProva = col.document(\"XatProva\") Encara que evidentment ho pod\u00edem haver fet en una \u00fanica l\u00ednia: val docXatProva = database.collection(\"Xats\").document(\"XatProva\") No ens plantejarem posar refer\u00e8ncies a elements de dins d'un document, sin\u00f3 que de moment accedirem a tot el conjunt del document. Recordeu que Realtime Database , com era un \u00fanic document JSON, all\u00e0 anava tot i obligat\u00f2riament hav\u00edem de poder tenir una refer\u00e8ncia a un \u00fanic element. Com en Cloud Firestore ho podem organitzar en col\u00b7leccions i documents, cadascun d'ells el podem dissenyar millor i que continga \u00fanicament les dades estrictes. Aleshores ens anir\u00e0 b\u00e9 accedir a tot el document. 4.4.2.2 CF-IntelliJ: Acc\u00e9s a les dades Guardar dades Com acabem de comentar, accedim a tot un document dins d'una col\u00b7lecci\u00f3. Per a guardar dades, ens podem plantejar 3 operacions d'escriptura sobre el document: Sobreescriure'l tot: ho farem amb el m\u00e8tode set() Esborrar-lo tot: amb el m\u00e8tode delete() Modificar-lo: amb el m\u00e8tode update() Excepte per esborrar, per a les altres operacions ens fa falta saber l'estructura del document. Per aix\u00f2 tant m\u00e8tode set() com el m\u00e8tode update() accepten com a par\u00e0metre no una \u00fanica dada, sin\u00f3 una estructura que puga arribar a reflectir el document. Acceptaran com a par\u00e0metre un Map , on podrem col\u00b7locar les claus i els valors de tots els membres del document. Cada valor pot ser dels tipus que vam practicar en el punt anterior: string, number, boolean, array, map, ... La manera de col\u00b7locar un element en una estructura Map <> \u00e9s amb el m\u00e8tode put() , que acceptar\u00e0 dos par\u00e0metres: la clau i el valor. En el seg\u00fcent exemple. quan s'apreta el bot\u00f3 d'enviar (baix a la dreta) es guardar\u00e0 el contingut del quadre de text usuari que est\u00e0 dalt i el de missatge que est\u00e0 baix. Per\u00f2 observeu que estem utilitzant el m\u00e8tode set() i per tant matxacar\u00edem el que ja ten\u00edem constru\u00eft (el nom del xat i potser tamb\u00e9 la subcol\u00b7lecci\u00f3 de missatges). Per tant US ACONSELLE QUE NO EXECUTEU EL QUE VE A CONTINUACI\u00d3 // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.set(dades) } Aquest seria el resultat, creant-se el document amb les 2 clau-valor, i havent matxacat el que hi havia, que era el nom del xat. Afortunadament no s'ha carregat la col\u00b7lecci\u00f3 missatges, per\u00f2 no ens podem fiar En realitat els m\u00e8todes set() , delete() i update() tornen un valor, que \u00e9s un ApiFuture<WriteResult> , que permet averiguar com ha anat l'actualitzaci\u00f3 de les dades. D'aquest ApiFuture<> podem obtenir el moment en qu\u00e8 s'ha confirmat l'actualitzaci\u00f3, i es podria aprofitar per a tractar-lo per si d\u00f3na algun error. Ampliem l'exemple anterior en qu\u00e8 utilitz\u00e0vem el set() per a comprovar el que comentem, senzillament mostrant el moment en qu\u00e8 s'ha actualitzat, i poder comprovar que \u00e9s un ApiFuture <WriteResult> . US ACONSELLE QUE NO EXECUTEU EL QUE VE A CONTINUACI\u00d3 // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) val result = docXatProva.set(dades) println(\"Data d'actualitzaci\u00f3: \" + result.get().getUpdateTime()) } Si veiem la consola d'eixida d' IntelliJ veurem despr\u00e9s dels warnings de sempre, al final en negre com ha impr\u00e9s el moment de la confirmaci\u00f3. En els exemples anterior, en cas d'haver-se executat hauran matxacat el document XatProva i aix\u00f2 era per haver utilitzat el m\u00e8tode set() . Anem a canviar-lo pel m\u00e8tode update() , en qu\u00e8 senzillament afegir\u00e0 (i si \u00e9s necessari matxacar\u00e0) les dades que proporcionem, per\u00f2 mantindr\u00e0 les altres. AQUEST EXEMPLE S\u00cd QUE EL PODEU FER // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) } conservarem tant el camp nomXat com la col\u00b7lecci\u00f3 missatges Recuperar dades Com en el cas del Realtime Database, ens plantegem dos casos: Una \u00fanica lectura Un listener que es quede escoltant per si hi ha canvis Com comprovarem, queda m\u00e9s senzilla la lectura \u00fanica en el cas de Cloud Firestore. Lectura \u00fanica Per a fer una lectura \u00fanica utilitzarem el m\u00e8tode get() sobre una refer\u00e8ncia al document que volem llegir. El resultat ens ve en un ApiFuture , que com es veu \u00e9s una c\u00f2pia de les dades en una interface ApiFutute , indicant que la tindrem disponible en un futur. Sobre aquesta farem get() per a obtenir aquesta c\u00f2pia (ser\u00e0 un objecte). I sobre ella podrem fer: getData() per a obtenir tot el document en un Map getId() per a obtenir el nom del document get( nomClau ) per a obtenir directament el valor d'una clau del document getString( nomClau ) per a obtenir el valor de la clau en forma de string getDouble( nomClau ) per a obtenir el valor de la clau en forma de double getDate( nomClau ) per a obtenir el valor de la clau en forma de date ... L'exemple d'\u00fanica lectura el farem per a posar el t\u00edtol de l'aplicaci\u00f3, com en l'exemple del Realtime Database. Pr\u00e8viament, des de la consola de Firebase ja hav\u00edem creat la parella clau-valor: nomXat: Xat Cloud Firestore , dins del document XatProva . Si pels exemples anteriors (els que havia marcat en roig que no us aconsellava fer) heu perdut aquesta parella, \u00e9s el moment de crear-la de nou: Ara s\u00ed que haurem d'anar amb compte en el moment de guardar les dades. Si utilitzem el m\u00e8tode set() matxacarem el document anterior (amb el nom del xat). Per tant, a partir d'ara ens convindr\u00e0 utilitzar el m\u00e8tode update() . Ho tornarem a especificar en el moment de fer aquesta escriptura. I aquestes seran les sent\u00e8ncies per a posar el t\u00edtol de l'aplicaci\u00f3: // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat val database = FirestoreClient.getFirestore() val docRef = database.collection(\"Xats\").document(\"XatProva\") val future = docRef.get() val nomXat = future.get().getString(\"nomXat\") this.setTitle(nomXat) I ac\u00ed tenim el resultat, on es veu el t\u00edtol agafat de Cloud Firestore: Listener que es queda escoltant: addSnapshotListener() De forma paral\u00b7lela al Realtime Database, si volem rebre una notificaci\u00f3 de quan hi haja un canvi en el document que ens interessa, sobre una refer\u00e8ncia a aquest document ens muntarem un listener, en aquest cas amb el m\u00e8tode addSnapshotListener() . Al m\u00e8tode onEvent() que s'ha de sobreescriure arribar\u00e0 un par\u00e0metre de tipus DocumentSnapshot , que ser\u00e0 una c\u00f2pia del document. Com en el cas anterior podrem fer sobre ell un getData() per a obtenir tot el document, getString( nomClau ) per a obtenir el valor de la clau com un string, etc. En el nostre exemple, de moment l'utilitzem tant per a posar l'\u00faltim missatge com per a anar omplint l'\u00e0rea central amb el xat. Per\u00f2 com hav\u00edem comentat abans, hem de cuidar de no matxacar tot el document per a no perdre el t\u00edtol del xat. Per tant, l'acci\u00f3 que farem en apretar el bot\u00f3 per a enviar el missatge no ser\u00e0 set() sin\u00f3 update(). Per si de cas hav\u00edeu fet els exemples que us havia aconsellat que no f\u00e9reu, ac\u00ed teniu una altra vegada el codi correcte: // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) } I ara s\u00ed el addSnapshotListener() : // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge DocumentSnapshot FirestoreException docRef.addSnapshotListener { snapshot, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } if (snapshot != null && snapshot.exists()) { ultimMissatge.setText(snapshot.getString(\"ultimMissatge\")) area.append(snapshot.getString(\"ultimUsuari\") + \": \" + snapshot.getString(\"ultimMissatge\") + \"\\n\") } else { println(\"Current data: null\") } } En aquest exemple tenim el tractament de possibles errors, com que no s'accedeix al document, o aquest \u00e9s nul. Observeu com la primera lectura tamb\u00e9 la fa, del que hi haja guardat en un principi. En la imatge es mostra el moment d'afegir un segon missatge: Guardar documents Ja hav\u00edem comentat en la pregunta 4.1 que per l'estructura de les dades a la qual ens convida Cloud Firestore , en compte de guardar els missatges (i l'usuari) en una llista, ho far\u00edem en documents dins d'una subcol\u00b7lecci\u00f3. Per tant ens \u00e9s necess\u00e0ria l'operaci\u00f3 d'afegir un document a una col\u00b7lecci\u00f3. Aix\u00f2 en un principi ho aconseguir\u00edem amb el m\u00e8tode set() sobre un document nou de la col\u00b7lecci\u00f3: database.collection(\"nomCol\").document(\"nomDoc\").set(dades) per\u00f2 aix\u00f2 ens obligaria a posar un nom a cada document. Ja hav\u00edem vist que Cloud Firestore era capa\u00e7 de generar un nom de document que no es puga repetir. Des de Kotlin s'aconsegueix amb el m\u00e8tode add() : database.collection(\"nomCol\").add(dades) per\u00f2 que en el nostre cas, per ser una subcol\u00b7lecci\u00f3 \u00e9s un poc m\u00e9s llarg database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").add(dades) L'estructura de les dades la podem fer amb un Map , i posar-li en el nostre cas l'usuari i el missatge. D'aquesta manera ens quedaria ara el procediment en apretar el bot\u00f3 d'enviar el missatge , on a banda del que ten\u00edem abans per a modificar ultimMissatge i ultimUsuari , ara afegirem el document nou.`` // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) val dades2 = HashMap<String, Any>() dades2.put(\"nom\", usuari.getText()) dades2.put(\"contingut\", missatge.getText()) database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").add(dades2) } I aquest \u00e9s el resultat Per cert, un detall que haurem de tenir en compte m\u00e9s avant: com que el n\u00famero de document \u00e9s aleoatori, no t\u00e9 per qu\u00e8 ser l'\u00faltim. Ho haurem de tenir en compte quan vulguem traure els missatges per ordre cronol\u00f2gic. Per\u00f2 s\u00ed que podem veure com el contingut del nou document \u00e9s el que vol\u00edem: Recuperar documents modificats Ja nom\u00e9s ens queda detectar els canvis en els documents de la col\u00b7lecci\u00f3, per a afegir a l'\u00e0rea central els documents afegits. Tamb\u00e9 \u00e9s un addSnapshotListener() , per\u00f2 ara l'apliquem a una col\u00b7lecci\u00f3 (no a un document). El resultat \u00e9s que d'una forma molt c\u00f2moda podrem detectar els documents afegits, els modificats i fins i tot els esborrats. En el nostre exemple nom\u00e9s ens interessa el cas de document afegit , que ser\u00e0 un nou missatge en el xat, i el que farem ser\u00e0 afegir a area (el JTextArea on visualitzem tota a conversa). Per tant ens sobrar\u00e0 la l\u00ednia area.append(...) que estar\u00e0 al voltant de la l\u00ednia 106, en la qual afeg\u00edem a area depenent del canvi en ultimMissatge Ac\u00ed tenim el fragment de programa que ens ho permetr\u00e0. Hem deixat els casos de document modificat i document esborrat per a una millor documentaci\u00f3, encara que en el nostre exemple no ho utilitzem. // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").addSnapshotListener { snapshots, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } for (dc in snapshots!!.getDocumentChanges()) { when (dc.getType()) { DocumentChange.Type.ADDED -> area.append(dc.getDocument().getString(\"nom\") + \": \" + dc.getDocument().getString(\"contingut\") + \"\\n\") DocumentChange.Type.MODIFIED -> println(\"Missatge modificat: \" + dc.getDocument().getData()); DocumentChange.Type.REMOVED -> println(\"Missatge esborrat: \" + dc.getDocument().getData()); } } } I en aquesta imatge es veu com en un principi es veuen els 3 documents que ja existien (2 creats en la pregunta 4.1, i 1 immediatament abans). Tamb\u00e9 s'afegeix un altre missatge per veure que es visualitza perfectament \u00c9s de destacar que ara la c\u00f2pia de les dades, el snapshot, \u00e9s en realitat un QuerySnapshot . I \u00e9s que nosaltres no hem fet cap consulta sobre els documents de la col\u00b7lecci\u00f3, per\u00f2 \u00e9s possible fer-la. Per exemple es podria seleccionar per mig d'una query tots els documents en qu\u00e8 l'usuari \u00e9s un determinat. Aleshores detectar\u00edem els documents afegits, modificats o esborrats d'aquest usuari. Ho far\u00edem en el moment de declarar el addSnapshotListener() : database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").whereEqualTo(\"usuari\",\"Usuari2\").addSnapshotListener { O tamb\u00e9 podr\u00edem ordenar els documents per algun camp. A\u00e7\u00f2 en realitat \u00e9s necessari per a poder ordenar els missatges, ja que el nom del document auto- generat per Cloud Firestore no \u00e9s consecutiu, sin\u00f3 aleatori , i per tant com ja hem vist un document nou pot tenir un nom anterior a alguns dels existents. Ho arreglarem f\u00e0cilment posant un camp m\u00e9s amb la data i ordenant per aquest camp amb orderBy() (que aniria en el lloc del whereEqualTo() de la sent\u00e8ncia anterior). 4.4.2.3 CF-IntelliJ: Tot l'exemple Aquest \u00e9s el programa, que recordeu que li hav\u00edem posat el nom de Exemple_8_4_2_FirebaseCF_CrearXatCloud.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import javax.swing.JPanel import javax.swing.JComboBox import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.auth.oauth2.GoogleCredentials import com.google.cloud.firestore.DocumentReference import com.google.cloud.firestore.Firestore import com.google.firebase.FirebaseApp import com.google.firebase.FirebaseOptions import com.google.firebase.cloud.FirestoreClient import com.google.cloud.firestore.ListenerRegistration import java.text.SimpleDateFormat import java.util.Date class CrearXatCloud : JFrame() { val etUsuari = JLabel(\"Nom Usuari:\") val usuari = JTextField(25) val etUltimMissatge = JLabel(\"\u00daltim missatge: \") val ultimMissatge = JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell11 = JPanel(FlowLayout()) panell11.add(etUsuari) panell11.add(usuari) val panell12 = JPanel(FlowLayout()) panell12.add(etUltimMissatge) panell12.add(ultimMissatge) val panell1 = JPanel(GridLayout(2, 1)) panell1.add(panell11) panell1.add(panell12) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener { enviar() } val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat val database = FirestoreClient.getFirestore() val docRef = database.collection(\"Xats\").document(\"XatProva\") val future = docRef.get() val nomXat = future.get().getString(\"nomXat\") this.setTitle(nomXat) // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge DocumentSnapshot FirestoreException docRef.addSnapshotListener { snapshot, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } if (snapshot != null && snapshot.exists()) { ultimMissatge.setText(snapshot.getString(\"ultimMissatge\")) //area.append(snapshot.getString(\"ultimUsuari\") + \": \" + snapshot.getString(\"ultimMissatge\") + \"\\n\") } else { println(\"Current data: null\") } } // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").addSnapshotListener { snapshots, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } for (dc in snapshots!!.getDocumentChanges()) { when (dc.getType()) { DocumentChange.Type.ADDED -> area.append(dc.getDocument().getString(\"nom\") + \": \" + dc.getDocument().getString(\"contingut\") + \"\\n\") DocumentChange.Type.MODIFIED -> println(\"Missatge modificat: \" + dc.getDocument().getData()); DocumentChange.Type.REMOVED -> println(\"Missatge esborrat: \" + dc.getDocument().getData()); } } } } // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) val dades2 = HashMap<String, Any>() dades2.put(\"nom\", usuari.getText()) dades2.put(\"contingut\", missatge.getText()) database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").add(dades2) } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXatCloud().isVisible = true } } 4.4.2.4 CF-IntelliJ: Exemple ampliat Anem a ampliar l'exemple anterior, fent algunes modificacions i millores: Tindrem la classe Missatge amb les propietat nom i contingut (expressament diferents dels noms utilitzats en l'exemple anterior per poder comprovar que aquestes modificacions funcionen i milloren l'exemple). Posarem tamb\u00e9 la data (com un timestamp de Firebase que es correspon amb un Date de Java i Kotlin) per a poder ordenar els missatges cronol\u00f2gicament Llevem les coses que no s'utilitzen estrictament en aquest exemple No definirem la refer\u00e8ncia a la Base de Dades en cada utilitzaci\u00f3. \u00danicament una vegada al principi, despr\u00e9s de la connexi\u00f3. Posem un JComboBox per a poder triar entre m\u00e9s d'un xat. Per a no modificar les coses ja fetes, posarem la creaci\u00f3 dels listeners en un m\u00e8tode anomenat inicialitzar() , ja que ara els listeners dependran del xat triat. I haurem d'anar amb compte tamb\u00e9 de parar els listeners, ja creats. \u00c9s a dir, si primer triem un xat, tindrem els listeners que apunten a ell. Si despr\u00e9s triem un altre xat i creem els listeners una altra vegada per a que apunten al lloc correcte, els tindrem per duplicat. Haur\u00edem de parar els primers listeners Aquesta \u00e9s la classe Missatge class Missatge(var nom: String, var data: Date, var contingut: String) Aquest \u00e9s el programa. Per comoditat hem posat la classe Missatge dins. Si l'heu definida en un fitxer independent, haureu d'esborrar la definici\u00f3 en aquest programa. No es visualitzaran els missatge que no tinguen la data incorporada. Guardeu-lo amb el nom Exemple_8_4_2 _FirebaseCF_XatCloud_Millorat.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import javax.swing.JPanel import javax.swing.JComboBox import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.auth.oauth2.GoogleCredentials import com.google.cloud.firestore.DocumentReference import com.google.cloud.firestore.Firestore import com.google.firebase.FirebaseApp import com.google.firebase.FirebaseOptions import com.google.firebase.cloud.FirestoreClient import com.google.cloud.firestore.ListenerRegistration import java.text.SimpleDateFormat import java.util.Date class Missatge(var nom: String, var data: Date, var contingut: String) class XatCloudMillorat : JFrame() { val etComboXats = JLabel(\"Llista de tots els xats disponibles:\") val comboXats = JComboBox<String>() val etUsuari = JLabel(\"Nom Usuari:\") val usuari = JTextField(25) val etUltimMissatge = JLabel(\"\u00daltim missatge: \") val ultimMissatge = JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) var database: Firestore? = null var docRef: DocumentReference? = null var listenerUltimMissatge: ListenerRegistration? = null var listenerMissatges: ListenerRegistration? = null // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 550, 400) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell10 = JPanel(FlowLayout()) panell10.add(etComboXats) panell10.add(comboXats) val panell11 = JPanel(FlowLayout()) panell11.add(etUsuari) panell11.add(usuari) val panell12 = JPanel(FlowLayout()) panell12.add(etUltimMissatge) panell12.add(ultimMissatge) val panell1 = JPanel(GridLayout(3, 1)) panell1.add(panell10) panell1.add(panell11) panell1.add(panell12) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) comboXats.addActionListener() { inicialitzarXat() } enviar.addActionListener { enviar() } val serviceAccount = FileInputStream(\"acces-a-dades-6e5a6-firebase-adminsdk-ei7uc-fcf7da56aa.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) database = FirestoreClient.getFirestore() // Exemple de llegir tots els documents d'una col\u00b7lecci\u00f3 // Per a triar el xat val documents = database?.collection(\"Xats\")?.get()?.get()?.getDocuments() for (document in documents!!) { comboXats.addItem(document.getId()) } comboXats.setSelectedIndex(0) } fun inicialitzarXat() { docRef = database?.collection(\"Xats\")?.document(comboXats.getSelectedItem().toString()) area.setText(\"\") // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat val nomXat = docRef?.get()?.get()?.getString(\"nomXat\") this.setTitle(nomXat) // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge // Si estava en marxa, el parem abans de tornar-lo a llan\u00e7ar if (listenerUltimMissatge != null) listenerUltimMissatge!!.remove() listenerUltimMissatge = docRef?.addSnapshotListener { snapshot, e -> ultimMissatge.setText(snapshot?.getString(\"ultimMissatge\")) } // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges // Si estava en marxa, el parem abans de tornar-lo a llan\u00e7ar if (listenerMissatges != null) listenerMissatges!!.remove() listenerMissatges = docRef?.collection(\"missatges\")?.orderBy(\"data\")?.addSnapshotListener { snapshots, e -> for (dc in snapshots!!.getDocumentChanges()) { val dData = dc.getDocument().getDate(\"data\") val d = SimpleDateFormat(\"dd-MM-yyyy HH:mm\").format(dData) area.append( dc.getDocument().getString(\"nom\") + \" (\" + d + \"): \" + dc.getDocument().getString(\"contingut\") + \"\\n\" ) } } } // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXat = database.collection(\"Xats\").document(comboXats.getSelectedItem().toString()) val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXat.update(dades) val dades2 = HashMap<String, Any>() dades2.put(\"nom\", usuari.getText()) dades2.put(\"contingut\", missatge.getText()) val m = Missatge(usuari.getText(), Date(), missatge.getText()) docXat.collection(\"missatges\").add(m) } } fun main(args: Array<String>) { EventQueue.invokeLater { XatCloudMillorat().isVisible = true } } I aquest \u00e9s un exemple d'utilitzaci\u00f3. Es pot veure el JComboBox per a triar els diferents xats Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.4. - Cloud Firestore"},{"location":"AD_Firebase/4__cloud_firestore_cf/#44-cloud-firestore-cf","text":"Cloud Firestore \u00e9s l'evoluci\u00f3 de Realtime Database, on podrem guardar m\u00e9s d'un document. Els documents aniran organitzats en col\u00b7leccions. Ja podem parlar d'una vertadera Base de Dades documental. Google recomana la utilitzaci\u00f3 de Cloud Firestore en compte de Realtime Database. Potser fins i tot en un futur deixen de proveir aquesta \u00faltima. Per\u00f2 no seria cap problema perqu\u00e8 tot el que podem guardar en Realtime Database ho podrem guardar en Cloud Firestore, sense que se'ns complique l'organitzaci\u00f3 de les dades. I l'acc\u00e9s \u00e9s igual de f\u00e0cil. De vegades Firebase l'anomena Firestore Database o Cloud Firestore","title":"4.4 - Cloud Firestore (CF)"},{"location":"AD_Firebase/4__cloud_firestore_cf/#441-cf-utilitzacio-des-de-lentorn-de-firebase","text":"Amb el Cloud Firestore ja podrem guardar m\u00e9s d'un document, i aniran agrupats en col\u00b7leccions de documents. En el seg\u00fcent v\u00eddeo anem a insistir en aquest aspecte dels documents, ja que \u00e9s el m\u00e9s noved\u00f3s. Hem de fer la consideraci\u00f3 de que encara que treballem sobre la mateixa Base de Dades de Firebase, des de Cloud Firestore no podrem accedir a les dades de Realtime Database, i a l'inrev\u00e9s . Aquesta \u00e9s l'estructura de dades que ens hem guardat en l'exemple: Observeu tamb\u00e9 que dins d'un document d'una col\u00b7lecci\u00f3 es pot comen\u00e7ar una col\u00b7lecci\u00f3 i dins d'ella crear documents, etc. De manera que ho podem fer recursiu, i s'enriqueixen molt les possibilitats de disseny de la nostra Base de Dades. Anem a aprofundir en aquesta possibilitat de les subcol\u00b7leccions per a redissenyar les dades del nostre exemple del xat. Subcol\u00b7leccions Com es veia en l'\u00faltima imatge, es poden crear subcol\u00b7leccions en un document, i aquestes col\u00b7leccions contenir a la seua vegada tots els documents que calga. Aleshores ens redissenyarem el xat constru\u00eft en la part de Realtime Database . En aquell moment vam posar tots els missatges del xat en un llista. Ens anava molt b\u00e9, perqu\u00e8 despr\u00e9s pos\u00e0vem un listener sobre la clau del xat que detectava tots els elements nous: el addChildEventListener() . Tanmateix en el Cloud Firestore no tindrem el listener anterior. El que s\u00ed que disposarem \u00e9s d'un listener que detecte els nous documents sobre una col\u00b7lecci\u00f3. Aleshores anem a muntar cada missatge del xat com un nou document, que de moment nom\u00e9s tindr\u00e0 nom d'usuari i contingut de missatge. Per tant, despr\u00e9s de l'anterior tenim una col\u00b7lecci\u00f3 anomenada Xats , dins de la qual hi ha un document anomenat XatProva , dins del qual hi ha un camp anomenat nomXat i una col\u00b7lecci\u00f3 anomenada missatges , dins del qual hi ha dos documents, un d'ells amb nom 0 i un altre amb nom generat per Cloud Firestore","title":"4.4.1 CF: Utilitzaci\u00f3 des de l'entorn de Firebase"},{"location":"AD_Firebase/4__cloud_firestore_cf/#442-cf-utilitzacio-des-de-intellij","text":"Exemple Practicarem tot el que ve a continuaci\u00f3 sobre un programa gr\u00e0fic. Aquest \u00e9s el seu esquelet. Guardeu-lo en un fitxer anomenat Exemple_8_4_1_FirebaseCF_CrearXatCloud .kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import javax.swing.JPanel import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.auth.oauth2.GoogleCredentials import com.google.cloud.firestore.DocumentChange import com.google.firebase.FirebaseApp import com.google.firebase.FirebaseOptions import com.google.firebase.cloud.FirestoreClient class CrearXat : JFrame() { val etUsuari = JLabel(\"Nom Usuari:\") val usuari = JTextField(25) val etUltimMissatge = JLabel(\"\u00daltim missatge: \") val ultimMissatge = JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell11 = JPanel(FlowLayout()) panell11.add(etUsuari) panell11.add(usuari) val panell12 = JPanel(FlowLayout()) panell12.add(etUltimMissatge) panell12.add(ultimMissatge) val panell1 = JPanel(GridLayout(2, 1)) panell1.add(panell11) panell1.add(panell12) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener { enviar() } val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge DocumentSnapshot FirestoreException // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges } // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXat().isVisible = true } } I aquest \u00e9s el seu aspecte:","title":"4.4.2 CF: Utilitzaci\u00f3 des de IntelliJ"},{"location":"AD_Firebase/4__cloud_firestore_cf/#4421-cf-intellij-connexio-des-de-kotlin","text":"Configuraci\u00f3 Ara ser\u00e0 lleugerament m\u00e9s que en el cas de Realtime Database vist en el punt 4.3.2.1 ., ja que no caldr\u00e0 especificar la URL de la Base de Dades, amb la refer\u00e8ncia al fitxer json ser\u00e0 suficient. Recordeu que ens vam baixar un fitxer json amb la clau privada que vam guardar a l'arrel del projecte (i del qual \u00e9s molt convenient guardar c\u00f2pia). Despr\u00e9s, com deia l'exemple, col\u00b7loquem el seg\u00fcent per a un acc\u00e9s correcte, on no posem el .setDatebaseURL() : val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.Builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) No us oblideu de substituir el nom del fitxer json . Refer\u00e8ncia a la Base de Dades i a les dades concretes a les quals volem accedir Ara la refer\u00e8ncia a la Base de Dades de Cloud Firestore canviar\u00e0: val database = FirestoreClient.getFirestore() Com que la informaci\u00f3 est\u00e0 organitzada en col\u00b7leccions i dins d'ella en documents, podrem accedir primer a les col\u00b7leccions i dins d'elles a documents. A continuaci\u00f3 teniu la refer\u00e8ncia pas a pas: val col = database.collection(\"Xats\") val docXatProva = col.document(\"XatProva\") Encara que evidentment ho pod\u00edem haver fet en una \u00fanica l\u00ednia: val docXatProva = database.collection(\"Xats\").document(\"XatProva\") No ens plantejarem posar refer\u00e8ncies a elements de dins d'un document, sin\u00f3 que de moment accedirem a tot el conjunt del document. Recordeu que Realtime Database , com era un \u00fanic document JSON, all\u00e0 anava tot i obligat\u00f2riament hav\u00edem de poder tenir una refer\u00e8ncia a un \u00fanic element. Com en Cloud Firestore ho podem organitzar en col\u00b7leccions i documents, cadascun d'ells el podem dissenyar millor i que continga \u00fanicament les dades estrictes. Aleshores ens anir\u00e0 b\u00e9 accedir a tot el document.","title":"4.4.2.1 CF-IntelliJ: Connexi\u00f3 des de Kotlin"},{"location":"AD_Firebase/4__cloud_firestore_cf/#4422-cf-intellij-acces-a-les-dades","text":"Guardar dades Com acabem de comentar, accedim a tot un document dins d'una col\u00b7lecci\u00f3. Per a guardar dades, ens podem plantejar 3 operacions d'escriptura sobre el document: Sobreescriure'l tot: ho farem amb el m\u00e8tode set() Esborrar-lo tot: amb el m\u00e8tode delete() Modificar-lo: amb el m\u00e8tode update() Excepte per esborrar, per a les altres operacions ens fa falta saber l'estructura del document. Per aix\u00f2 tant m\u00e8tode set() com el m\u00e8tode update() accepten com a par\u00e0metre no una \u00fanica dada, sin\u00f3 una estructura que puga arribar a reflectir el document. Acceptaran com a par\u00e0metre un Map , on podrem col\u00b7locar les claus i els valors de tots els membres del document. Cada valor pot ser dels tipus que vam practicar en el punt anterior: string, number, boolean, array, map, ... La manera de col\u00b7locar un element en una estructura Map <> \u00e9s amb el m\u00e8tode put() , que acceptar\u00e0 dos par\u00e0metres: la clau i el valor. En el seg\u00fcent exemple. quan s'apreta el bot\u00f3 d'enviar (baix a la dreta) es guardar\u00e0 el contingut del quadre de text usuari que est\u00e0 dalt i el de missatge que est\u00e0 baix. Per\u00f2 observeu que estem utilitzant el m\u00e8tode set() i per tant matxacar\u00edem el que ja ten\u00edem constru\u00eft (el nom del xat i potser tamb\u00e9 la subcol\u00b7lecci\u00f3 de missatges). Per tant US ACONSELLE QUE NO EXECUTEU EL QUE VE A CONTINUACI\u00d3 // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.set(dades) } Aquest seria el resultat, creant-se el document amb les 2 clau-valor, i havent matxacat el que hi havia, que era el nom del xat. Afortunadament no s'ha carregat la col\u00b7lecci\u00f3 missatges, per\u00f2 no ens podem fiar En realitat els m\u00e8todes set() , delete() i update() tornen un valor, que \u00e9s un ApiFuture<WriteResult> , que permet averiguar com ha anat l'actualitzaci\u00f3 de les dades. D'aquest ApiFuture<> podem obtenir el moment en qu\u00e8 s'ha confirmat l'actualitzaci\u00f3, i es podria aprofitar per a tractar-lo per si d\u00f3na algun error. Ampliem l'exemple anterior en qu\u00e8 utilitz\u00e0vem el set() per a comprovar el que comentem, senzillament mostrant el moment en qu\u00e8 s'ha actualitzat, i poder comprovar que \u00e9s un ApiFuture <WriteResult> . US ACONSELLE QUE NO EXECUTEU EL QUE VE A CONTINUACI\u00d3 // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) val result = docXatProva.set(dades) println(\"Data d'actualitzaci\u00f3: \" + result.get().getUpdateTime()) } Si veiem la consola d'eixida d' IntelliJ veurem despr\u00e9s dels warnings de sempre, al final en negre com ha impr\u00e9s el moment de la confirmaci\u00f3. En els exemples anterior, en cas d'haver-se executat hauran matxacat el document XatProva i aix\u00f2 era per haver utilitzat el m\u00e8tode set() . Anem a canviar-lo pel m\u00e8tode update() , en qu\u00e8 senzillament afegir\u00e0 (i si \u00e9s necessari matxacar\u00e0) les dades que proporcionem, per\u00f2 mantindr\u00e0 les altres. AQUEST EXEMPLE S\u00cd QUE EL PODEU FER // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) } conservarem tant el camp nomXat com la col\u00b7lecci\u00f3 missatges Recuperar dades Com en el cas del Realtime Database, ens plantegem dos casos: Una \u00fanica lectura Un listener que es quede escoltant per si hi ha canvis Com comprovarem, queda m\u00e9s senzilla la lectura \u00fanica en el cas de Cloud Firestore. Lectura \u00fanica Per a fer una lectura \u00fanica utilitzarem el m\u00e8tode get() sobre una refer\u00e8ncia al document que volem llegir. El resultat ens ve en un ApiFuture , que com es veu \u00e9s una c\u00f2pia de les dades en una interface ApiFutute , indicant que la tindrem disponible en un futur. Sobre aquesta farem get() per a obtenir aquesta c\u00f2pia (ser\u00e0 un objecte). I sobre ella podrem fer: getData() per a obtenir tot el document en un Map getId() per a obtenir el nom del document get( nomClau ) per a obtenir directament el valor d'una clau del document getString( nomClau ) per a obtenir el valor de la clau en forma de string getDouble( nomClau ) per a obtenir el valor de la clau en forma de double getDate( nomClau ) per a obtenir el valor de la clau en forma de date ... L'exemple d'\u00fanica lectura el farem per a posar el t\u00edtol de l'aplicaci\u00f3, com en l'exemple del Realtime Database. Pr\u00e8viament, des de la consola de Firebase ja hav\u00edem creat la parella clau-valor: nomXat: Xat Cloud Firestore , dins del document XatProva . Si pels exemples anteriors (els que havia marcat en roig que no us aconsellava fer) heu perdut aquesta parella, \u00e9s el moment de crear-la de nou: Ara s\u00ed que haurem d'anar amb compte en el moment de guardar les dades. Si utilitzem el m\u00e8tode set() matxacarem el document anterior (amb el nom del xat). Per tant, a partir d'ara ens convindr\u00e0 utilitzar el m\u00e8tode update() . Ho tornarem a especificar en el moment de fer aquesta escriptura. I aquestes seran les sent\u00e8ncies per a posar el t\u00edtol de l'aplicaci\u00f3: // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat val database = FirestoreClient.getFirestore() val docRef = database.collection(\"Xats\").document(\"XatProva\") val future = docRef.get() val nomXat = future.get().getString(\"nomXat\") this.setTitle(nomXat) I ac\u00ed tenim el resultat, on es veu el t\u00edtol agafat de Cloud Firestore: Listener que es queda escoltant: addSnapshotListener() De forma paral\u00b7lela al Realtime Database, si volem rebre una notificaci\u00f3 de quan hi haja un canvi en el document que ens interessa, sobre una refer\u00e8ncia a aquest document ens muntarem un listener, en aquest cas amb el m\u00e8tode addSnapshotListener() . Al m\u00e8tode onEvent() que s'ha de sobreescriure arribar\u00e0 un par\u00e0metre de tipus DocumentSnapshot , que ser\u00e0 una c\u00f2pia del document. Com en el cas anterior podrem fer sobre ell un getData() per a obtenir tot el document, getString( nomClau ) per a obtenir el valor de la clau com un string, etc. En el nostre exemple, de moment l'utilitzem tant per a posar l'\u00faltim missatge com per a anar omplint l'\u00e0rea central amb el xat. Per\u00f2 com hav\u00edem comentat abans, hem de cuidar de no matxacar tot el document per a no perdre el t\u00edtol del xat. Per tant, l'acci\u00f3 que farem en apretar el bot\u00f3 per a enviar el missatge no ser\u00e0 set() sin\u00f3 update(). Per si de cas hav\u00edeu fet els exemples que us havia aconsellat que no f\u00e9reu, ac\u00ed teniu una altra vegada el codi correcte: // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) } I ara s\u00ed el addSnapshotListener() : // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge DocumentSnapshot FirestoreException docRef.addSnapshotListener { snapshot, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } if (snapshot != null && snapshot.exists()) { ultimMissatge.setText(snapshot.getString(\"ultimMissatge\")) area.append(snapshot.getString(\"ultimUsuari\") + \": \" + snapshot.getString(\"ultimMissatge\") + \"\\n\") } else { println(\"Current data: null\") } } En aquest exemple tenim el tractament de possibles errors, com que no s'accedeix al document, o aquest \u00e9s nul. Observeu com la primera lectura tamb\u00e9 la fa, del que hi haja guardat en un principi. En la imatge es mostra el moment d'afegir un segon missatge: Guardar documents Ja hav\u00edem comentat en la pregunta 4.1 que per l'estructura de les dades a la qual ens convida Cloud Firestore , en compte de guardar els missatges (i l'usuari) en una llista, ho far\u00edem en documents dins d'una subcol\u00b7lecci\u00f3. Per tant ens \u00e9s necess\u00e0ria l'operaci\u00f3 d'afegir un document a una col\u00b7lecci\u00f3. Aix\u00f2 en un principi ho aconseguir\u00edem amb el m\u00e8tode set() sobre un document nou de la col\u00b7lecci\u00f3: database.collection(\"nomCol\").document(\"nomDoc\").set(dades) per\u00f2 aix\u00f2 ens obligaria a posar un nom a cada document. Ja hav\u00edem vist que Cloud Firestore era capa\u00e7 de generar un nom de document que no es puga repetir. Des de Kotlin s'aconsegueix amb el m\u00e8tode add() : database.collection(\"nomCol\").add(dades) per\u00f2 que en el nostre cas, per ser una subcol\u00b7lecci\u00f3 \u00e9s un poc m\u00e9s llarg database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").add(dades) L'estructura de les dades la podem fer amb un Map , i posar-li en el nostre cas l'usuari i el missatge. D'aquesta manera ens quedaria ara el procediment en apretar el bot\u00f3 d'enviar el missatge , on a banda del que ten\u00edem abans per a modificar ultimMissatge i ultimUsuari , ara afegirem el document nou.`` // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) val dades2 = HashMap<String, Any>() dades2.put(\"nom\", usuari.getText()) dades2.put(\"contingut\", missatge.getText()) database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").add(dades2) } I aquest \u00e9s el resultat Per cert, un detall que haurem de tenir en compte m\u00e9s avant: com que el n\u00famero de document \u00e9s aleoatori, no t\u00e9 per qu\u00e8 ser l'\u00faltim. Ho haurem de tenir en compte quan vulguem traure els missatges per ordre cronol\u00f2gic. Per\u00f2 s\u00ed que podem veure com el contingut del nou document \u00e9s el que vol\u00edem: Recuperar documents modificats Ja nom\u00e9s ens queda detectar els canvis en els documents de la col\u00b7lecci\u00f3, per a afegir a l'\u00e0rea central els documents afegits. Tamb\u00e9 \u00e9s un addSnapshotListener() , per\u00f2 ara l'apliquem a una col\u00b7lecci\u00f3 (no a un document). El resultat \u00e9s que d'una forma molt c\u00f2moda podrem detectar els documents afegits, els modificats i fins i tot els esborrats. En el nostre exemple nom\u00e9s ens interessa el cas de document afegit , que ser\u00e0 un nou missatge en el xat, i el que farem ser\u00e0 afegir a area (el JTextArea on visualitzem tota a conversa). Per tant ens sobrar\u00e0 la l\u00ednia area.append(...) que estar\u00e0 al voltant de la l\u00ednia 106, en la qual afeg\u00edem a area depenent del canvi en ultimMissatge Ac\u00ed tenim el fragment de programa que ens ho permetr\u00e0. Hem deixat els casos de document modificat i document esborrat per a una millor documentaci\u00f3, encara que en el nostre exemple no ho utilitzem. // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").addSnapshotListener { snapshots, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } for (dc in snapshots!!.getDocumentChanges()) { when (dc.getType()) { DocumentChange.Type.ADDED -> area.append(dc.getDocument().getString(\"nom\") + \": \" + dc.getDocument().getString(\"contingut\") + \"\\n\") DocumentChange.Type.MODIFIED -> println(\"Missatge modificat: \" + dc.getDocument().getData()); DocumentChange.Type.REMOVED -> println(\"Missatge esborrat: \" + dc.getDocument().getData()); } } } I en aquesta imatge es veu com en un principi es veuen els 3 documents que ja existien (2 creats en la pregunta 4.1, i 1 immediatament abans). Tamb\u00e9 s'afegeix un altre missatge per veure que es visualitza perfectament \u00c9s de destacar que ara la c\u00f2pia de les dades, el snapshot, \u00e9s en realitat un QuerySnapshot . I \u00e9s que nosaltres no hem fet cap consulta sobre els documents de la col\u00b7lecci\u00f3, per\u00f2 \u00e9s possible fer-la. Per exemple es podria seleccionar per mig d'una query tots els documents en qu\u00e8 l'usuari \u00e9s un determinat. Aleshores detectar\u00edem els documents afegits, modificats o esborrats d'aquest usuari. Ho far\u00edem en el moment de declarar el addSnapshotListener() : database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").whereEqualTo(\"usuari\",\"Usuari2\").addSnapshotListener { O tamb\u00e9 podr\u00edem ordenar els documents per algun camp. A\u00e7\u00f2 en realitat \u00e9s necessari per a poder ordenar els missatges, ja que el nom del document auto- generat per Cloud Firestore no \u00e9s consecutiu, sin\u00f3 aleatori , i per tant com ja hem vist un document nou pot tenir un nom anterior a alguns dels existents. Ho arreglarem f\u00e0cilment posant un camp m\u00e9s amb la data i ordenant per aquest camp amb orderBy() (que aniria en el lloc del whereEqualTo() de la sent\u00e8ncia anterior).","title":"4.4.2.2 CF-IntelliJ: Acc\u00e9s a les dades"},{"location":"AD_Firebase/4__cloud_firestore_cf/#4423-cf-intellij-tot-lexemple","text":"Aquest \u00e9s el programa, que recordeu que li hav\u00edem posat el nom de Exemple_8_4_2_FirebaseCF_CrearXatCloud.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import javax.swing.JPanel import javax.swing.JComboBox import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.auth.oauth2.GoogleCredentials import com.google.cloud.firestore.DocumentReference import com.google.cloud.firestore.Firestore import com.google.firebase.FirebaseApp import com.google.firebase.FirebaseOptions import com.google.firebase.cloud.FirestoreClient import com.google.cloud.firestore.ListenerRegistration import java.text.SimpleDateFormat import java.util.Date class CrearXatCloud : JFrame() { val etUsuari = JLabel(\"Nom Usuari:\") val usuari = JTextField(25) val etUltimMissatge = JLabel(\"\u00daltim missatge: \") val ultimMissatge = JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 300) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell11 = JPanel(FlowLayout()) panell11.add(etUsuari) panell11.add(usuari) val panell12 = JPanel(FlowLayout()) panell12.add(etUltimMissatge) panell12.add(ultimMissatge) val panell1 = JPanel(GridLayout(2, 1)) panell1.add(panell11) panell1.add(panell12) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) enviar.addActionListener { enviar() } val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat val database = FirestoreClient.getFirestore() val docRef = database.collection(\"Xats\").document(\"XatProva\") val future = docRef.get() val nomXat = future.get().getString(\"nomXat\") this.setTitle(nomXat) // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge DocumentSnapshot FirestoreException docRef.addSnapshotListener { snapshot, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } if (snapshot != null && snapshot.exists()) { ultimMissatge.setText(snapshot.getString(\"ultimMissatge\")) //area.append(snapshot.getString(\"ultimUsuari\") + \": \" + snapshot.getString(\"ultimMissatge\") + \"\\n\") } else { println(\"Current data: null\") } } // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").addSnapshotListener { snapshots, e -> if (e != null) { System.err.println(\"Listen failed: \" + e) return@addSnapshotListener } for (dc in snapshots!!.getDocumentChanges()) { when (dc.getType()) { DocumentChange.Type.ADDED -> area.append(dc.getDocument().getString(\"nom\") + \": \" + dc.getDocument().getString(\"contingut\") + \"\\n\") DocumentChange.Type.MODIFIED -> println(\"Missatge modificat: \" + dc.getDocument().getData()); DocumentChange.Type.REMOVED -> println(\"Missatge esborrat: \" + dc.getDocument().getData()); } } } } // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXatProva = database.collection(\"Xats\").document(\"XatProva\") val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXatProva.update(dades) val dades2 = HashMap<String, Any>() dades2.put(\"nom\", usuari.getText()) dades2.put(\"contingut\", missatge.getText()) database.collection(\"Xats\").document(\"XatProva\").collection(\"missatges\").add(dades2) } } fun main(args: Array<String>) { EventQueue.invokeLater { CrearXatCloud().isVisible = true } }","title":"4.4.2.3 CF-IntelliJ: Tot l'exemple"},{"location":"AD_Firebase/4__cloud_firestore_cf/#4424-cf-intellij-exemple-ampliat","text":"Anem a ampliar l'exemple anterior, fent algunes modificacions i millores: Tindrem la classe Missatge amb les propietat nom i contingut (expressament diferents dels noms utilitzats en l'exemple anterior per poder comprovar que aquestes modificacions funcionen i milloren l'exemple). Posarem tamb\u00e9 la data (com un timestamp de Firebase que es correspon amb un Date de Java i Kotlin) per a poder ordenar els missatges cronol\u00f2gicament Llevem les coses que no s'utilitzen estrictament en aquest exemple No definirem la refer\u00e8ncia a la Base de Dades en cada utilitzaci\u00f3. \u00danicament una vegada al principi, despr\u00e9s de la connexi\u00f3. Posem un JComboBox per a poder triar entre m\u00e9s d'un xat. Per a no modificar les coses ja fetes, posarem la creaci\u00f3 dels listeners en un m\u00e8tode anomenat inicialitzar() , ja que ara els listeners dependran del xat triat. I haurem d'anar amb compte tamb\u00e9 de parar els listeners, ja creats. \u00c9s a dir, si primer triem un xat, tindrem els listeners que apunten a ell. Si despr\u00e9s triem un altre xat i creem els listeners una altra vegada per a que apunten al lloc correcte, els tindrem per duplicat. Haur\u00edem de parar els primers listeners Aquesta \u00e9s la classe Missatge class Missatge(var nom: String, var data: Date, var contingut: String) Aquest \u00e9s el programa. Per comoditat hem posat la classe Missatge dins. Si l'heu definida en un fitxer independent, haureu d'esborrar la definici\u00f3 en aquest programa. No es visualitzaran els missatge que no tinguen la data incorporada. Guardeu-lo amb el nom Exemple_8_4_2 _FirebaseCF_XatCloud_Millorat.kt : import java.awt.EventQueue import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextArea import javax.swing.JButton import javax.swing.JTextField import javax.swing.JPanel import javax.swing.JComboBox import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.auth.oauth2.GoogleCredentials import com.google.cloud.firestore.DocumentReference import com.google.cloud.firestore.Firestore import com.google.firebase.FirebaseApp import com.google.firebase.FirebaseOptions import com.google.firebase.cloud.FirestoreClient import com.google.cloud.firestore.ListenerRegistration import java.text.SimpleDateFormat import java.util.Date class Missatge(var nom: String, var data: Date, var contingut: String) class XatCloudMillorat : JFrame() { val etComboXats = JLabel(\"Llista de tots els xats disponibles:\") val comboXats = JComboBox<String>() val etUsuari = JLabel(\"Nom Usuari:\") val usuari = JTextField(25) val etUltimMissatge = JLabel(\"\u00daltim missatge: \") val ultimMissatge = JLabel() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() val etIntroduccioMissatge = JLabel(\"Introdueix missatge:\") val enviar = JButton(\"Enviar\") val missatge = JTextField(15) var database: Firestore? = null var docRef: DocumentReference? = null var listenerUltimMissatge: ListenerRegistration? = null var listenerMissatges: ListenerRegistration? = null // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 550, 400) setLayout(BorderLayout()) // contenidor per als elements //Hi haur\u00e0 t\u00edtol. Panell de dalt: \u00faltim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat val panell10 = JPanel(FlowLayout()) panell10.add(etComboXats) panell10.add(comboXats) val panell11 = JPanel(FlowLayout()) panell11.add(etUsuari) panell11.add(usuari) val panell12 = JPanel(FlowLayout()) panell12.add(etUltimMissatge) panell12.add(ultimMissatge) val panell1 = JPanel(GridLayout(3, 1)) panell1.add(panell10) panell1.add(panell11) panell1.add(panell12) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) val panell3 = JPanel(FlowLayout()) panell3.add(etIntroduccioMissatge) panell3.add(missatge) panell3.add(enviar) getContentPane().add(panell3, BorderLayout.SOUTH) setVisible(true) comboXats.addActionListener() { inicialitzarXat() } enviar.addActionListener { enviar() } val serviceAccount = FileInputStream(\"acces-a-dades-6e5a6-firebase-adminsdk-ei7uc-fcf7da56aa.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) database = FirestoreClient.getFirestore() // Exemple de llegir tots els documents d'una col\u00b7lecci\u00f3 // Per a triar el xat val documents = database?.collection(\"Xats\")?.get()?.get()?.getDocuments() for (document in documents!!) { comboXats.addItem(document.getId()) } comboXats.setSelectedIndex(0) } fun inicialitzarXat() { docRef = database?.collection(\"Xats\")?.document(comboXats.getSelectedItem().toString()) area.setText(\"\") // Exemple de lectura \u00fanica: senzillament sobre un ApiFuture i sobre ell get() // Per a posar el t\u00edtol. Sobre /Xats/XatProva/nomXat val nomXat = docRef?.get()?.get()?.getString(\"nomXat\") this.setTitle(nomXat) // Exemple de listener de lectura cont\u00ednua addSnapshotListener() // Per a posar l'\u00faltim missatge registrat. Sobre /Xats/XatProva/ultimUsuari i /Xats/XatProva/ultimMissatge // Si estava en marxa, el parem abans de tornar-lo a llan\u00e7ar if (listenerUltimMissatge != null) listenerUltimMissatge!!.remove() listenerUltimMissatge = docRef?.addSnapshotListener { snapshot, e -> ultimMissatge.setText(snapshot?.getString(\"ultimMissatge\")) } // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges // Si estava en marxa, el parem abans de tornar-lo a llan\u00e7ar if (listenerMissatges != null) listenerMissatges!!.remove() listenerMissatges = docRef?.collection(\"missatges\")?.orderBy(\"data\")?.addSnapshotListener { snapshots, e -> for (dc in snapshots!!.getDocumentChanges()) { val dData = dc.getDocument().getDate(\"data\") val d = SimpleDateFormat(\"dd-MM-yyyy HH:mm\").format(dData) area.append( dc.getDocument().getString(\"nom\") + \" (\" + d + \"): \" + dc.getDocument().getString(\"contingut\") + \"\\n\" ) } } } // Exemple de guardar dades en Cloud Firestore // Per a guardar dades. Sobre /Xats/XatProva i despr\u00e9s sobre /Xats/Xat1 fun enviar() { val database = FirestoreClient.getFirestore() val docXat = database.collection(\"Xats\").document(comboXats.getSelectedItem().toString()) val dades = HashMap<String, Any>() dades.put(\"ultimUsuari\", usuari.getText()) dades.put(\"ultimMissatge\", missatge.getText()) docXat.update(dades) val dades2 = HashMap<String, Any>() dades2.put(\"nom\", usuari.getText()) dades2.put(\"contingut\", missatge.getText()) val m = Missatge(usuari.getText(), Date(), missatge.getText()) docXat.collection(\"missatges\").add(m) } } fun main(args: Array<String>) { EventQueue.invokeLater { XatCloudMillorat().isVisible = true } } I aquest \u00e9s un exemple d'utilitzaci\u00f3. Es pot veure el JComboBox per a triar els diferents xats Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.4.2.4 CF-IntelliJ: Exemple ampliat"},{"location":"AD_Firebase/5__cloud_storage/","text":"4.5 - Cloud Storage Cloud Storage ens permet guardar fitxers c\u00f2modament: fotos, v\u00eddeos, audios, ... Combinat amb Reltime Database o Cloud Firestore ens permet guardar les nostres dedes de forma eficient, ja que podem guardar en les primeres les refer\u00e8ncies als fitxers que pugem al Storage. La utilitzaci\u00f3 d'estoratge no \u00e9s de gratis, per la qual cosa els exemples d'aquest apartat es faran sobre una base de dades externa (la mateixa que la de l'exercici 2) on s\u00ed que tindreu acc\u00e9s. Necessitareu el fitxer de connexi\u00f3 d'aquesta base de dades al que teniu com un recurs en l'aula virtual: xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json 4.5.1 CS: Utilitzaci\u00f3 des de l'entorn L'entorn que ens ofereix Firebase per a gestionar Cloud Storage \u00e9s molt senzill i no t\u00e9 cap secret, ja que ens permetr\u00e0 pujar els fitxers, organitzant-los en subdirectoris, i tamb\u00e9 esborrar-los. En principi no necessitem m\u00e9s. Si punxem en un fitxer podrem veure les seues caracter\u00edstiques, i si el seleccionem podrem esborrar-lo o obrir-lo en una altra finestra. Aquest entorn, de tan senzill, fins i tot es queda un poc curt, ja que no ens permetr\u00e0 canviar el nom d'un fitxer, o moure'l a una carpeta, ... Si vulgu\u00e9rem fer algun canvi d'aquestos, canviar el nom o canviar de carpeta, ho haur\u00edem de fer des d'un altre lloc, un altre navegador del Google Cloud Storage ( https://console.cloud.google.com/storage/browser ): on es pot observar com en els 3 puntets de la dreta d'un fitxer ens apareixen moltes opcions com copiar, menejar, renomenar, ... Per\u00f2 nosaltres en principi tindrem prou amb la primera consola. Anem alerta de col\u00b7locar les coses al lloc, i si no estan, esborrem i col\u00b7loquem al lloc correcte. Ja que estem en la consola, controlem els permisos ( Rules ) en la pestanya corresponent de la consola: En aquesta imatge s'aprecia que no hi haur\u00e0 perm\u00eds per a llegir ni escriure fora de la consola. Com que el que volem \u00e9s accedir des de les aplicacions d'IntelliJ i d'Android, substituirem el perm\u00eds per aquest: allow read, write: if request.time < timestamp.date(2025, 6, 14); amb una data en la qual no ens pillem els dits. Nota Observeu com tant en la consola senzilla com en la del browser de GoogleCloud, ens posa una adre\u00e7a, que en el meu cas \u00e9s: gs://xat-ad-9f901.appspot.com . Es tracta de l'adre\u00e7a del bucket (poal, contenidor) on estan col\u00b7locats els fitxers. Podem crear m\u00e9s buckets , per\u00f2 no ho complicarem. Haurem de tenir clara la refer\u00e8ncia a aquest bucket per defecte. 4.5.2 CS: Utilitzaci\u00f3 des de IntelliJ Exemple Practicarem tot el que ve a continuaci\u00f3 sobre un programa gr\u00e0fic. Ser\u00e0 molt m\u00e9s senzill que en els casos anteriors, ja que de moment nom\u00e9s volem un lloc on tenir el nom de la imatge que volem baixar, i un lloc on visualitzar la imatge Aquest \u00e9s el seu esquelet. Guardeu-lo en un fitxer anomenat Exemple_8_5_1_FirebaseCS_AgafarImatge.kt : import javax.swing.JFrame import java.awt.EventQueue import javax.swing.JTextField import javax.swing.JButton import javax.swing.JLabel import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.cloud.storage.Bucket import com.google.firebase.cloud.StorageClient import javax.imageio.ImageIO import java.nio.ByteBuffer import java.io.ByteArrayInputStream import javax.swing.ImageIcon class AgafarImatge_1 : JFrame() { val nomIm = JTextField(25) val boto = JButton(\"Agafar\") val foto = JLabel() var bucket: Bucket? = null init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 900, 600) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(nomIm) panell1.add(boto) getContentPane().add(panell1, BorderLayout.NORTH) getContentPane().add(foto, BorderLayout.CENTER) boto.addActionListener { agafar() } } fun agafar() { // Instruccions per agafar la imatge } } fun main(args: Array<String>) { EventQueue.invokeLater { AgafarImatge_1().isVisible = true } } 4.5.2.1 CS-IntelliJ: Connexi\u00f3 Configuraci\u00f3 No caldr\u00e0 fer refer\u00e8ncia a la URL de l'aplicaci\u00f3 Firebase, perqu\u00e8 quan especifiquem el bucket, li posarem l'adre\u00e7a i amb aix\u00f2 \u00e9s suficient. Recordeu que ens vam baixar un fitxer json amb la clau privada que vam guardar a l'arrel del projecte (i del qual \u00e9s molt convenient guardar c\u00f2pia). val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json\") val options = FirebaseOptions.Builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) Refer\u00e8ncia al bucket de Cloud Storage Ac\u00ed haurem de fer una refer\u00e8ncia expl\u00edcita al bucket que vam comentar en el punt anterior, mentre que en Android ens el podrem saltar, ja que la refer\u00e8ncia estar\u00e0 impl\u00edcitament. Ho farem a trav\u00e9s de StorageClient , mentre que en Android ser\u00e0 un altra classe.: bucket = StorageClient.getInstance().bucket(\"xat-ad-9f901.appspot.com\") Nota Podr\u00e9m haver-ho definit diferent, especificant el bucket en el moment de definir les opcions. Aleshores, en el moment de crear el bucket no caldria passar-li el par\u00e0metre. val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json\") val options = FirebaseOptions.Builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setStorageBucket(\"xat-ad-9f901.appspot.com\") .build() FirebaseApp.initializeApp(options) bucket StorageClient.getInstance().bucket() 4.5.2.2 CS-IntelliJ: Acc\u00e9s a les dades Farem acc\u00e9s als fitxers de Cloud Storage per a llegir-los, per a baixar-los. Mencionarem el fet de guardar fitxers, per\u00f2 no l'utilitzarem tant. Ho farem per mig del m\u00e8tode get() del bucket , al qual li passarem el nom del fitxer que volem llegir, i ens tornar\u00e0 un blob (de cloud storage) amb el seu contingut. val blob = bucket?.get(nomIm.getText()) Aquest blob podrem agafar-lo de dues maneres: Baixant-lo a un fitxer temporal amb el m\u00e8tode downloadTo() Agafant-lo directament en mem\u00f2ria a un ByteBuffer de grand\u00e0ria suficient Agafant-lo directament en mem\u00f2ria a un ByteArray amb el m\u00e8tode getContent() i aleshores no cal especificar cap grand\u00e0ria (potser siga el m\u00e9s c\u00f2mode) De la primera manera ho far\u00edem aix\u00ed, baixem el fitxer a un fitxer auxiliar, i des d'alli el carreguem // Primera manera de llegir, amb un fitxer auxiliar val f = File(\"auxiliar\") blob?.downloadTo(FileOutputStream(f)) val image = ImageIO.read(f) foto.setIcon(ImageIcon(image)) De la segona manera ens muntem un reader (de Cloud Storage) per poder carregar-ho en mem\u00f2ria a un ByteBuffer //Segona manera de llegir: muntant un reader per a carregar a un ByteBuffer val im = ByteBuffer.allocate(1024 * 1024) blob?.reader()?.read(im) val image = ImageIO.read(ByteArrayInputStream(im.array())) foto.setIcon(ImageIcon(image)) La tercera manera, segurament \u00e9s la m\u00e9s c\u00f2moda, amb el m\u00e8tode getContent() , que ens torna el ByteArray . P //Tercera manera de llegir: amb getContent per a carregar a un ByteArray val im = blob?.getContent() val image = ImageIO.read(im?.inputStream()) foto.setIcon(ImageIcon(image)) Qualsevol de les tres maneres ens hauria de funcionar b\u00e9, col\u00b7locant juntament amb la definici\u00f3 del blob en la funci\u00f3 que s'executa en apretar el bot\u00f3, agafar() . I aquest seria el resultat: Altres m\u00e8todes del bucket que ens poden interessar s\u00f3n: get() : agafa un fitxer, passant-li el nom i tornant un blob . \u00c9s el que hem utiitzat. create() : serveix per a pujar un fitxer al bucket; se li passen 3 par\u00e0metres, el nom que tindr\u00e0 el fitxer en el Clousd Storage, el contingut que se li pot passar en forma de ByteArray o de InputStream, i el tipus de fitxer (per exemple \"image/png\" ) list() : torna un conjunt de blobs en forma de Page . De cada element blob podrem baixar-nos el contingut a un fitxer auxiliar, a un ByteBuffer, agafar el seu nom, ... 4.5.2.3 CS-IntelliJ: Tot l'exemple Anem a ajuntar tot l'exemple que visualitza una imatge guardada en Cloud Storage, modificant-lo un poc: Ens guardarem els noms de les imatges en un JComboBox . I per a visualitzar la imatge, en compte d'un JLabel utilitzarem un JButton , aix\u00ed la imatge quedara centrada tan horitzontal com verticalment. Per a provar la pujada d'imatges, proposarem un segon nom a la imatge, i un bot\u00f3. Si s'apreta es guardar\u00e0 la imatge amb el nom proposat (o canviat), aprofitant l'extensi\u00f3 del nom per a posar el tipus d'imatge El guardarem amb un altre nom, en el fitxer Kotlin Exemple_8_5_2_FirebaseCS_AgafarImatge .kt import javax.swing.JFrame import java.awt.EventQueue import javax.swing.JComboBox import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.cloud.storage.Bucket import com.google.firebase.cloud.StorageClient import javax.imageio.ImageIO import java.nio.ByteBuffer import java.io.ByteArrayInputStream import javax.swing.ImageIcon import javax.swing.JButton class AgafarImatge_2 : JFrame() { val nomIm = JComboBox<String>() val nomIm2 = JTextField(15) val boto = JButton(\"Guardar c\u00f2pia\") val foto = JButton() var bucket: Bucket? = null var im = byteArrayOf() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 900, 600) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(nomIm) getContentPane().add(panell1, BorderLayout.NORTH) getContentPane().add(foto, BorderLayout.CENTER) val panell2 = JPanel(FlowLayout()) panell2.add(nomIm2) panell2.add(boto) contentPane.add(panell2,BorderLayout.SOUTH) val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) bucket = StorageClient.getInstance().bucket(\"xat-ad-9f901.appspot.com\") val blobs = bucket?.list() for (b in blobs!!.iterateAll()) nomIm.addItem(b.getName()) nomIm.addActionListener { agafar() } boto.addActionListener { guardar() } } fun agafar() { // Instruccions per agafar la imatge val blob = bucket?.get(nomIm.getSelectedItem().toString()) //Tercera manera de llegir: amb getContent per a carregar a un ByteArray im = blob!!.getContent() val image = ImageIO.read(im?.inputStream()) foto.setIcon(ImageIcon(image)) val nom = nomIm.getSelectedItem().toString().split(\".\") nomIm2.text = nom[0]+\"2.\"+nom[1] } fun guardar(){ bucket?.create(nomIm2.text,im,\"image/\"+nomIm2.text.split(\".\")[1]) } } fun main(args: Array<String>) { EventQueue.invokeLater { AgafarImatge_2().isVisible = true } } I aquest seria el resultat: 4.5.2.4 CS-IntelliJ: Exemple ampliat, combinant amb Cloud Firestore Anem a fer un altre exemple. Des d' IntelliJ nom\u00e9s ens plantegem accedir a Cloud Firestore i Cloud Storage per a agafar: De Cloud Firestore els documents de la col\u00b7lecci\u00f3 on est\u00e0 entre altres coses el nom de la imatge Amb aquest nom d'imatge anirem a Cloud Storage per a agafar-la D'aquesta manera ens queda una pantalla molt senzilla, pr\u00e0cticament com en l'exemple anterior, \u00e9s a dir amb un JComboBox amb el nom de les imatges, que ara agafarem de Cloud Firestore, i un JButton per a mostrar la imatge. Li posarem ara el nom de Exemple_8_5_3_FirebaseCF-CS_CoffeeShops .kt . El codi est\u00e0 simplificat al m\u00e0xim, llevant tractament d'errors i opcions. import javax.swing.JFrame import java.awt.EventQueue import javax.swing.JComboBox import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.cloud.storage.Bucket import com.google.firebase.cloud.StorageClient import javax.imageio.ImageIO import java.nio.ByteBuffer import java.io.ByteArrayInputStream import javax.swing.ImageIcon import javax.swing.JButton import com.google.firebase.cloud.FirestoreClient import com.google.cloud.firestore.Firestore class CoffeeShops : JFrame() { val nomCafe = JComboBox<String>() val foto = JButton() var bucket: Bucket? = null var database: Firestore? = null init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 900, 600) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(nomCafe) getContentPane().add(panell1, BorderLayout.NORTH) getContentPane().add(foto, BorderLayout.CENTER) val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-ee7dc206de.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) bucket = StorageClient.getInstance().bucket(\"xat-ad-9f901.appspot.com\") database = FirestoreClient.getFirestore() // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges database?.collection(\"CoffeeShops\")?.orderBy(\"nom\")?.addSnapshotListener { snapshots, e -> for (dc in snapshots!!.getDocumentChanges()) { nomCafe.addItem(dc.getDocument().getString(\"nom\")) } } nomCafe.addActionListener { agafar() } } fun agafar() { //Primer agafem el nom de la imatge mirant el document que t\u00e9 el nom com el triat //Despr\u00e9s agafem la imatge amb eixe nom database?.collection(\"CoffeeShops\")?.whereEqualTo(\"nom\", nomCafe.getSelectedItem())!! .addSnapshotListener { snapshots, e -> for (dc in snapshots!!.getDocumentChanges()) { val blob = bucket?.get(\"CoffeeShops/\" + dc.getDocument().getString(\"imatge\")) //Segona manera de llegir: muntant un reader per a carregar a un ByteBuffer val im = ByteBuffer.allocate(1024 * 1024) blob?.reader()?.read(im) val image = ImageIO.read(ByteArrayInputStream(im.array())) foto.setIcon(ImageIcon(image)) } } } } fun main(args: Array<String>) { EventQueue.invokeLater { CoffeeShops().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.5. - Cloud Storage (opcional)"},{"location":"AD_Firebase/5__cloud_storage/#45-cloud-storage","text":"Cloud Storage ens permet guardar fitxers c\u00f2modament: fotos, v\u00eddeos, audios, ... Combinat amb Reltime Database o Cloud Firestore ens permet guardar les nostres dedes de forma eficient, ja que podem guardar en les primeres les refer\u00e8ncies als fitxers que pugem al Storage. La utilitzaci\u00f3 d'estoratge no \u00e9s de gratis, per la qual cosa els exemples d'aquest apartat es faran sobre una base de dades externa (la mateixa que la de l'exercici 2) on s\u00ed que tindreu acc\u00e9s. Necessitareu el fitxer de connexi\u00f3 d'aquesta base de dades al que teniu com un recurs en l'aula virtual: xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json","title":"4.5 - Cloud Storage"},{"location":"AD_Firebase/5__cloud_storage/#451-cs-utilitzacio-des-de-lentorn","text":"L'entorn que ens ofereix Firebase per a gestionar Cloud Storage \u00e9s molt senzill i no t\u00e9 cap secret, ja que ens permetr\u00e0 pujar els fitxers, organitzant-los en subdirectoris, i tamb\u00e9 esborrar-los. En principi no necessitem m\u00e9s. Si punxem en un fitxer podrem veure les seues caracter\u00edstiques, i si el seleccionem podrem esborrar-lo o obrir-lo en una altra finestra. Aquest entorn, de tan senzill, fins i tot es queda un poc curt, ja que no ens permetr\u00e0 canviar el nom d'un fitxer, o moure'l a una carpeta, ... Si vulgu\u00e9rem fer algun canvi d'aquestos, canviar el nom o canviar de carpeta, ho haur\u00edem de fer des d'un altre lloc, un altre navegador del Google Cloud Storage ( https://console.cloud.google.com/storage/browser ): on es pot observar com en els 3 puntets de la dreta d'un fitxer ens apareixen moltes opcions com copiar, menejar, renomenar, ... Per\u00f2 nosaltres en principi tindrem prou amb la primera consola. Anem alerta de col\u00b7locar les coses al lloc, i si no estan, esborrem i col\u00b7loquem al lloc correcte. Ja que estem en la consola, controlem els permisos ( Rules ) en la pestanya corresponent de la consola: En aquesta imatge s'aprecia que no hi haur\u00e0 perm\u00eds per a llegir ni escriure fora de la consola. Com que el que volem \u00e9s accedir des de les aplicacions d'IntelliJ i d'Android, substituirem el perm\u00eds per aquest: allow read, write: if request.time < timestamp.date(2025, 6, 14); amb una data en la qual no ens pillem els dits. Nota Observeu com tant en la consola senzilla com en la del browser de GoogleCloud, ens posa una adre\u00e7a, que en el meu cas \u00e9s: gs://xat-ad-9f901.appspot.com . Es tracta de l'adre\u00e7a del bucket (poal, contenidor) on estan col\u00b7locats els fitxers. Podem crear m\u00e9s buckets , per\u00f2 no ho complicarem. Haurem de tenir clara la refer\u00e8ncia a aquest bucket per defecte.","title":"4.5.1 CS: Utilitzaci\u00f3 des de l'entorn"},{"location":"AD_Firebase/5__cloud_storage/#452-cs-utilitzacio-des-de-intellij","text":"Exemple Practicarem tot el que ve a continuaci\u00f3 sobre un programa gr\u00e0fic. Ser\u00e0 molt m\u00e9s senzill que en els casos anteriors, ja que de moment nom\u00e9s volem un lloc on tenir el nom de la imatge que volem baixar, i un lloc on visualitzar la imatge Aquest \u00e9s el seu esquelet. Guardeu-lo en un fitxer anomenat Exemple_8_5_1_FirebaseCS_AgafarImatge.kt : import javax.swing.JFrame import java.awt.EventQueue import javax.swing.JTextField import javax.swing.JButton import javax.swing.JLabel import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.cloud.storage.Bucket import com.google.firebase.cloud.StorageClient import javax.imageio.ImageIO import java.nio.ByteBuffer import java.io.ByteArrayInputStream import javax.swing.ImageIcon class AgafarImatge_1 : JFrame() { val nomIm = JTextField(25) val boto = JButton(\"Agafar\") val foto = JLabel() var bucket: Bucket? = null init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 900, 600) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(nomIm) panell1.add(boto) getContentPane().add(panell1, BorderLayout.NORTH) getContentPane().add(foto, BorderLayout.CENTER) boto.addActionListener { agafar() } } fun agafar() { // Instruccions per agafar la imatge } } fun main(args: Array<String>) { EventQueue.invokeLater { AgafarImatge_1().isVisible = true } }","title":"4.5.2 CS: Utilitzaci\u00f3 des de IntelliJ"},{"location":"AD_Firebase/5__cloud_storage/#4521-cs-intellij-connexio","text":"Configuraci\u00f3 No caldr\u00e0 fer refer\u00e8ncia a la URL de l'aplicaci\u00f3 Firebase, perqu\u00e8 quan especifiquem el bucket, li posarem l'adre\u00e7a i amb aix\u00f2 \u00e9s suficient. Recordeu que ens vam baixar un fitxer json amb la clau privada que vam guardar a l'arrel del projecte (i del qual \u00e9s molt convenient guardar c\u00f2pia). val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json\") val options = FirebaseOptions.Builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) Refer\u00e8ncia al bucket de Cloud Storage Ac\u00ed haurem de fer una refer\u00e8ncia expl\u00edcita al bucket que vam comentar en el punt anterior, mentre que en Android ens el podrem saltar, ja que la refer\u00e8ncia estar\u00e0 impl\u00edcitament. Ho farem a trav\u00e9s de StorageClient , mentre que en Android ser\u00e0 un altra classe.: bucket = StorageClient.getInstance().bucket(\"xat-ad-9f901.appspot.com\") Nota Podr\u00e9m haver-ho definit diferent, especificant el bucket en el moment de definir les opcions. Aleshores, en el moment de crear el bucket no caldria passar-li el par\u00e0metre. val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json\") val options = FirebaseOptions.Builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setStorageBucket(\"xat-ad-9f901.appspot.com\") .build() FirebaseApp.initializeApp(options) bucket StorageClient.getInstance().bucket()","title":"4.5.2.1 CS-IntelliJ: Connexi\u00f3"},{"location":"AD_Firebase/5__cloud_storage/#4522-cs-intellij-acces-a-les-dades","text":"Farem acc\u00e9s als fitxers de Cloud Storage per a llegir-los, per a baixar-los. Mencionarem el fet de guardar fitxers, per\u00f2 no l'utilitzarem tant. Ho farem per mig del m\u00e8tode get() del bucket , al qual li passarem el nom del fitxer que volem llegir, i ens tornar\u00e0 un blob (de cloud storage) amb el seu contingut. val blob = bucket?.get(nomIm.getText()) Aquest blob podrem agafar-lo de dues maneres: Baixant-lo a un fitxer temporal amb el m\u00e8tode downloadTo() Agafant-lo directament en mem\u00f2ria a un ByteBuffer de grand\u00e0ria suficient Agafant-lo directament en mem\u00f2ria a un ByteArray amb el m\u00e8tode getContent() i aleshores no cal especificar cap grand\u00e0ria (potser siga el m\u00e9s c\u00f2mode) De la primera manera ho far\u00edem aix\u00ed, baixem el fitxer a un fitxer auxiliar, i des d'alli el carreguem // Primera manera de llegir, amb un fitxer auxiliar val f = File(\"auxiliar\") blob?.downloadTo(FileOutputStream(f)) val image = ImageIO.read(f) foto.setIcon(ImageIcon(image)) De la segona manera ens muntem un reader (de Cloud Storage) per poder carregar-ho en mem\u00f2ria a un ByteBuffer //Segona manera de llegir: muntant un reader per a carregar a un ByteBuffer val im = ByteBuffer.allocate(1024 * 1024) blob?.reader()?.read(im) val image = ImageIO.read(ByteArrayInputStream(im.array())) foto.setIcon(ImageIcon(image)) La tercera manera, segurament \u00e9s la m\u00e9s c\u00f2moda, amb el m\u00e8tode getContent() , que ens torna el ByteArray . P //Tercera manera de llegir: amb getContent per a carregar a un ByteArray val im = blob?.getContent() val image = ImageIO.read(im?.inputStream()) foto.setIcon(ImageIcon(image)) Qualsevol de les tres maneres ens hauria de funcionar b\u00e9, col\u00b7locant juntament amb la definici\u00f3 del blob en la funci\u00f3 que s'executa en apretar el bot\u00f3, agafar() . I aquest seria el resultat: Altres m\u00e8todes del bucket que ens poden interessar s\u00f3n: get() : agafa un fitxer, passant-li el nom i tornant un blob . \u00c9s el que hem utiitzat. create() : serveix per a pujar un fitxer al bucket; se li passen 3 par\u00e0metres, el nom que tindr\u00e0 el fitxer en el Clousd Storage, el contingut que se li pot passar en forma de ByteArray o de InputStream, i el tipus de fitxer (per exemple \"image/png\" ) list() : torna un conjunt de blobs en forma de Page . De cada element blob podrem baixar-nos el contingut a un fitxer auxiliar, a un ByteBuffer, agafar el seu nom, ...","title":"4.5.2.2 CS-IntelliJ: Acc\u00e9s a les dades"},{"location":"AD_Firebase/5__cloud_storage/#4523-cs-intellij-tot-lexemple","text":"Anem a ajuntar tot l'exemple que visualitza una imatge guardada en Cloud Storage, modificant-lo un poc: Ens guardarem els noms de les imatges en un JComboBox . I per a visualitzar la imatge, en compte d'un JLabel utilitzarem un JButton , aix\u00ed la imatge quedara centrada tan horitzontal com verticalment. Per a provar la pujada d'imatges, proposarem un segon nom a la imatge, i un bot\u00f3. Si s'apreta es guardar\u00e0 la imatge amb el nom proposat (o canviat), aprofitant l'extensi\u00f3 del nom per a posar el tipus d'imatge El guardarem amb un altre nom, en el fitxer Kotlin Exemple_8_5_2_FirebaseCS_AgafarImatge .kt import javax.swing.JFrame import java.awt.EventQueue import javax.swing.JComboBox import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.cloud.storage.Bucket import com.google.firebase.cloud.StorageClient import javax.imageio.ImageIO import java.nio.ByteBuffer import java.io.ByteArrayInputStream import javax.swing.ImageIcon import javax.swing.JButton class AgafarImatge_2 : JFrame() { val nomIm = JComboBox<String>() val nomIm2 = JTextField(15) val boto = JButton(\"Guardar c\u00f2pia\") val foto = JButton() var bucket: Bucket? = null var im = byteArrayOf() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 900, 600) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(nomIm) getContentPane().add(panell1, BorderLayout.NORTH) getContentPane().add(foto, BorderLayout.CENTER) val panell2 = JPanel(FlowLayout()) panell2.add(nomIm2) panell2.add(boto) contentPane.add(panell2,BorderLayout.SOUTH) val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) bucket = StorageClient.getInstance().bucket(\"xat-ad-9f901.appspot.com\") val blobs = bucket?.list() for (b in blobs!!.iterateAll()) nomIm.addItem(b.getName()) nomIm.addActionListener { agafar() } boto.addActionListener { guardar() } } fun agafar() { // Instruccions per agafar la imatge val blob = bucket?.get(nomIm.getSelectedItem().toString()) //Tercera manera de llegir: amb getContent per a carregar a un ByteArray im = blob!!.getContent() val image = ImageIO.read(im?.inputStream()) foto.setIcon(ImageIcon(image)) val nom = nomIm.getSelectedItem().toString().split(\".\") nomIm2.text = nom[0]+\"2.\"+nom[1] } fun guardar(){ bucket?.create(nomIm2.text,im,\"image/\"+nomIm2.text.split(\".\")[1]) } } fun main(args: Array<String>) { EventQueue.invokeLater { AgafarImatge_2().isVisible = true } } I aquest seria el resultat:","title":"4.5.2.3 CS-IntelliJ: Tot l'exemple"},{"location":"AD_Firebase/5__cloud_storage/#4524-cs-intellij-exemple-ampliat-combinant-amb-cloud-firestore","text":"Anem a fer un altre exemple. Des d' IntelliJ nom\u00e9s ens plantegem accedir a Cloud Firestore i Cloud Storage per a agafar: De Cloud Firestore els documents de la col\u00b7lecci\u00f3 on est\u00e0 entre altres coses el nom de la imatge Amb aquest nom d'imatge anirem a Cloud Storage per a agafar-la D'aquesta manera ens queda una pantalla molt senzilla, pr\u00e0cticament com en l'exemple anterior, \u00e9s a dir amb un JComboBox amb el nom de les imatges, que ara agafarem de Cloud Firestore, i un JButton per a mostrar la imatge. Li posarem ara el nom de Exemple_8_5_3_FirebaseCF-CS_CoffeeShops .kt . El codi est\u00e0 simplificat al m\u00e0xim, llevant tractament d'errors i opcions. import javax.swing.JFrame import java.awt.EventQueue import javax.swing.JComboBox import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.cloud.storage.Bucket import com.google.firebase.cloud.StorageClient import javax.imageio.ImageIO import java.nio.ByteBuffer import java.io.ByteArrayInputStream import javax.swing.ImageIcon import javax.swing.JButton import com.google.firebase.cloud.FirestoreClient import com.google.cloud.firestore.Firestore class CoffeeShops : JFrame() { val nomCafe = JComboBox<String>() val foto = JButton() var bucket: Bucket? = null var database: Firestore? = null init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 900, 600) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(nomCafe) getContentPane().add(panell1, BorderLayout.NORTH) getContentPane().add(foto, BorderLayout.CENTER) val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-ee7dc206de.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) bucket = StorageClient.getInstance().bucket(\"xat-ad-9f901.appspot.com\") database = FirestoreClient.getFirestore() // Exemple de listener de lectura cont\u00ednua addSnapshotListener() sobre una col\u00b7lecci\u00f3 // Per a posar tota la llista de missatges. Sobre /Xats/XatProva/missatges database?.collection(\"CoffeeShops\")?.orderBy(\"nom\")?.addSnapshotListener { snapshots, e -> for (dc in snapshots!!.getDocumentChanges()) { nomCafe.addItem(dc.getDocument().getString(\"nom\")) } } nomCafe.addActionListener { agafar() } } fun agafar() { //Primer agafem el nom de la imatge mirant el document que t\u00e9 el nom com el triat //Despr\u00e9s agafem la imatge amb eixe nom database?.collection(\"CoffeeShops\")?.whereEqualTo(\"nom\", nomCafe.getSelectedItem())!! .addSnapshotListener { snapshots, e -> for (dc in snapshots!!.getDocumentChanges()) { val blob = bucket?.get(\"CoffeeShops/\" + dc.getDocument().getString(\"imatge\")) //Segona manera de llegir: muntant un reader per a carregar a un ByteBuffer val im = ByteBuffer.allocate(1024 * 1024) blob?.reader()?.read(im) val image = ImageIO.read(ByteArrayInputStream(im.array())) foto.setIcon(ImageIcon(image)) } } } } fun main(args: Array<String>) { EventQueue.invokeLater { CoffeeShops().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4.5.2.4 CS-IntelliJ: Exemple ampliat, combinant amb Cloud Firestore"},{"location":"AD_Firebase/exercicis/","text":"Exercicis Exercici 1 (Realtime Database) Farem una aplicaci\u00f3 per a agafar unes dades corresponents a unes estad\u00edstiques guardades en Realtime Database de Firebase . Per no haver de substuir les dades que ja teniu, podeu crear-vos un nou projecte, per exemple, ExercicisAD , i en una base de dades RealtimeDatabase importar el fitxer variaciopoblacional.json , al que teniu com un recurs a l'aula virtual. La informaci\u00f3 a la qual volem accedir est\u00e0 en el array EstadisticaVariacioPoblacional amb les prov\u00edncies, i en cada prov\u00edncia tenim el nom ( Nombre ) i en un array anomenat Data tenim diferents anys amb el n\u00famero d'any i el valor de la variaci\u00f3 de la poblaci\u00f3: Podeu utilitzar el \"esquelet\" que hi ha a continuaci\u00f3. En ell tenim: Un JCombobox per a triar la prov\u00edncia Un JTextArea, per a mostrar les dades de la prov\u00edncia triada Haureu d'incorporar el fitxer json on est\u00e0 la configuraci\u00f3 i la clau privada de la connexi\u00f3. L'aplicaci\u00f3 ha de agafar les prov\u00edncies (observeu que estan en una llista) i guardar-les en un JComboBox, per a poder triar-les. Quan es trie una prov\u00edncia, s'haur\u00e0 de mostrar en el JTextArea la informaci\u00f3 corresponent a la prov\u00edncia, agafant tots els anys de l'array Data (observeu que tamb\u00e9 \u00e9s una llista) i mostrar l'any i el valor de la variaci\u00f3 poblacional (respectivament NombrePeriodo i Valor ). No cal agafar tota la EstadisticaVariacioPoblacional. Podeu anar directament a un element de l'array. Per exemple EstadisticaVariacioPoblacional/0/Data fa refer\u00e8ncia a les dades de la primera prov\u00edncia A continuaci\u00f3 teniu l'esquelet del programa que podeu utilitzar, que el podeu guardar en el fitxer Kotlin T8Ex1_EstadisticaRD.kt : import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JComboBox import javax.swing.JTextArea import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.* import java.awt.EventQueue class EstadisticaRD : JFrame() { val etProv = JLabel(\"Provincia: \") val provincia = JComboBox<String>() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 450) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(etProv) panell1.add(provincia) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) setVisible(true) val serviceAccount = FileInputStream(\"path/to/your-credentials.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://<your-database-name>\").build() FirebaseApp.initializeApp(options) // Posar tota la llista de prov\u00edncies al JComboBox anomenat provincia provincia.addActionListener() { // Posar la informaci\u00f3 de tots els anys en el JTextArea anomenat area } } } fun main(args: Array<String>) { EventQueue.invokeLater { EstadisticaRD().isVisible = true } } Exercici 2 (Cloud Firestore) Farem un exercici paregut a l'anterior, per\u00f2 ara les dades estaran guardades en Cloud Firestore , d'una base de dades externa, per tant, haureu d'incorporar el fitxer json on est\u00e0 la configuraci\u00f3 i la clau privada de la connexi\u00f3, al que teniu com un recurs en l'aula virtual: xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json A la base de dades hi ha una col.lecci\u00f3, Estadistica , on tindrem un document per cada prov\u00edncia i any, amb la poblaci\u00f3 de dones i homes. Per tant, com que hi ha 52 prov\u00edncies i 10 anys d'estad\u00edstiques, tindrem un total de 520 documents. Com es veu en la imatge, en cada document es guarda: la prov\u00edncia, l'any, el n\u00famero de dones i el n\u00famero d'homes. Podeu utilitzar el \"esquelet\" que hi ha a continuaci\u00f3. En ell tenim: Un JCombobox per a triar la prov\u00edncia Un JTextArea, per a mostrar les dades de la prov\u00edncia triada L'aplicaci\u00f3 ha de agafar les prov\u00edncies per a guardar-les en un JComboBox i poder triar-les, per\u00f2 tenint en compte que eixiran repetides (concretament 10 vegades cada prov\u00edncia). Podeu afegir-les a un Mutable Set per a evitar que estiguen repetides, ja que un set es defineix com un conjunt no ordenat de valors que no es poden repetir. Aix\u00ed, si afegim un valor que ja estava, senzillament no el repetir\u00e0. Despr\u00e9s nom\u00e9s haureu d'ordenar aquest set. Quan es trie una prov\u00edncia, s'haur\u00e0 de mostrar en el JTextArea la informaci\u00f3 corresponent a la prov\u00edncia, agafant tots els documents d'aquesta prov\u00edncia, i millor ordenar-los per l'any. S'haur\u00e0 de mostrar aquest any, i el n\u00famero de dones i d'homes (respectivament any , Dones i Homes ) Aquest seria l'aspecte: I aquest seria l'esquelet, que podeu guardar amb el nom T8Ex2_EstadisticaCF.kt : import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JComboBox import javax.swing.JTextArea import java.awt.BorderLayout import java.awt.FlowLayout import javax.swing.JPanel import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.cloud.FirestoreClient import java.awt.EventQueue class EstadisticaCF : JFrame() { val etCombo = JLabel(\"Llista de prov\u00edncies:\") val comboProv = JComboBox<String>() val etiqueta = JLabel(\"Estad\u00edstiques:\") val area = JTextArea() // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 400) setLayout(BorderLayout()) // contenidor per als elements val panell1 = JPanel(FlowLayout()) panell1.add(etCombo) panell1.add(comboProv) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) setVisible(true) val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-ee7dc206de.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) val db = FirestoreClient.getFirestore() // Instruccions per a omplir el JComboBox amb les prov\u00edncies // Instruccions per agafar la informaci\u00f3 de tots els anys de la prov\u00edncia triada comboProv.addActionListener() { } } } fun main(args: Array<String>) { EventQueue.invokeLater { EstadisticaCF().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercicis"},{"location":"AD_Firebase/exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"AD_Firebase/exercicis/#exercici-1-realtime-database","text":"Farem una aplicaci\u00f3 per a agafar unes dades corresponents a unes estad\u00edstiques guardades en Realtime Database de Firebase . Per no haver de substuir les dades que ja teniu, podeu crear-vos un nou projecte, per exemple, ExercicisAD , i en una base de dades RealtimeDatabase importar el fitxer variaciopoblacional.json , al que teniu com un recurs a l'aula virtual. La informaci\u00f3 a la qual volem accedir est\u00e0 en el array EstadisticaVariacioPoblacional amb les prov\u00edncies, i en cada prov\u00edncia tenim el nom ( Nombre ) i en un array anomenat Data tenim diferents anys amb el n\u00famero d'any i el valor de la variaci\u00f3 de la poblaci\u00f3: Podeu utilitzar el \"esquelet\" que hi ha a continuaci\u00f3. En ell tenim: Un JCombobox per a triar la prov\u00edncia Un JTextArea, per a mostrar les dades de la prov\u00edncia triada Haureu d'incorporar el fitxer json on est\u00e0 la configuraci\u00f3 i la clau privada de la connexi\u00f3. L'aplicaci\u00f3 ha de agafar les prov\u00edncies (observeu que estan en una llista) i guardar-les en un JComboBox, per a poder triar-les. Quan es trie una prov\u00edncia, s'haur\u00e0 de mostrar en el JTextArea la informaci\u00f3 corresponent a la prov\u00edncia, agafant tots els anys de l'array Data (observeu que tamb\u00e9 \u00e9s una llista) i mostrar l'any i el valor de la variaci\u00f3 poblacional (respectivament NombrePeriodo i Valor ). No cal agafar tota la EstadisticaVariacioPoblacional. Podeu anar directament a un element de l'array. Per exemple EstadisticaVariacioPoblacional/0/Data fa refer\u00e8ncia a les dades de la primera prov\u00edncia A continuaci\u00f3 teniu l'esquelet del programa que podeu utilitzar, que el podeu guardar en el fitxer Kotlin T8Ex1_EstadisticaRD.kt : import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JComboBox import javax.swing.JTextArea import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.database.* import java.awt.EventQueue class EstadisticaRD : JFrame() { val etProv = JLabel(\"Provincia: \") val provincia = JComboBox<String>() val etiqueta = JLabel(\"Missatges:\") val area = JTextArea() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 450) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(etProv) panell1.add(provincia) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) setVisible(true) val serviceAccount = FileInputStream(\"path/to/your-credentials.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://<your-database-name>\").build() FirebaseApp.initializeApp(options) // Posar tota la llista de prov\u00edncies al JComboBox anomenat provincia provincia.addActionListener() { // Posar la informaci\u00f3 de tots els anys en el JTextArea anomenat area } } } fun main(args: Array<String>) { EventQueue.invokeLater { EstadisticaRD().isVisible = true } }","title":"Exercici 1 (Realtime Database)"},{"location":"AD_Firebase/exercicis/#exercici-2-cloud-firestore","text":"Farem un exercici paregut a l'anterior, per\u00f2 ara les dades estaran guardades en Cloud Firestore , d'una base de dades externa, per tant, haureu d'incorporar el fitxer json on est\u00e0 la configuraci\u00f3 i la clau privada de la connexi\u00f3, al que teniu com un recurs en l'aula virtual: xat-ad-9f901-firebase-adminsdk-f1vja-b8957819d1.json A la base de dades hi ha una col.lecci\u00f3, Estadistica , on tindrem un document per cada prov\u00edncia i any, amb la poblaci\u00f3 de dones i homes. Per tant, com que hi ha 52 prov\u00edncies i 10 anys d'estad\u00edstiques, tindrem un total de 520 documents. Com es veu en la imatge, en cada document es guarda: la prov\u00edncia, l'any, el n\u00famero de dones i el n\u00famero d'homes. Podeu utilitzar el \"esquelet\" que hi ha a continuaci\u00f3. En ell tenim: Un JCombobox per a triar la prov\u00edncia Un JTextArea, per a mostrar les dades de la prov\u00edncia triada L'aplicaci\u00f3 ha de agafar les prov\u00edncies per a guardar-les en un JComboBox i poder triar-les, per\u00f2 tenint en compte que eixiran repetides (concretament 10 vegades cada prov\u00edncia). Podeu afegir-les a un Mutable Set per a evitar que estiguen repetides, ja que un set es defineix com un conjunt no ordenat de valors que no es poden repetir. Aix\u00ed, si afegim un valor que ja estava, senzillament no el repetir\u00e0. Despr\u00e9s nom\u00e9s haureu d'ordenar aquest set. Quan es trie una prov\u00edncia, s'haur\u00e0 de mostrar en el JTextArea la informaci\u00f3 corresponent a la prov\u00edncia, agafant tots els documents d'aquesta prov\u00edncia, i millor ordenar-los per l'any. S'haur\u00e0 de mostrar aquest any, i el n\u00famero de dones i d'homes (respectivament any , Dones i Homes ) Aquest seria l'aspecte: I aquest seria l'esquelet, que podeu guardar amb el nom T8Ex2_EstadisticaCF.kt : import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JComboBox import javax.swing.JTextArea import java.awt.BorderLayout import java.awt.FlowLayout import javax.swing.JPanel import java.awt.Color import javax.swing.JScrollPane import java.io.FileInputStream import com.google.firebase.FirebaseOptions import com.google.auth.oauth2.GoogleCredentials import com.google.firebase.FirebaseApp import com.google.firebase.cloud.FirestoreClient import java.awt.EventQueue class EstadisticaCF : JFrame() { val etCombo = JLabel(\"Llista de prov\u00edncies:\") val comboProv = JComboBox<String>() val etiqueta = JLabel(\"Estad\u00edstiques:\") val area = JTextArea() // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 450, 400) setLayout(BorderLayout()) // contenidor per als elements val panell1 = JPanel(FlowLayout()) panell1.add(etCombo) panell1.add(comboProv) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) area.setEditable(false) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) setVisible(true) val serviceAccount = FileInputStream(\"xat-ad-9f901-firebase-adminsdk-f1vja-ee7dc206de.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .build() FirebaseApp.initializeApp(options) val db = FirestoreClient.getFirestore() // Instruccions per a omplir el JComboBox amb les prov\u00edncies // Instruccions per agafar la informaci\u00f3 de tots els anys de la prov\u00edncia triada comboProv.addActionListener() { } } } fun main(args: Array<String>) { EventQueue.invokeLater { EstadisticaCF().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercici 2 (Cloud Firestore)"}]}